package generator

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"

	"github.com/carlosnayan/prisma-go-client/internal/migrations"
	"github.com/carlosnayan/prisma-go-client/internal/parser"
)

// GenerateDriver generates the driver.go file based on the provider in the schema
func GenerateDriver(schema *parser.Schema, outputDir string) error {
	driverFile := filepath.Join(outputDir, "driver.go")
	if err := os.MkdirAll(outputDir, 0755); err != nil {
		return fmt.Errorf("erro ao criar diret√≥rio: %w", err)
	}

	// Get provider from schema
	provider := migrations.GetProviderFromSchema(schema)
	provider = strings.ToLower(provider)

	file, err := os.Create(driverFile)
	if err != nil {
		return err
	}
	defer file.Close()

	// Header
	fmt.Fprintf(file, "// Code generated by prisma generate. DO NOT EDIT.\n")
	fmt.Fprintf(file, "package db\n\n")

	// Generate driver code based on provider
	switch provider {
	case "postgresql":
		generatePostgreSQLDriver(file)
	case "mysql":
		generateMySQLDriver(file)
	case "sqlite":
		generateSQLiteDriver(file)
	default:
		// Default to PostgreSQL
		generatePostgreSQLDriver(file)
	}

	return nil
}

// generatePostgreSQLDriver generates driver code for PostgreSQL using pgx
func generatePostgreSQLDriver(file *os.File) {
	fmt.Fprintf(file, "import (\n")
	fmt.Fprintf(file, "\t\"context\"\n")
	fmt.Fprintf(file, "\t\"database/sql\"\n")
	fmt.Fprintf(file, "\t\"fmt\"\n")
	fmt.Fprintf(file, "\t\"os\"\n\n")
	fmt.Fprintf(file, "\t\"github.com/carlosnayan/prisma-go-client/builder\"\n")
	fmt.Fprintf(file, "\t\"github.com/jackc/pgx/v5\"\n")
	fmt.Fprintf(file, "\t\"github.com/jackc/pgx/v5/pgconn\"\n")
	fmt.Fprintf(file, "\t\"github.com/jackc/pgx/v5/pgxpool\"\n")
	fmt.Fprintf(file, ")\n\n")

	// PgxPoolAdapter type
	fmt.Fprintf(file, "// PgxPoolAdapter adapts *pgxpool.Pool to builder.DBTX\n")
	fmt.Fprintf(file, "type PgxPoolAdapter struct {\n")
	fmt.Fprintf(file, "\tpool *pgxpool.Pool\n")
	fmt.Fprintf(file, "}\n\n")

	// NewPgxPoolDriver function
	fmt.Fprintf(file, "// NewPgxPoolDriver creates a new driver adapter from a pgxpool.Pool\n")
	fmt.Fprintf(file, "// This allows you to use pgx pool with the Prisma client without\n")
	fmt.Fprintf(file, "// importing internal packages.\n")
	fmt.Fprintf(file, "func NewPgxPoolDriver(pool *pgxpool.Pool) builder.DBTX {\n")
	fmt.Fprintf(file, "\treturn &PgxPoolAdapter{pool: pool}\n")
	fmt.Fprintf(file, "}\n\n")

	// NewPgxPoolFromURL function - creates pool with PgBouncer-compatible settings
	fmt.Fprintf(file, "// NewPgxPoolFromURL creates a new pgx pool from a database URL\n")
	fmt.Fprintf(file, "// with PgBouncer-compatible settings (prepared statements disabled).\n")
	fmt.Fprintf(file, "// This is the recommended way to create a pool for use with NewPgxPoolDriver.\n")
	fmt.Fprintf(file, "// Example: pool, err := db.NewPgxPoolFromURL(ctx, databaseURL)\n")
	fmt.Fprintf(file, "func NewPgxPoolFromURL(ctx context.Context, databaseURL string) (*pgxpool.Pool, error) {\n")
	fmt.Fprintf(file, "\tcfg, err := pgxpool.ParseConfig(databaseURL)\n")
	fmt.Fprintf(file, "\tif err != nil {\n")
	fmt.Fprintf(file, "\t\treturn nil, fmt.Errorf(\"error parsing database URL: %%w\", err)\n")
	fmt.Fprintf(file, "\t}\n\n")
	fmt.Fprintf(file, "\t// Disable prepared statements for PgBouncer compatibility\n")
	fmt.Fprintf(file, "\tcfg.ConnConfig.DefaultQueryExecMode = pgx.QueryExecModeSimpleProtocol\n\n")
	fmt.Fprintf(file, "\tpool, err := pgxpool.NewWithConfig(ctx, cfg)\n")
	fmt.Fprintf(file, "\tif err != nil {\n")
	fmt.Fprintf(file, "\t\treturn nil, fmt.Errorf(\"error creating pool: %%w\", err)\n")
	fmt.Fprintf(file, "\t}\n\n")
	fmt.Fprintf(file, "\treturn pool, nil\n")
	fmt.Fprintf(file, "}\n\n")

	// Implement DBTX interface methods
	fmt.Fprintf(file, "// Exec executes a query that doesn't return rows\n")
	fmt.Fprintf(file, "func (a *PgxPoolAdapter) Exec(ctx context.Context, sql string, args ...interface{}) (builder.Result, error) {\n")
	fmt.Fprintf(file, "\tresult, err := a.pool.Exec(ctx, sql, args...)\n")
	fmt.Fprintf(file, "\tif err != nil {\n")
	fmt.Fprintf(file, "\t\treturn nil, err\n")
	fmt.Fprintf(file, "\t}\n")
	fmt.Fprintf(file, "\treturn &PgxResult{result: result}, nil\n")
	fmt.Fprintf(file, "}\n\n")

	fmt.Fprintf(file, "// Query executes a query that returns multiple rows\n")
	fmt.Fprintf(file, "func (a *PgxPoolAdapter) Query(ctx context.Context, sql string, args ...interface{}) (builder.Rows, error) {\n")
	fmt.Fprintf(file, "\trows, err := a.pool.Query(ctx, sql, args...)\n")
	fmt.Fprintf(file, "\tif err != nil {\n")
	fmt.Fprintf(file, "\t\treturn nil, err\n")
	fmt.Fprintf(file, "\t}\n")
	fmt.Fprintf(file, "\treturn &PgxRows{rows: rows}, nil\n")
	fmt.Fprintf(file, "}\n\n")

	fmt.Fprintf(file, "// QueryRow executes a query that returns a single row\n")
	fmt.Fprintf(file, "func (a *PgxPoolAdapter) QueryRow(ctx context.Context, sql string, args ...interface{}) builder.Row {\n")
	fmt.Fprintf(file, "\treturn &PgxRow{row: a.pool.QueryRow(ctx, sql, args...)}\n")
	fmt.Fprintf(file, "}\n\n")

	fmt.Fprintf(file, "// Begin starts a transaction\n")
	fmt.Fprintf(file, "func (a *PgxPoolAdapter) Begin(ctx context.Context) (builder.Tx, error) {\n")
	fmt.Fprintf(file, "\ttx, err := a.pool.Begin(ctx)\n")
	fmt.Fprintf(file, "\tif err != nil {\n")
	fmt.Fprintf(file, "\t\treturn nil, err\n")
	fmt.Fprintf(file, "\t}\n")
	fmt.Fprintf(file, "\treturn &PgxTx{tx: tx}, nil\n")
	fmt.Fprintf(file, "}\n\n")

	fmt.Fprintf(file, "// SQLDB returns nil as pgxpool.Pool doesn't provide *sql.DB directly\n")
	fmt.Fprintf(file, "func (a *PgxPoolAdapter) SQLDB() *sql.DB {\n")
	fmt.Fprintf(file, "\treturn nil\n")
	fmt.Fprintf(file, "}\n\n")

	// PgxResult type
	fmt.Fprintf(file, "// PgxResult wraps pgconn.CommandTag\n")
	fmt.Fprintf(file, "type PgxResult struct {\n")
	fmt.Fprintf(file, "\tresult pgconn.CommandTag\n")
	fmt.Fprintf(file, "}\n\n")

	fmt.Fprintf(file, "// RowsAffected returns the number of rows affected\n")
	fmt.Fprintf(file, "func (r *PgxResult) RowsAffected() int64 {\n")
	fmt.Fprintf(file, "\treturn r.result.RowsAffected()\n")
	fmt.Fprintf(file, "}\n\n")

	// PgxRows type
	fmt.Fprintf(file, "// PgxRows wraps pgx.Rows\n")
	fmt.Fprintf(file, "type PgxRows struct {\n")
	fmt.Fprintf(file, "\trows pgx.Rows\n")
	fmt.Fprintf(file, "}\n\n")

	fmt.Fprintf(file, "// Close closes the rows iterator\n")
	fmt.Fprintf(file, "func (r *PgxRows) Close() {\n")
	fmt.Fprintf(file, "\tr.rows.Close()\n")
	fmt.Fprintf(file, "}\n\n")

	fmt.Fprintf(file, "// Err returns any error that occurred during iteration\n")
	fmt.Fprintf(file, "func (r *PgxRows) Err() error {\n")
	fmt.Fprintf(file, "\treturn r.rows.Err()\n")
	fmt.Fprintf(file, "}\n\n")

	fmt.Fprintf(file, "// Next prepares the next result row for reading\n")
	fmt.Fprintf(file, "func (r *PgxRows) Next() bool {\n")
	fmt.Fprintf(file, "\treturn r.rows.Next()\n")
	fmt.Fprintf(file, "}\n\n")

	fmt.Fprintf(file, "// Scan copies the columns in the current row into the values pointed at by dest\n")
	fmt.Fprintf(file, "func (r *PgxRows) Scan(dest ...interface{}) error {\n")
	fmt.Fprintf(file, "\treturn r.rows.Scan(dest...)\n")
	fmt.Fprintf(file, "}\n\n")

	// PgxRow type
	fmt.Fprintf(file, "// PgxRow wraps pgx.Row\n")
	fmt.Fprintf(file, "type PgxRow struct {\n")
	fmt.Fprintf(file, "\trow pgx.Row\n")
	fmt.Fprintf(file, "}\n\n")

	fmt.Fprintf(file, "// Scan copies the columns in the current row into the values pointed at by dest\n")
	fmt.Fprintf(file, "func (r *PgxRow) Scan(dest ...interface{}) error {\n")
	fmt.Fprintf(file, "\treturn r.row.Scan(dest...)\n")
	fmt.Fprintf(file, "}\n\n")

	// PgxTx type
	fmt.Fprintf(file, "// PgxTx wraps pgx.Tx\n")
	fmt.Fprintf(file, "type PgxTx struct {\n")
	fmt.Fprintf(file, "\ttx pgx.Tx\n")
	fmt.Fprintf(file, "}\n\n")

	fmt.Fprintf(file, "// Commit commits the transaction\n")
	fmt.Fprintf(file, "func (t *PgxTx) Commit(ctx context.Context) error {\n")
	fmt.Fprintf(file, "\treturn t.tx.Commit(ctx)\n")
	fmt.Fprintf(file, "}\n\n")

	fmt.Fprintf(file, "// Rollback rolls back the transaction\n")
	fmt.Fprintf(file, "func (t *PgxTx) Rollback(ctx context.Context) error {\n")
	fmt.Fprintf(file, "\treturn t.tx.Rollback(ctx)\n")
	fmt.Fprintf(file, "}\n\n")

	fmt.Fprintf(file, "// Exec executes a query that doesn't return rows\n")
	fmt.Fprintf(file, "func (t *PgxTx) Exec(ctx context.Context, sql string, args ...interface{}) (builder.Result, error) {\n")
	fmt.Fprintf(file, "\tresult, err := t.tx.Exec(ctx, sql, args...)\n")
	fmt.Fprintf(file, "\tif err != nil {\n")
	fmt.Fprintf(file, "\t\treturn nil, err\n")
	fmt.Fprintf(file, "\t}\n")
	fmt.Fprintf(file, "\treturn &PgxResult{result: result}, nil\n")
	fmt.Fprintf(file, "}\n\n")

	fmt.Fprintf(file, "// Query executes a query that returns multiple rows\n")
	fmt.Fprintf(file, "func (t *PgxTx) Query(ctx context.Context, sql string, args ...interface{}) (builder.Rows, error) {\n")
	fmt.Fprintf(file, "\trows, err := t.tx.Query(ctx, sql, args...)\n")
	fmt.Fprintf(file, "\tif err != nil {\n")
	fmt.Fprintf(file, "\t\treturn nil, err\n")
	fmt.Fprintf(file, "\t}\n")
	fmt.Fprintf(file, "\treturn &PgxRows{rows: rows}, nil\n")
	fmt.Fprintf(file, "}\n\n")

	fmt.Fprintf(file, "// QueryRow executes a query that returns a single row\n")
	fmt.Fprintf(file, "func (t *PgxTx) QueryRow(ctx context.Context, sql string, args ...interface{}) builder.Row {\n")
	fmt.Fprintf(file, "\trow := t.tx.QueryRow(ctx, sql, args...)\n")
	fmt.Fprintf(file, "\treturn &PgxRow{row: row}\n")
	fmt.Fprintf(file, "}\n\n")

	// NewSQLDriver function
	fmt.Fprintf(file, "// NewSQLDriver creates a new driver adapter from a *sql.DB\n")
	fmt.Fprintf(file, "// This allows you to use database/sql with the Prisma client without\n")
	fmt.Fprintf(file, "// importing internal packages.\n")
	fmt.Fprintf(file, "// Note: For PostgreSQL, prefer NewPgxPoolDriver for better performance.\n")
	fmt.Fprintf(file, "func NewSQLDriver(db *sql.DB) builder.DBTX {\n")
	fmt.Fprintf(file, "\treturn &SQLDBAdapter{db: db}\n")
	fmt.Fprintf(file, "}\n\n")

	// SetupClient function - automatic setup from DATABASE_URL
	fmt.Fprintf(file, "// SetupClient creates a new Prisma client from DATABASE_URL environment variable\n")
	fmt.Fprintf(file, "// This function handles all the setup automatically:\n")
	fmt.Fprintf(file, "// - Parses DATABASE_URL\n")
	fmt.Fprintf(file, "// - Creates pgx pool with PgBouncer-compatible settings (prepared statements disabled)\n")
	fmt.Fprintf(file, "// - Pings the database to verify connection\n")
	fmt.Fprintf(file, "// - Returns a ready-to-use client\n")
	fmt.Fprintf(file, "// Example: client, pool, err := db.SetupClient(ctx)\n")
	fmt.Fprintf(file, "func SetupClient(ctx context.Context) (*Client, *pgxpool.Pool, error) {\n")
	fmt.Fprintf(file, "\tdatabaseURL := os.Getenv(\"DATABASE_URL\")\n")
	fmt.Fprintf(file, "\tif databaseURL == \"\" {\n")
	fmt.Fprintf(file, "\t\treturn nil, nil, fmt.Errorf(\"DATABASE_URL environment variable is not set\")\n")
	fmt.Fprintf(file, "\t}\n\n")
	fmt.Fprintf(file, "\tpool, err := NewPgxPoolFromURL(ctx, databaseURL)\n")
	fmt.Fprintf(file, "\tif err != nil {\n")
	fmt.Fprintf(file, "\t\treturn nil, nil, err\n")
	fmt.Fprintf(file, "\t}\n\n")
	fmt.Fprintf(file, "\tif err := pool.Ping(ctx); err != nil {\n")
	fmt.Fprintf(file, "\t\tpool.Close()\n")
	fmt.Fprintf(file, "\t\treturn nil, nil, fmt.Errorf(\"error pinging database: %%w\", err)\n")
	fmt.Fprintf(file, "\t}\n\n")
	fmt.Fprintf(file, "\tdbDriver := NewPgxPoolDriver(pool)\n")
	fmt.Fprintf(file, "\tclient := NewClient(dbDriver)\n\n")
	fmt.Fprintf(file, "\treturn client, pool, nil\n")
	fmt.Fprintf(file, "}\n\n")

	// SQLDBAdapter type (shared with MySQL and SQLite)
	generateSQLDBAdapter(file)
}

// generateMySQLDriver generates driver code for MySQL
func generateMySQLDriver(file *os.File) {
	fmt.Fprintf(file, "import (\n")
	fmt.Fprintf(file, "\t\"context\"\n")
	fmt.Fprintf(file, "\t\"database/sql\"\n")
	fmt.Fprintf(file, "\t\"fmt\"\n")
	fmt.Fprintf(file, "\t\"os\"\n\n")
	fmt.Fprintf(file, "\t\"github.com/carlosnayan/prisma-go-client/builder\"\n")
	fmt.Fprintf(file, "\t_ \"github.com/go-sql-driver/mysql\"\n")
	fmt.Fprintf(file, ")\n\n")

	fmt.Fprintf(file, "// NewSQLDriver creates a new driver adapter from a *sql.DB\n")
	fmt.Fprintf(file, "// This allows you to use database/sql with the Prisma client without\n")
	fmt.Fprintf(file, "// importing internal packages.\n")
	fmt.Fprintf(file, "func NewSQLDriver(db *sql.DB) builder.DBTX {\n")
	fmt.Fprintf(file, "\treturn &SQLDBAdapter{db: db}\n")
	fmt.Fprintf(file, "}\n\n")

	// SetupClient function - automatic setup from DATABASE_URL
	fmt.Fprintf(file, "// SetupClient creates a new Prisma client from DATABASE_URL environment variable\n")
	fmt.Fprintf(file, "// This function handles all the setup automatically:\n")
	fmt.Fprintf(file, "// - Opens database connection from DATABASE_URL\n")
	fmt.Fprintf(file, "// - Pings the database to verify connection\n")
	fmt.Fprintf(file, "// - Returns a ready-to-use client\n")
	fmt.Fprintf(file, "// Example: client, db, err := db.SetupClient(ctx)\n")
	fmt.Fprintf(file, "func SetupClient(ctx context.Context) (*Client, *sql.DB, error) {\n")
	fmt.Fprintf(file, "\tdatabaseURL := os.Getenv(\"DATABASE_URL\")\n")
	fmt.Fprintf(file, "\tif databaseURL == \"\" {\n")
	fmt.Fprintf(file, "\t\treturn nil, nil, fmt.Errorf(\"DATABASE_URL environment variable is not set\")\n")
	fmt.Fprintf(file, "\t}\n\n")
	fmt.Fprintf(file, "\tdb, err := sql.Open(\"mysql\", databaseURL)\n")
	fmt.Fprintf(file, "\tif err != nil {\n")
	fmt.Fprintf(file, "\t\treturn nil, nil, fmt.Errorf(\"error opening database: %%w\", err)\n")
	fmt.Fprintf(file, "\t}\n\n")
	fmt.Fprintf(file, "\tif err := db.PingContext(ctx); err != nil {\n")
	fmt.Fprintf(file, "\t\tdb.Close()\n")
	fmt.Fprintf(file, "\t\treturn nil, nil, fmt.Errorf(\"error pinging database: %%w\", err)\n")
	fmt.Fprintf(file, "\t}\n\n")
	fmt.Fprintf(file, "\tdbDriver := NewSQLDriver(db)\n")
	fmt.Fprintf(file, "\tclient := NewClient(dbDriver)\n\n")
	fmt.Fprintf(file, "\treturn client, db, nil\n")
	fmt.Fprintf(file, "}\n\n")

	// SQLDBAdapter type
	generateSQLDBAdapter(file)
}

// generateSQLiteDriver generates driver code for SQLite
func generateSQLiteDriver(file *os.File) {
	fmt.Fprintf(file, "import (\n")
	fmt.Fprintf(file, "\t\"context\"\n")
	fmt.Fprintf(file, "\t\"database/sql\"\n")
	fmt.Fprintf(file, "\t\"fmt\"\n")
	fmt.Fprintf(file, "\t\"os\"\n\n")
	fmt.Fprintf(file, "\t\"github.com/carlosnayan/prisma-go-client/builder\"\n")
	fmt.Fprintf(file, "\t_ \"github.com/mattn/go-sqlite3\"\n")
	fmt.Fprintf(file, ")\n\n")

	fmt.Fprintf(file, "// NewSQLDriver creates a new driver adapter from a *sql.DB\n")
	fmt.Fprintf(file, "// This allows you to use database/sql with the Prisma client without\n")
	fmt.Fprintf(file, "// importing internal packages.\n")
	fmt.Fprintf(file, "func NewSQLDriver(db *sql.DB) builder.DBTX {\n")
	fmt.Fprintf(file, "\treturn &SQLDBAdapter{db: db}\n")
	fmt.Fprintf(file, "}\n\n")

	// SetupClient function - automatic setup from DATABASE_URL
	fmt.Fprintf(file, "// SetupClient creates a new Prisma client from DATABASE_URL environment variable\n")
	fmt.Fprintf(file, "// This function handles all the setup automatically:\n")
	fmt.Fprintf(file, "// - Opens database connection from DATABASE_URL\n")
	fmt.Fprintf(file, "// - Pings the database to verify connection\n")
	fmt.Fprintf(file, "// - Returns a ready-to-use client\n")
	fmt.Fprintf(file, "// Example: client, db, err := db.SetupClient(ctx)\n")
	fmt.Fprintf(file, "func SetupClient(ctx context.Context) (*Client, *sql.DB, error) {\n")
	fmt.Fprintf(file, "\tdatabaseURL := os.Getenv(\"DATABASE_URL\")\n")
	fmt.Fprintf(file, "\tif databaseURL == \"\" {\n")
	fmt.Fprintf(file, "\t\treturn nil, nil, fmt.Errorf(\"DATABASE_URL environment variable is not set\")\n")
	fmt.Fprintf(file, "\t}\n\n")
	fmt.Fprintf(file, "\tdb, err := sql.Open(\"sqlite3\", databaseURL)\n")
	fmt.Fprintf(file, "\tif err != nil {\n")
	fmt.Fprintf(file, "\t\treturn nil, nil, fmt.Errorf(\"error opening database: %%w\", err)\n")
	fmt.Fprintf(file, "\t}\n\n")
	fmt.Fprintf(file, "\tif err := db.PingContext(ctx); err != nil {\n")
	fmt.Fprintf(file, "\t\tdb.Close()\n")
	fmt.Fprintf(file, "\t\treturn nil, nil, fmt.Errorf(\"error pinging database: %%w\", err)\n")
	fmt.Fprintf(file, "\t}\n\n")
	fmt.Fprintf(file, "\tdbDriver := NewSQLDriver(db)\n")
	fmt.Fprintf(file, "\tclient := NewClient(dbDriver)\n\n")
	fmt.Fprintf(file, "\treturn client, db, nil\n")
	fmt.Fprintf(file, "}\n\n")

	// SQLDBAdapter type
	generateSQLDBAdapter(file)
}

// generateSQLDBAdapter generates the SQLDBAdapter implementation (shared for MySQL and SQLite)
func generateSQLDBAdapter(file *os.File) {
	// SQLDBAdapter type
	fmt.Fprintf(file, "// SQLDBAdapter adapts *sql.DB to builder.DBTX\n")
	fmt.Fprintf(file, "type SQLDBAdapter struct {\n")
	fmt.Fprintf(file, "\tdb *sql.DB\n")
	fmt.Fprintf(file, "}\n\n")

	// Implement DBTX interface methods
	fmt.Fprintf(file, "// Exec executes a query that doesn't return rows\n")
	fmt.Fprintf(file, "func (a *SQLDBAdapter) Exec(ctx context.Context, sql string, args ...interface{}) (builder.Result, error) {\n")
	fmt.Fprintf(file, "\tresult, err := a.db.ExecContext(ctx, sql, args...)\n")
	fmt.Fprintf(file, "\tif err != nil {\n")
	fmt.Fprintf(file, "\t\treturn nil, err\n")
	fmt.Fprintf(file, "\t}\n")
	fmt.Fprintf(file, "\treturn &SQLResult{result: result}, nil\n")
	fmt.Fprintf(file, "}\n\n")

	fmt.Fprintf(file, "// Query executes a query that returns multiple rows\n")
	fmt.Fprintf(file, "func (a *SQLDBAdapter) Query(ctx context.Context, sql string, args ...interface{}) (builder.Rows, error) {\n")
	fmt.Fprintf(file, "\trows, err := a.db.QueryContext(ctx, sql, args...)\n")
	fmt.Fprintf(file, "\tif err != nil {\n")
	fmt.Fprintf(file, "\t\treturn nil, err\n")
	fmt.Fprintf(file, "\t}\n")
	fmt.Fprintf(file, "\treturn &SQLRows{rows: rows}, nil\n")
	fmt.Fprintf(file, "}\n\n")

	fmt.Fprintf(file, "// QueryRow executes a query that returns a single row\n")
	fmt.Fprintf(file, "func (a *SQLDBAdapter) QueryRow(ctx context.Context, sql string, args ...interface{}) builder.Row {\n")
	fmt.Fprintf(file, "\trow := a.db.QueryRowContext(ctx, sql, args...)\n")
	fmt.Fprintf(file, "\treturn &SQLRow{row: row}\n")
	fmt.Fprintf(file, "}\n\n")

	fmt.Fprintf(file, "// Begin starts a transaction\n")
	fmt.Fprintf(file, "func (a *SQLDBAdapter) Begin(ctx context.Context) (builder.Tx, error) {\n")
	fmt.Fprintf(file, "\ttx, err := a.db.BeginTx(ctx, nil)\n")
	fmt.Fprintf(file, "\tif err != nil {\n")
	fmt.Fprintf(file, "\t\treturn nil, err\n")
	fmt.Fprintf(file, "\t}\n")
	fmt.Fprintf(file, "\treturn &SQLTx{tx: tx}, nil\n")
	fmt.Fprintf(file, "}\n\n")

	fmt.Fprintf(file, "// SQLDB returns the underlying *sql.DB\n")
	fmt.Fprintf(file, "func (a *SQLDBAdapter) SQLDB() *sql.DB {\n")
	fmt.Fprintf(file, "\treturn a.db\n")
	fmt.Fprintf(file, "}\n\n")

	// SQLResult type
	fmt.Fprintf(file, "// SQLResult wraps sql.Result\n")
	fmt.Fprintf(file, "type SQLResult struct {\n")
	fmt.Fprintf(file, "\tresult sql.Result\n")
	fmt.Fprintf(file, "}\n\n")

	fmt.Fprintf(file, "// RowsAffected returns the number of rows affected\n")
	fmt.Fprintf(file, "func (r *SQLResult) RowsAffected() int64 {\n")
	fmt.Fprintf(file, "\trows, _ := r.result.RowsAffected()\n")
	fmt.Fprintf(file, "\treturn rows\n")
	fmt.Fprintf(file, "}\n\n")

	// SQLRows type
	fmt.Fprintf(file, "// SQLRows wraps sql.Rows\n")
	fmt.Fprintf(file, "type SQLRows struct {\n")
	fmt.Fprintf(file, "\trows *sql.Rows\n")
	fmt.Fprintf(file, "}\n\n")

	fmt.Fprintf(file, "// Close closes the rows iterator\n")
	fmt.Fprintf(file, "func (r *SQLRows) Close() {\n")
	fmt.Fprintf(file, "\tr.rows.Close()\n")
	fmt.Fprintf(file, "}\n\n")

	fmt.Fprintf(file, "// Err returns any error that occurred during iteration\n")
	fmt.Fprintf(file, "func (r *SQLRows) Err() error {\n")
	fmt.Fprintf(file, "\treturn r.rows.Err()\n")
	fmt.Fprintf(file, "}\n\n")

	fmt.Fprintf(file, "// Next prepares the next result row for reading\n")
	fmt.Fprintf(file, "func (r *SQLRows) Next() bool {\n")
	fmt.Fprintf(file, "\treturn r.rows.Next()\n")
	fmt.Fprintf(file, "}\n\n")

	fmt.Fprintf(file, "// Scan copies the columns in the current row into the values pointed at by dest\n")
	fmt.Fprintf(file, "func (r *SQLRows) Scan(dest ...interface{}) error {\n")
	fmt.Fprintf(file, "\treturn r.rows.Scan(dest...)\n")
	fmt.Fprintf(file, "}\n\n")

	// SQLRow type
	fmt.Fprintf(file, "// SQLRow wraps sql.Row\n")
	fmt.Fprintf(file, "type SQLRow struct {\n")
	fmt.Fprintf(file, "\trow *sql.Row\n")
	fmt.Fprintf(file, "}\n\n")

	fmt.Fprintf(file, "// Scan copies the columns in the current row into the values pointed at by dest\n")
	fmt.Fprintf(file, "func (r *SQLRow) Scan(dest ...interface{}) error {\n")
	fmt.Fprintf(file, "\treturn r.row.Scan(dest...)\n")
	fmt.Fprintf(file, "}\n\n")

	// SQLTx type
	fmt.Fprintf(file, "// SQLTx wraps sql.Tx\n")
	fmt.Fprintf(file, "type SQLTx struct {\n")
	fmt.Fprintf(file, "\ttx *sql.Tx\n")
	fmt.Fprintf(file, "}\n\n")

	fmt.Fprintf(file, "// Commit commits the transaction\n")
	fmt.Fprintf(file, "func (t *SQLTx) Commit(ctx context.Context) error {\n")
	fmt.Fprintf(file, "\treturn t.tx.Commit()\n")
	fmt.Fprintf(file, "}\n\n")

	fmt.Fprintf(file, "// Rollback rolls back the transaction\n")
	fmt.Fprintf(file, "func (t *SQLTx) Rollback(ctx context.Context) error {\n")
	fmt.Fprintf(file, "\treturn t.tx.Rollback()\n")
	fmt.Fprintf(file, "}\n\n")

	fmt.Fprintf(file, "// Exec executes a query that doesn't return rows\n")
	fmt.Fprintf(file, "func (t *SQLTx) Exec(ctx context.Context, sql string, args ...interface{}) (builder.Result, error) {\n")
	fmt.Fprintf(file, "\tresult, err := t.tx.ExecContext(ctx, sql, args...)\n")
	fmt.Fprintf(file, "\tif err != nil {\n")
	fmt.Fprintf(file, "\t\treturn nil, err\n")
	fmt.Fprintf(file, "\t}\n")
	fmt.Fprintf(file, "\treturn &SQLResult{result: result}, nil\n")
	fmt.Fprintf(file, "}\n\n")

	fmt.Fprintf(file, "// Query executes a query that returns multiple rows\n")
	fmt.Fprintf(file, "func (t *SQLTx) Query(ctx context.Context, sql string, args ...interface{}) (builder.Rows, error) {\n")
	fmt.Fprintf(file, "\trows, err := t.tx.QueryContext(ctx, sql, args...)\n")
	fmt.Fprintf(file, "\tif err != nil {\n")
	fmt.Fprintf(file, "\t\treturn nil, err\n")
	fmt.Fprintf(file, "\t}\n")
	fmt.Fprintf(file, "\treturn &SQLRows{rows: rows}, nil\n")
	fmt.Fprintf(file, "}\n\n")

	fmt.Fprintf(file, "// QueryRow executes a query that returns a single row\n")
	fmt.Fprintf(file, "func (t *SQLTx) QueryRow(ctx context.Context, sql string, args ...interface{}) builder.Row {\n")
	fmt.Fprintf(file, "\trow := t.tx.QueryRowContext(ctx, sql, args...)\n")
	fmt.Fprintf(file, "\treturn &SQLRow{row: row}\n")
	fmt.Fprintf(file, "}\n")
}

