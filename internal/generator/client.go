package generator

import (
	"fmt"
	"os"
	"path/filepath"
	"sort"

	"github.com/carlosnayan/prisma-go-client/internal/migrations"
	"github.com/carlosnayan/prisma-go-client/internal/parser"
)

// GenerateClient generates the main client.go file
func GenerateClient(schema *parser.Schema, outputDir string) error {
	clientFile := filepath.Join(outputDir, "client.go")
	if err := os.MkdirAll(outputDir, 0755); err != nil {
		return fmt.Errorf("erro ao criar diretÃ³rio: %w", err)
	}

	// Detect user module
	userModule, err := detectUserModule(outputDir)
	if err != nil {
		return fmt.Errorf("failed to detect user module: %w", err)
	}

	file, err := os.Create(clientFile)
	if err != nil {
		return err
	}
	defer file.Close()

	// Header
	fmt.Fprintf(file, "// Code generated by prisma generate. DO NOT EDIT.\n")
	fmt.Fprintf(file, "package db\n\n")

	// Determine required imports
	imports, driverImports := determineClientImports(schema, userModule, outputDir)
	if len(imports) > 0 || len(driverImports) > 0 {
		fmt.Fprintf(file, "import (\n")
		// Separate stdlib and third-party imports
		stdlib := []string{}
		thirdParty := []string{}

		for _, imp := range imports {
			if isStdlibImport(imp) {
				stdlib = append(stdlib, imp)
			} else {
				thirdParty = append(thirdParty, imp)
			}
		}

		// Write stdlib imports
		for _, imp := range stdlib {
			fmt.Fprintf(file, "\t%q\n", imp)
		}

		// Add blank line if both exist
		if len(stdlib) > 0 && len(thirdParty) > 0 {
			fmt.Fprintf(file, "\n")
		}

		// Write third-party imports
		for _, imp := range thirdParty {
			fmt.Fprintf(file, "\t%q\n", imp)
		}

		// Write driver imports (blank imports) with comment
		if len(driverImports) > 0 {
			if len(thirdParty) > 0 {
				fmt.Fprintf(file, "\n")
			}
			fmt.Fprintf(file, "\t// Database driver (blank import to register driver)\n")
			for _, imp := range driverImports {
				fmt.Fprintf(file, "\t%s\n", imp)
			}
		}

		fmt.Fprintf(file, ")\n\n")
	}

	// Client struct
	fmt.Fprintf(file, "// Client is the main Prisma client\n")
	fmt.Fprintf(file, "type Client struct {\n")
	fmt.Fprintf(file, "\tdb driver.DB\n")
	fmt.Fprintf(file, "\traw *raw.Executor\n")
	fmt.Fprintf(file, "}\n\n")

	// NewClient
	fmt.Fprintf(file, "// NewClient creates a new Prisma client\n")
	fmt.Fprintf(file, "// db must be a driver.DB implementation (e.g., driver.NewPgxPool, driver.NewSQLDB)\n")
	fmt.Fprintf(file, "func NewClient(db driver.DB) *Client {\n")
	fmt.Fprintf(file, "\treturn &Client{\n")
	fmt.Fprintf(file, "\t\tdb:  db,\n")
	fmt.Fprintf(file, "\t\traw: raw.New(db),\n")
	fmt.Fprintf(file, "\t}\n")
	fmt.Fprintf(file, "}\n\n")

	// Raw
	fmt.Fprintf(file, "// Raw returns the raw SQL executor\n")
	fmt.Fprintf(file, "func (c *Client) Raw() *raw.Executor {\n")
	fmt.Fprintf(file, "\treturn c.raw\n")
	fmt.Fprintf(file, "}\n\n")

	// Methods for each model
	var modelNames []string
	for _, model := range schema.Models {
		modelNames = append(modelNames, model.Name)
	}
	sort.Strings(modelNames)

	for _, modelName := range modelNames {
		generateModelMethod(file, modelName, schema)
	}

	// Generate TransactionClient and Transaction method
	generateTransactionClient(file, schema)
	generateTransactionMethod(file, schema)

	// Generate helper functions for type-safe filters
	generateHelperFunctions(file)

	return nil
}

// generateModelMethod generates the method to access a model
func generateModelMethod(file *os.File, modelName string, schema *parser.Schema) {
	var model *parser.Model
	for _, m := range schema.Models {
		if m.Name == modelName {
			model = m
			break
		}
	}
	if model == nil {
		return
	}

	columns := getModelColumns(model)
	primaryKey := getPrimaryKey(model)
	hasDeleted := hasDeletedAt(model)
	pascalModelName := toPascalCase(modelName)
	methodName := pascalModelName

	generateFluentAPIMethods(file, model, pascalModelName, methodName)

	fmt.Fprintf(file, "// %s returns the query builder for model %s with fluent API\n", methodName, pascalModelName)
	fmt.Fprintf(file, "// Example: client.%s().Where(\"active = ?\", true).First(ctx, &user)\n", methodName)
	fmt.Fprintf(file, "func (c *Client) %s() *queries.%sQuery {\n", methodName, pascalModelName)
	fmt.Fprintf(file, "\tcolumns := []string{%s}\n", formatColumns(columns))
	fmt.Fprintf(file, "\tquery := builder.NewQuery(c.db, %q, columns)\n", toSnakeCase(modelName))
	if primaryKey != "" {
		fmt.Fprintf(file, "\tquery.SetPrimaryKey(%q)\n", primaryKey)
	}
	if hasDeleted {
		fmt.Fprintf(file, "\tquery.SetHasDeleted(true)\n")
	}

	fmt.Fprintf(file, "\tmodelType := reflect.TypeOf(models.%s{})\n", pascalModelName)
	fmt.Fprintf(file, "\tquery.SetModelType(modelType)\n")
	fmt.Fprintf(file, "\treturn &queries.%sQuery{Query: query}\n", pascalModelName)
	fmt.Fprintf(file, "}\n\n")
}

// getModelColumns returns the columns of a model
func getModelColumns(model *parser.Model) []string {
	columns := []string{}
	for _, field := range model.Fields {
		columnName := field.Name
		for _, attr := range field.Attributes {
			if attr.Name == "map" && len(attr.Arguments) > 0 {
				if val, ok := attr.Arguments[0].Value.(string); ok {
					columnName = val
				}
			}
		}
		columns = append(columns, columnName)
	}
	return columns
}

// getPrimaryKey returns the primary key of a model
func getPrimaryKey(model *parser.Model) string {
	for _, attr := range model.Attributes {
		if attr.Name == "id" {
			if len(attr.Arguments) > 0 {
				if fields, ok := attr.Arguments[0].Value.([]interface{}); ok && len(fields) > 0 {
					if fieldName, ok := fields[0].(string); ok {
						return fieldName
					}
				}
			}
		}
	}

	for _, field := range model.Fields {
		for _, attr := range field.Attributes {
			if attr.Name == "id" {
				columnName := field.Name
				for _, mapAttr := range field.Attributes {
					if mapAttr.Name == "map" && len(mapAttr.Arguments) > 0 {
						if val, ok := mapAttr.Arguments[0].Value.(string); ok {
							columnName = val
						}
					}
				}
				return columnName
			}
		}
	}

	return "id"
}

// hasDeletedAt checks if the model has a deleted_at field
func hasDeletedAt(model *parser.Model) bool {
	for _, field := range model.Fields {
		if field.Name == "deleted_at" || field.Name == "deletedAt" {
			return true
		}
		for _, attr := range field.Attributes {
			if attr.Name == "map" && len(attr.Arguments) > 0 {
				if val, ok := attr.Arguments[0].Value.(string); ok {
					if val == "deleted_at" {
						return true
					}
				}
			}
		}
	}
	return false
}

// formatColumns formats columns for Go code
func formatColumns(columns []string) string {
	if len(columns) == 0 {
		return ""
	}
	result := ""
	for i, col := range columns {
		if i > 0 {
			result += ", "
		}
		result += fmt.Sprintf("%q", col)
	}
	return result
}

// determineClientImports determines which imports are needed for client.go
// Returns regular imports and driver imports (blank imports) separately
func determineClientImports(schema *parser.Schema, userModule, outputDir string) ([]string, []string) {
	imports := make(map[string]bool)
	var driverImports []string

	// context and fmt are needed for fluent API methods
	imports["context"] = true
	imports["fmt"] = true
	// reflect is always needed for SetModelType
	imports["reflect"] = true

	// Calculate import paths for generated packages
	modelsPath, queriesPath, inputsPath, err := calculateImportPath(userModule, outputDir)
	if err != nil {
		// Fallback to old paths if detection fails
		modelsPath = "github.com/carlosnayan/prisma-go-client/db/models"
		queriesPath = "github.com/carlosnayan/prisma-go-client/db/queries"
		inputsPath = "github.com/carlosnayan/prisma-go-client/db/inputs"
	}

	// These are always needed
	imports["github.com/carlosnayan/prisma-go-client/builder"] = true
	imports[modelsPath] = true
	imports[queriesPath] = true
	imports[inputsPath] = true
	imports["github.com/carlosnayan/prisma-go-client/raw"] = true
	imports["github.com/carlosnayan/prisma-go-client/internal/driver"] = true

	// Add driver import based on provider (blank import)
	provider := migrations.GetProviderFromSchema(schema)
	switch provider {
	case "postgresql":
		driverImports = append(driverImports, `_ "github.com/jackc/pgx/v5/stdlib"`)
	case "mysql":
		driverImports = append(driverImports, `_ "github.com/go-sql-driver/mysql"`)
	case "sqlite":
		driverImports = append(driverImports, `_ "github.com/mattn/go-sqlite3"`)
	}

	result := []string{}
	if imports["context"] {
		result = append(result, "context")
	}
	if imports["fmt"] {
		result = append(result, "fmt")
	}
	if imports["reflect"] {
		result = append(result, "reflect")
	}
	if imports["github.com/carlosnayan/prisma-go-client/builder"] {
		result = append(result, "github.com/carlosnayan/prisma-go-client/builder")
	}
	if imports[modelsPath] {
		result = append(result, modelsPath)
	}
	if imports[queriesPath] {
		result = append(result, queriesPath)
	}
	if imports[inputsPath] {
		result = append(result, inputsPath)
	}
	if imports["github.com/carlosnayan/prisma-go-client/raw"] {
		result = append(result, "github.com/carlosnayan/prisma-go-client/raw")
	}
	if imports["github.com/carlosnayan/prisma-go-client/internal/driver"] {
		result = append(result, "github.com/carlosnayan/prisma-go-client/internal/driver")
	}

	return result, driverImports
}

// generateHelperFunctions generates type-safe helper functions in client.go
func generateHelperFunctions(file *os.File) {
	fmt.Fprintf(file, "// Helper functions for type-safe filters\n\n")

	// String helpers
	fmt.Fprintf(file, "// Contains creates a StringFilter with Contains condition\n")
	fmt.Fprintf(file, "func Contains(value string) *inputs.StringFilter {\n")
	fmt.Fprintf(file, "\treturn &inputs.StringFilter{Contains: &value}\n")
	fmt.Fprintf(file, "}\n\n")

	fmt.Fprintf(file, "// String creates a StringFilter with Equals condition\n")
	fmt.Fprintf(file, "func String(value string) *inputs.StringFilter {\n")
	fmt.Fprintf(file, "\treturn &inputs.StringFilter{Equals: &value}\n")
	fmt.Fprintf(file, "}\n\n")

	// Int helpers
	fmt.Fprintf(file, "// Int creates an IntFilter with Equals condition\n")
	fmt.Fprintf(file, "func Int(value int) *inputs.IntFilter {\n")
	fmt.Fprintf(file, "\treturn &inputs.IntFilter{Equals: &value}\n")
	fmt.Fprintf(file, "}\n\n")

	fmt.Fprintf(file, "// IntGt creates an IntFilter with Gt condition\n")
	fmt.Fprintf(file, "func IntGt(value int) *inputs.IntFilter {\n")
	fmt.Fprintf(file, "\treturn &inputs.IntFilter{Gt: &value}\n")
	fmt.Fprintf(file, "}\n\n")

	fmt.Fprintf(file, "// IntGte creates an IntFilter with Gte condition\n")
	fmt.Fprintf(file, "func IntGte(value int) *inputs.IntFilter {\n")
	fmt.Fprintf(file, "\treturn &inputs.IntFilter{Gte: &value}\n")
	fmt.Fprintf(file, "}\n\n")

	fmt.Fprintf(file, "// IntLt creates an IntFilter with Lt condition\n")
	fmt.Fprintf(file, "func IntLt(value int) *inputs.IntFilter {\n")
	fmt.Fprintf(file, "\treturn &inputs.IntFilter{Lt: &value}\n")
	fmt.Fprintf(file, "}\n\n")

	fmt.Fprintf(file, "// IntLte creates an IntFilter with Lte condition\n")
	fmt.Fprintf(file, "func IntLte(value int) *inputs.IntFilter {\n")
	fmt.Fprintf(file, "\treturn &inputs.IntFilter{Lte: &value}\n")
	fmt.Fprintf(file, "}\n\n")
}

// generateFluentAPIMethods generates fluent methods for Create, FindMany, FindFirst, Update, Delete
func generateFluentAPIMethods(file *os.File, model *parser.Model, pascalModelName, methodName string) {
	fmt.Fprintf(file, "// %sCreateBuilder is a fluent builder for creating %s records\n", pascalModelName, pascalModelName)
	fmt.Fprintf(file, "type %sCreateBuilder struct {\n", pascalModelName)
	fmt.Fprintf(file, "\tclient   *Client\n")
	fmt.Fprintf(file, "\ttxClient *TransactionClient\n")
	fmt.Fprintf(file, "\tdata     *inputs.%sCreateInput\n", pascalModelName)
	fmt.Fprintf(file, "}\n\n")

	fmt.Fprintf(file, "// Data sets the data for creating a %s record\n", pascalModelName)
	fmt.Fprintf(file, "func (b *%sCreateBuilder) Data(data inputs.%sCreateInput) *%sCreateBuilder {\n", pascalModelName, pascalModelName, pascalModelName)
	fmt.Fprintf(file, "\tb.data = &data\n")
	fmt.Fprintf(file, "\treturn b\n")
	fmt.Fprintf(file, "}\n\n")

	fmt.Fprintf(file, "// Exec executes the create operation\n")
	fmt.Fprintf(file, "func (b *%sCreateBuilder) Exec(ctx context.Context) (*models.%s, error) {\n", pascalModelName, pascalModelName)
	fmt.Fprintf(file, "\tif b.data == nil {\n")
	fmt.Fprintf(file, "\t\treturn nil, fmt.Errorf(\"data is required\")\n")
	fmt.Fprintf(file, "\t}\n")
	fmt.Fprintf(file, "\tuser := &models.%s{}\n", pascalModelName)
	for _, field := range model.Fields {
		if isAutoGenerated(field) || isRelation(field) {
			continue
		}
		fieldName := toPascalCase(field.Name)
		fmt.Fprintf(file, "\tif b.data.%s != nil {\n", fieldName)
		fmt.Fprintf(file, "\t\tuser.%s = *b.data.%s\n", fieldName, fieldName)
		fmt.Fprintf(file, "\t}\n")
	}
	fmt.Fprintf(file, "\tvar query *queries.%sQuery\n", pascalModelName)
	fmt.Fprintf(file, "\tif b.txClient != nil {\n")
	fmt.Fprintf(file, "\t\tquery = b.txClient.%s()\n", methodName)
	fmt.Fprintf(file, "\t} else {\n")
	fmt.Fprintf(file, "\t\tquery = b.client.%s()\n", methodName)
	fmt.Fprintf(file, "\t}\n")
	fmt.Fprintf(file, "\terr := query.Create(ctx, user)\n")
	fmt.Fprintf(file, "\tif err != nil {\n")
	fmt.Fprintf(file, "\t\treturn nil, err\n")
	fmt.Fprintf(file, "\t}\n")
	fmt.Fprintf(file, "\treturn user, nil\n")
	fmt.Fprintf(file, "}\n\n")

	// FindMany builder
	fmt.Fprintf(file, "// %sFindManyBuilder is a fluent builder for finding multiple %s records\n", pascalModelName, pascalModelName)
	fmt.Fprintf(file, "type %sFindManyBuilder struct {\n", pascalModelName)
	fmt.Fprintf(file, "\tclient      *Client\n")
	fmt.Fprintf(file, "\ttxClient    *TransactionClient\n")
	fmt.Fprintf(file, "\tselectFields *inputs.%sSelect\n", pascalModelName)
	fmt.Fprintf(file, "\twhereInput   *inputs.%sWhereInput\n", pascalModelName)
	fmt.Fprintf(file, "}\n\n")

	fmt.Fprintf(file, "// Select sets which fields to return\n")
	fmt.Fprintf(file, "func (b *%sFindManyBuilder) Select(selectFields inputs.%sSelect) *%sFindManyBuilder {\n", pascalModelName, pascalModelName, pascalModelName)
	fmt.Fprintf(file, "\tb.selectFields = &selectFields\n")
	fmt.Fprintf(file, "\treturn b\n")
	fmt.Fprintf(file, "}\n\n")

	fmt.Fprintf(file, "// Where sets the where conditions\n")
	fmt.Fprintf(file, "func (b *%sFindManyBuilder) Where(where inputs.%sWhereInput) *%sFindManyBuilder {\n", pascalModelName, pascalModelName, pascalModelName)
	fmt.Fprintf(file, "\tb.whereInput = &where\n")
	fmt.Fprintf(file, "\treturn b\n")
	fmt.Fprintf(file, "}\n\n")

	fmt.Fprintf(file, "// Exec executes the find many operation\n")
	fmt.Fprintf(file, "func (b *%sFindManyBuilder) Exec(ctx context.Context) ([]models.%s, error) {\n", pascalModelName, pascalModelName)
	fmt.Fprintf(file, "\tvar query *queries.%sQuery\n", pascalModelName)
	fmt.Fprintf(file, "\tif b.txClient != nil {\n")
	fmt.Fprintf(file, "\t\tquery = b.txClient.%s()\n", methodName)
	fmt.Fprintf(file, "\t} else {\n")
	fmt.Fprintf(file, "\t\tquery = b.client.%s()\n", methodName)
	fmt.Fprintf(file, "\t}\n")
	fmt.Fprintf(file, "\tif b.selectFields != nil {\n")
	fmt.Fprintf(file, "\t\t// TODO: implement field selection in builder\n")
	fmt.Fprintf(file, "\t}\n")
	fmt.Fprintf(file, "\tif b.whereInput != nil {\n")
	fmt.Fprintf(file, "\t\twhereMap := queries.Convert%sWhereInputToWhere(*b.whereInput)\n", pascalModelName)
	fmt.Fprintf(file, "\t\tquery.Where(whereMap)\n")
	fmt.Fprintf(file, "\t}\n")
	fmt.Fprintf(file, "\tvar results []models.%s\n", pascalModelName)
	fmt.Fprintf(file, "\terr := query.FindMany(ctx, &results)\n")
	fmt.Fprintf(file, "\treturn results, err\n")
	fmt.Fprintf(file, "}\n\n")

	// FindFirst builder
	fmt.Fprintf(file, "// %sFindFirstBuilder is a fluent builder for finding a single %s record\n", pascalModelName, pascalModelName)
	fmt.Fprintf(file, "type %sFindFirstBuilder struct {\n", pascalModelName)
	fmt.Fprintf(file, "\tclient      *Client\n")
	fmt.Fprintf(file, "\ttxClient    *TransactionClient\n")
	fmt.Fprintf(file, "\tselectFields *inputs.%sSelect\n", pascalModelName)
	fmt.Fprintf(file, "\twhereInput   *inputs.%sWhereInput\n", pascalModelName)
	fmt.Fprintf(file, "}\n\n")

	fmt.Fprintf(file, "// Select sets which fields to return\n")
	fmt.Fprintf(file, "func (b *%sFindFirstBuilder) Select(selectFields inputs.%sSelect) *%sFindFirstBuilder {\n", pascalModelName, pascalModelName, pascalModelName)
	fmt.Fprintf(file, "\tb.selectFields = &selectFields\n")
	fmt.Fprintf(file, "\treturn b\n")
	fmt.Fprintf(file, "}\n\n")

	fmt.Fprintf(file, "// Where sets the where conditions\n")
	fmt.Fprintf(file, "func (b *%sFindFirstBuilder) Where(where inputs.%sWhereInput) *%sFindFirstBuilder {\n", pascalModelName, pascalModelName, pascalModelName)
	fmt.Fprintf(file, "\tb.whereInput = &where\n")
	fmt.Fprintf(file, "\treturn b\n")
	fmt.Fprintf(file, "}\n\n")

	fmt.Fprintf(file, "// Exec executes the find first operation\n")
	fmt.Fprintf(file, "func (b *%sFindFirstBuilder) Exec(ctx context.Context) (*models.%s, error) {\n", pascalModelName, pascalModelName)
	fmt.Fprintf(file, "\tvar query *queries.%sQuery\n", pascalModelName)
	fmt.Fprintf(file, "\tif b.txClient != nil {\n")
	fmt.Fprintf(file, "\t\tquery = b.txClient.%s()\n", methodName)
	fmt.Fprintf(file, "\t} else {\n")
	fmt.Fprintf(file, "\t\tquery = b.client.%s()\n", methodName)
	fmt.Fprintf(file, "\t}\n")
	fmt.Fprintf(file, "\tif b.selectFields != nil {\n")
	fmt.Fprintf(file, "\t\t// TODO: implement field selection in builder\n")
	fmt.Fprintf(file, "\t}\n")
	fmt.Fprintf(file, "\tif b.whereInput != nil {\n")
	fmt.Fprintf(file, "\t\twhereMap := queries.Convert%sWhereInputToWhere(*b.whereInput)\n", pascalModelName)
	fmt.Fprintf(file, "\t\tquery.Where(whereMap)\n")
	fmt.Fprintf(file, "\t}\n")
	fmt.Fprintf(file, "\tvar result models.%s\n", pascalModelName)
	fmt.Fprintf(file, "\terr := query.FindFirst(ctx, &result)\n")
	fmt.Fprintf(file, "\tif err != nil {\n")
	fmt.Fprintf(file, "\t\treturn nil, err\n")
	fmt.Fprintf(file, "\t}\n")
	fmt.Fprintf(file, "\treturn &result, nil\n")
	fmt.Fprintf(file, "}\n\n")

	fmt.Fprintf(file, "// %sUpdateBuilder is a fluent builder for updating %s records\n", pascalModelName, pascalModelName)
	fmt.Fprintf(file, "type %sUpdateBuilder struct {\n", pascalModelName)
	fmt.Fprintf(file, "\tclient     *Client\n")
	fmt.Fprintf(file, "\ttxClient   *TransactionClient\n")
	fmt.Fprintf(file, "\twhereInput *inputs.%sWhereInput\n", pascalModelName)
	fmt.Fprintf(file, "\tdata       *inputs.%sUpdateInput\n", pascalModelName)
	fmt.Fprintf(file, "}\n\n")

	fmt.Fprintf(file, "// Where sets the where conditions\n")
	fmt.Fprintf(file, "func (b *%sUpdateBuilder) Where(where inputs.%sWhereInput) *%sUpdateBuilder {\n", pascalModelName, pascalModelName, pascalModelName)
	fmt.Fprintf(file, "\tb.whereInput = &where\n")
	fmt.Fprintf(file, "\treturn b\n")
	fmt.Fprintf(file, "}\n\n")

	fmt.Fprintf(file, "// Data sets the data for updating\n")
	fmt.Fprintf(file, "func (b *%sUpdateBuilder) Data(data inputs.%sUpdateInput) *%sUpdateBuilder {\n", pascalModelName, pascalModelName, pascalModelName)
	fmt.Fprintf(file, "\tb.data = &data\n")
	fmt.Fprintf(file, "\treturn b\n")
	fmt.Fprintf(file, "}\n\n")

	fmt.Fprintf(file, "// Exec executes the update operation\n")
	fmt.Fprintf(file, "func (b *%sUpdateBuilder) Exec(ctx context.Context) error {\n", pascalModelName)
	fmt.Fprintf(file, "\tif b.whereInput == nil {\n")
	fmt.Fprintf(file, "\t\treturn fmt.Errorf(\"where condition is required\")\n")
	fmt.Fprintf(file, "\t}\n")
	fmt.Fprintf(file, "\tif b.data == nil {\n")
	fmt.Fprintf(file, "\t\treturn fmt.Errorf(\"data is required\")\n")
	fmt.Fprintf(file, "\t}\n")
	fmt.Fprintf(file, "\tvar query *queries.%sQuery\n", pascalModelName)
	fmt.Fprintf(file, "\tif b.txClient != nil {\n")
	fmt.Fprintf(file, "\t\tquery = b.txClient.%s()\n", methodName)
	fmt.Fprintf(file, "\t} else {\n")
	fmt.Fprintf(file, "\t\tquery = b.client.%s()\n", methodName)
	fmt.Fprintf(file, "\t}\n")
	fmt.Fprintf(file, "\twhereMap := queries.Convert%sWhereInputToWhere(*b.whereInput)\n", pascalModelName)
	fmt.Fprintf(file, "\tquery.Where(whereMap)\n")
	fmt.Fprintf(file, "\tupdateData := make(map[string]interface{})\n")
	for _, field := range model.Fields {
		if isAutoGenerated(field) || isPrimaryKey(field) || isRelation(field) {
			continue
		}
		fieldName := toPascalCase(field.Name)
		dbFieldName := field.Name
		fmt.Fprintf(file, "\tif b.data.%s != nil {\n", fieldName)
		fmt.Fprintf(file, "\t\tupdateData[%q] = *b.data.%s\n", dbFieldName, fieldName)
		fmt.Fprintf(file, "\t}\n")
	}
	fmt.Fprintf(file, "\treturn query.Updates(ctx, updateData)\n")
	fmt.Fprintf(file, "}\n\n")

	fmt.Fprintf(file, "// %sDeleteBuilder is a fluent builder for deleting %s records\n", pascalModelName, pascalModelName)
	fmt.Fprintf(file, "type %sDeleteBuilder struct {\n", pascalModelName)
	fmt.Fprintf(file, "\tclient     *Client\n")
	fmt.Fprintf(file, "\ttxClient   *TransactionClient\n")
	fmt.Fprintf(file, "\twhereInput *inputs.%sWhereInput\n", pascalModelName)
	fmt.Fprintf(file, "}\n\n")

	fmt.Fprintf(file, "// Where sets the where conditions\n")
	fmt.Fprintf(file, "func (b *%sDeleteBuilder) Where(where inputs.%sWhereInput) *%sDeleteBuilder {\n", pascalModelName, pascalModelName, pascalModelName)
	fmt.Fprintf(file, "\tb.whereInput = &where\n")
	fmt.Fprintf(file, "\treturn b\n")
	fmt.Fprintf(file, "}\n\n")

	fmt.Fprintf(file, "// Exec executes the delete operation\n")
	fmt.Fprintf(file, "func (b *%sDeleteBuilder) Exec(ctx context.Context) error {\n", pascalModelName)
	fmt.Fprintf(file, "\tif b.whereInput == nil {\n")
	fmt.Fprintf(file, "\t\treturn fmt.Errorf(\"where condition is required\")\n")
	fmt.Fprintf(file, "\t}\n")
	fmt.Fprintf(file, "\tvar query *queries.%sQuery\n", pascalModelName)
	fmt.Fprintf(file, "\tif b.txClient != nil {\n")
	fmt.Fprintf(file, "\t\tquery = b.txClient.%s()\n", methodName)
	fmt.Fprintf(file, "\t} else {\n")
	fmt.Fprintf(file, "\t\tquery = b.client.%s()\n", methodName)
	fmt.Fprintf(file, "\t}\n")
	fmt.Fprintf(file, "\twhereMap := queries.Convert%sWhereInputToWhere(*b.whereInput)\n", pascalModelName)
	fmt.Fprintf(file, "\tquery.Where(whereMap)\n")
	fmt.Fprintf(file, "\treturn query.Delete(ctx, &models.%s{})\n", pascalModelName)
	fmt.Fprintf(file, "}\n\n")

	// Generate methods on Client
	fmt.Fprintf(file, "// Create returns a builder for creating a %s record\n", pascalModelName)
	fmt.Fprintf(file, "// Example: user, err := client.%s.Create().Data(inputs.UserCreateInput{...}).Exec(ctx)\n", methodName)
	fmt.Fprintf(file, "func (c *Client) %sCreate() *%sCreateBuilder {\n", methodName, pascalModelName)
	fmt.Fprintf(file, "\treturn &%sCreateBuilder{client: c}\n", pascalModelName)
	fmt.Fprintf(file, "}\n\n")

	fmt.Fprintf(file, "// FindMany returns a builder for finding multiple %s records\n", pascalModelName)
	fmt.Fprintf(file, "// Example: users, err := client.%s.FindMany().Where(inputs.UserWhereInput{...}).Exec(ctx)\n", methodName)
	fmt.Fprintf(file, "func (c *Client) %sFindMany() *%sFindManyBuilder {\n", methodName, pascalModelName)
	fmt.Fprintf(file, "\treturn &%sFindManyBuilder{client: c}\n", pascalModelName)
	fmt.Fprintf(file, "}\n\n")

	fmt.Fprintf(file, "// FindFirst returns a builder for finding a single %s record\n", pascalModelName)
	fmt.Fprintf(file, "// Example: user, err := client.%s.FindFirst().Where(inputs.UserWhereInput{...}).Exec(ctx)\n", methodName)
	fmt.Fprintf(file, "func (c *Client) %sFindFirst() *%sFindFirstBuilder {\n", methodName, pascalModelName)
	fmt.Fprintf(file, "\treturn &%sFindFirstBuilder{client: c}\n", pascalModelName)
	fmt.Fprintf(file, "}\n\n")

	fmt.Fprintf(file, "// Update returns a builder for updating %s records\n", pascalModelName)
	fmt.Fprintf(file, "// Example: err := client.%s.Update().Where(inputs.UserWhereInput{...}).Data(inputs.UserUpdateInput{...}).Exec(ctx)\n", methodName)
	fmt.Fprintf(file, "func (c *Client) %sUpdate() *%sUpdateBuilder {\n", methodName, pascalModelName)
	fmt.Fprintf(file, "\treturn &%sUpdateBuilder{client: c}\n", pascalModelName)
	fmt.Fprintf(file, "}\n\n")

	fmt.Fprintf(file, "// Delete returns a builder for deleting %s records\n", pascalModelName)
	fmt.Fprintf(file, "// Example: err := client.%s.Delete().Where(inputs.UserWhereInput{...}).Exec(ctx)\n", methodName)
	fmt.Fprintf(file, "func (c *Client) %sDelete() *%sDeleteBuilder {\n", methodName, pascalModelName)
	fmt.Fprintf(file, "\treturn &%sDeleteBuilder{client: c}\n", pascalModelName)
	fmt.Fprintf(file, "}\n\n")
}

// generateTransactionClient generates the TransactionClient struct and its methods
func generateTransactionClient(file *os.File, schema *parser.Schema) {
	// TransactionClient struct
	fmt.Fprintf(file, "// TransactionClient is a client that executes operations within a transaction\n")
	fmt.Fprintf(file, "// All operations executed through TransactionClient are part of the same transaction\n")
	fmt.Fprintf(file, "type TransactionClient struct {\n")
	fmt.Fprintf(file, "\ttx  *builder.Transaction\n")
	fmt.Fprintf(file, "\traw *raw.Executor\n")
	fmt.Fprintf(file, "}\n\n")

	// Raw method for TransactionClient
	fmt.Fprintf(file, "// Raw returns the raw SQL executor for the transaction\n")
	fmt.Fprintf(file, "func (tc *TransactionClient) Raw() *raw.Executor {\n")
	fmt.Fprintf(file, "\treturn tc.raw\n")
	fmt.Fprintf(file, "}\n\n")

	// Methods for each model in TransactionClient
	var modelNames []string
	for _, model := range schema.Models {
		modelNames = append(modelNames, model.Name)
	}
	sort.Strings(modelNames)

	for _, modelName := range modelNames {
		generateTransactionModelMethod(file, modelName, schema)
	}
}

// generateTransactionModelMethod generates the method to access a model in TransactionClient
func generateTransactionModelMethod(file *os.File, modelName string, schema *parser.Schema) {
	var model *parser.Model
	for _, m := range schema.Models {
		if m.Name == modelName {
			model = m
			break
		}
	}
	if model == nil {
		return
	}

	columns := getModelColumns(model)
	primaryKey := getPrimaryKey(model)
	hasDeleted := hasDeletedAt(model)
	pascalModelName := toPascalCase(modelName)
	methodName := pascalModelName

	fmt.Fprintf(file, "// %s returns the query builder for model %s within the transaction\n", methodName, pascalModelName)
	fmt.Fprintf(file, "// Example: tx.%s().Where(\"active = ?\", true).First(ctx, &user)\n", methodName)
	fmt.Fprintf(file, "func (tc *TransactionClient) %s() *queries.%sQuery {\n", methodName, pascalModelName)
	fmt.Fprintf(file, "\tcolumns := []string{%s}\n", formatColumns(columns))
	fmt.Fprintf(file, "\tquery := tc.tx.Query(%q, columns)\n", toSnakeCase(modelName))
	if primaryKey != "" {
		fmt.Fprintf(file, "\tquery.SetPrimaryKey(%q)\n", primaryKey)
	}
	if hasDeleted {
		fmt.Fprintf(file, "\tquery.SetHasDeleted(true)\n")
	}

	fmt.Fprintf(file, "\tmodelType := reflect.TypeOf(models.%s{})\n", pascalModelName)
	fmt.Fprintf(file, "\tquery.SetModelType(modelType)\n")
	fmt.Fprintf(file, "\treturn &queries.%sQuery{Query: query}\n", pascalModelName)
	fmt.Fprintf(file, "}\n\n")

	// Generate fluent API methods for TransactionClient
	generateTransactionFluentAPIMethods(file, model, pascalModelName, methodName)
}

// generateTransactionFluentAPIMethods generates fluent API methods for TransactionClient
func generateTransactionFluentAPIMethods(file *os.File, model *parser.Model, pascalModelName, methodName string) {
	// Create builder for TransactionClient
	fmt.Fprintf(file, "// %sCreate returns a builder for creating a %s record within the transaction\n", methodName, pascalModelName)
	fmt.Fprintf(file, "// Example: user, err := tx.%s.Create().Data(inputs.UserCreateInput{...}).Exec(ctx)\n", methodName)
	fmt.Fprintf(file, "func (tc *TransactionClient) %sCreate() *%sCreateBuilder {\n", methodName, pascalModelName)
	fmt.Fprintf(file, "\treturn &%sCreateBuilder{client: nil, txClient: tc}\n", pascalModelName)
	fmt.Fprintf(file, "}\n\n")

	// FindMany builder
	fmt.Fprintf(file, "// %sFindMany returns a builder for finding multiple %s records within the transaction\n", methodName, pascalModelName)
	fmt.Fprintf(file, "// Example: users, err := tx.%s.FindMany().Where(inputs.UserWhereInput{...}).Exec(ctx)\n", methodName)
	fmt.Fprintf(file, "func (tc *TransactionClient) %sFindMany() *%sFindManyBuilder {\n", methodName, pascalModelName)
	fmt.Fprintf(file, "\treturn &%sFindManyBuilder{client: nil, txClient: tc}\n", pascalModelName)
	fmt.Fprintf(file, "}\n\n")

	// FindFirst builder
	fmt.Fprintf(file, "// %sFindFirst returns a builder for finding a single %s record within the transaction\n", methodName, pascalModelName)
	fmt.Fprintf(file, "// Example: user, err := tx.%s.FindFirst().Where(inputs.UserWhereInput{...}).Exec(ctx)\n", methodName)
	fmt.Fprintf(file, "func (tc *TransactionClient) %sFindFirst() *%sFindFirstBuilder {\n", methodName, pascalModelName)
	fmt.Fprintf(file, "\treturn &%sFindFirstBuilder{client: nil, txClient: tc}\n", pascalModelName)
	fmt.Fprintf(file, "}\n\n")

	// Update builder
	fmt.Fprintf(file, "// %sUpdate returns a builder for updating %s records within the transaction\n", methodName, pascalModelName)
	fmt.Fprintf(file, "// Example: err := tx.%s.Update().Where(inputs.UserWhereInput{...}).Data(inputs.UserUpdateInput{...}).Exec(ctx)\n", methodName)
	fmt.Fprintf(file, "func (tc *TransactionClient) %sUpdate() *%sUpdateBuilder {\n", methodName, pascalModelName)
	fmt.Fprintf(file, "\treturn &%sUpdateBuilder{client: nil, txClient: tc}\n", pascalModelName)
	fmt.Fprintf(file, "}\n\n")

	// Delete builder
	fmt.Fprintf(file, "// %sDelete returns a builder for deleting %s records within the transaction\n", methodName, pascalModelName)
	fmt.Fprintf(file, "// Example: err := tx.%s.Delete().Where(inputs.UserWhereInput{...}).Exec(ctx)\n", methodName)
	fmt.Fprintf(file, "func (tc *TransactionClient) %sDelete() *%sDeleteBuilder {\n", methodName, pascalModelName)
	fmt.Fprintf(file, "\treturn &%sDeleteBuilder{client: nil, txClient: tc}\n", pascalModelName)
	fmt.Fprintf(file, "}\n\n")
}

// generateTransactionMethod generates the Transaction method on Client
func generateTransactionMethod(file *os.File, schema *parser.Schema) {
	fmt.Fprintf(file, "// Transaction executes a function within a database transaction\n")
	fmt.Fprintf(file, "// If the function returns an error, the transaction is automatically rolled back\n")
	fmt.Fprintf(file, "// Example:\n")
	fmt.Fprintf(file, "//   err := client.Transaction(ctx, func(tx *TransactionClient) error {\n")
	fmt.Fprintf(file, "//       user, err := tx.User.Create().Data(...).Exec(ctx)\n")
	fmt.Fprintf(file, "//       if err != nil { return err }\n")
	fmt.Fprintf(file, "//       _, err = tx.Post.Create().Data(...).Exec(ctx)\n")
	fmt.Fprintf(file, "//       return err\n")
	fmt.Fprintf(file, "//   })\n")
	fmt.Fprintf(file, "func (c *Client) Transaction(ctx context.Context, fn func(*TransactionClient) error) error {\n")
	fmt.Fprintf(file, "\treturn builder.ExecuteTransaction(ctx, c.db, func(tx *builder.Transaction) error {\n")
	fmt.Fprintf(file, "\t\t// Create adapter for raw executor\n")
	fmt.Fprintf(file, "\t\ttxAdapter := tx.DB()\n")
	fmt.Fprintf(file, "\t\ttxClient := &TransactionClient{\n")
	fmt.Fprintf(file, "\t\t\ttx:  tx,\n")
	fmt.Fprintf(file, "\t\t\traw: raw.New(txAdapter),\n")
	fmt.Fprintf(file, "\t\t}\n")
	fmt.Fprintf(file, "\t\treturn fn(txClient)\n")
	fmt.Fprintf(file, "\t})\n")
	fmt.Fprintf(file, "}\n\n")
}
