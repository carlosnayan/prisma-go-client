package generator

import (
	"fmt"
	"os"
	"path/filepath"

	"github.com/carlosnayan/prisma-go-client/internal/parser"
)

// GenerateInputs generates auxiliary types (CreateInput, UpdateInput) for each model
func GenerateInputs(schema *parser.Schema, outputDir string) error {
	inputsDir := filepath.Join(outputDir, "inputs")
	if err := os.MkdirAll(inputsDir, 0755); err != nil {
		return fmt.Errorf("erro ao criar diretório inputs: %w", err)
	}

	// Generate Filter types once in a shared file
	filtersFile := filepath.Join(inputsDir, "filters.go")
	if err := generateFiltersFile(filtersFile, schema); err != nil {
		return fmt.Errorf("erro ao gerar filters: %w", err)
	}

	// Generate input types for each model
	for _, model := range schema.Models {
		inputFile := filepath.Join(inputsDir, toSnakeCase(model.Name)+"_input.go")
		if err := generateInputFile(inputFile, model); err != nil {
			return fmt.Errorf("erro ao gerar inputs para %s: %w", model.Name, err)
		}
	}

	return nil
}

// generateInputFile generates input types for a model
func generateInputFile(filePath string, model *parser.Model) error {
	file, err := os.Create(filePath)
	if err != nil {
		return err
	}
	defer file.Close()

	// Header
	fmt.Fprintf(file, "// Code generated by prisma generate. DO NOT EDIT.\n")
	fmt.Fprintf(file, "package inputs\n\n")

	pascalModelName := toPascalCase(model.Name)

	// Determine required imports by checking all fields that will be generated
	imports := determineInputImports(model)
	if len(imports) > 0 {
		fmt.Fprintf(file, "import (\n")
		// Separate stdlib and third-party imports
		stdlib := []string{}
		thirdParty := []string{}

		for _, imp := range imports {
			if isStdlibImport(imp) {
				stdlib = append(stdlib, imp)
			} else {
				thirdParty = append(thirdParty, imp)
			}
		}

		// Write stdlib imports
		for _, imp := range stdlib {
			fmt.Fprintf(file, "\t%q\n", imp)
		}

		// Add blank line if both exist
		if len(stdlib) > 0 && len(thirdParty) > 0 {
			fmt.Fprintf(file, "\n")
		}

		// Write third-party imports
		for _, imp := range thirdParty {
			fmt.Fprintf(file, "\t%q\n", imp)
		}

		fmt.Fprintf(file, ")\n\n")
	}

	// Filter types are generated in filters.go, not here

	// CreateInput
	fmt.Fprintf(file, "// %sCreateInput represents data to create a new %s\n", pascalModelName, pascalModelName)
	fmt.Fprintf(file, "type %sCreateInput struct {\n", pascalModelName)
	for _, field := range model.Fields {
		// Skip auto-generated fields and relations for now
		if isAutoGenerated(field) || isRelation(field) {
			continue
		}
		generateInputField(file, field, true)
	}
	fmt.Fprintf(file, "}\n\n")

	// UpdateInput
	fmt.Fprintf(file, "// %sUpdateInput represents data to update a %s\n", pascalModelName, pascalModelName)
	fmt.Fprintf(file, "type %sUpdateInput struct {\n", pascalModelName)
	for _, field := range model.Fields {
		// Skip auto-generated fields, primary keys and relations
		if isAutoGenerated(field) || isPrimaryKey(field) || isRelation(field) {
			continue
		}
		generateInputField(file, field, false)
	}
	fmt.Fprintf(file, "}\n\n")

	// WhereInput (type-safe with Filter types)
	fmt.Fprintf(file, "// %sWhereInput represents filter conditions for %s\n", pascalModelName, pascalModelName)
	fmt.Fprintf(file, "type %sWhereInput struct {\n", pascalModelName)
	for _, field := range model.Fields {
		if isRelation(field) {
			continue
		}
		fieldName := toPascalCase(field.Name)
		filterType := getFilterType(field.Type)

		// For WhereInput, all fields use Filter types for type-safety
		fmt.Fprintf(file, "\t%s *%s `json:\"%s,omitempty\"`\n", fieldName, filterType, toSnakeCase(field.Name))
	}

	// Add OR/AND/NOT support
	fmt.Fprintf(file, "\tOr  []%sWhereInput `json:\"or,omitempty\"`\n", pascalModelName)
	fmt.Fprintf(file, "\tAnd []%sWhereInput `json:\"and,omitempty\"`\n", pascalModelName)
	fmt.Fprintf(file, "\tNot *%sWhereInput `json:\"not,omitempty\"`\n", pascalModelName)
	fmt.Fprintf(file, "}\n\n")

	// SelectInput (for field selection)
	fmt.Fprintf(file, "// %sSelect represents field selection for %s\n", pascalModelName, pascalModelName)
	fmt.Fprintf(file, "type %sSelect struct {\n", pascalModelName)
	for _, field := range model.Fields {
		if isRelation(field) {
			continue
		}
		fieldName := toPascalCase(field.Name)
		fmt.Fprintf(file, "\t%s bool `json:\"%s,omitempty\"`\n", fieldName, toSnakeCase(field.Name))
	}
	fmt.Fprintf(file, "}\n\n")

	return nil
}

// generateInputField generates a field for CreateInput or UpdateInput
func generateInputField(file *os.File, field *parser.ModelField, isCreate bool) {
	fieldName := toPascalCase(field.Name)
	goType := fieldTypeToGo(field.Type, field.Attributes)

	isOptional := !isCreate || (field.Type != nil && field.Type.IsOptional)

	if isOptional {
		goType = "*" + goType
	}

	jsonTag := toSnakeCase(field.Name)
	fmt.Fprintf(file, "\t%s %s `json:\"%s,omitempty\"`\n", fieldName, goType, jsonTag)
}

// isAutoGenerated checks if a field is auto-generated (id with autoincrement, created_at, updated_at)
func isAutoGenerated(field *parser.ModelField) bool {
	hasID := false
	hasAutoIncrement := false
	for _, attr := range field.Attributes {
		if attr.Name == "id" {
			hasID = true
		}
		if attr.Name == "default" {
			for _, arg := range attr.Arguments {
				if arg.Value == "autoincrement()" {
					hasAutoIncrement = true
				}
			}
		}
	}

	if hasID && hasAutoIncrement {
		return true
	}

	if field.Name == "created_at" || field.Name == "createdAt" {
		return true
	}
	if field.Name == "updated_at" || field.Name == "updatedAt" {
		for _, attr := range field.Attributes {
			if attr.Name == "updatedAt" {
				return true
			}
		}
	}

	return false
}

// isPrimaryKey checks if a field is a primary key
func isPrimaryKey(field *parser.ModelField) bool {
	for _, attr := range field.Attributes {
		if attr.Name == "id" {
			return true
		}
	}
	return false
}

// isRelation checks if a field is a relationship (non-primitive type)
func isRelation(field *parser.ModelField) bool {
	if field.Type == nil {
		return false
	}

	// Se não é um tipo builtin, provavelmente é um relacionamento
	// Tipos builtin conhecidos
	builtinTypes := map[string]bool{
		"String":   true,
		"Int":      true,
		"BigInt":   true,
		"Float":    true,
		"Decimal":  true,
		"Boolean":  true,
		"DateTime": true,
		"Json":     true,
		"Bytes":    true,
	}

	return !builtinTypes[field.Type.Name]
}

// determineInputImports determines which imports are needed for input types
// Only checks fields that are actually generated in CreateInput, UpdateInput, or WhereInput
func determineInputImports(model *parser.Model) []string {
	imports := make(map[string]bool)
	fieldsToCheck := make(map[*parser.ModelField]bool)

	// Collect fields that will actually be generated in the input types
	for _, field := range model.Fields {
		if field.Type == nil {
			continue
		}

		// Check if field appears in CreateInput (skip auto-generated and relations)
		if !isAutoGenerated(field) && !isRelation(field) {
			fieldsToCheck[field] = true
		}

		// Check if field appears in UpdateInput (skip auto-generated, primary keys, and relations)
		if !isAutoGenerated(field) && !isPrimaryKey(field) && !isRelation(field) {
			fieldsToCheck[field] = true
		}

		// Check if field appears in WhereInput (skip only relations)
		if !isRelation(field) {
			fieldsToCheck[field] = true
		}
	}

	// Check imports only for fields that will actually be generated
	for field := range fieldsToCheck {
		// Use the same logic as fieldTypeToGo to determine the Go type
		// Then check if that type requires imports
		typeMapping := parser.GetTypeGoMapping()
		if mapped, ok := typeMapping[field.Type.Name]; ok {
			// This is a primitive type - check if it needs imports
			switch mapped {
			case "time.Time":
				imports["time"] = true
			case "json.RawMessage":
				imports["encoding/json"] = true
			}
		}
		// Note: enums and relations are handled as strings, so no imports needed
	}

	result := []string{}
	if imports["time"] {
		result = append(result, "time")
	}
	if imports["encoding/json"] {
		result = append(result, "encoding/json")
	}

	return result
}

// getFilterType returns the appropriate Filter type for a field type
func getFilterType(fieldType *parser.FieldType) string {
	if fieldType == nil {
		return "StringFilter" // Default
	}

	typeMapping := parser.GetTypeGoMapping()
	if mapped, ok := typeMapping[fieldType.Name]; ok {
		switch mapped {
		case "string":
			return "StringFilter"
		case "int":
			return "IntFilter"
		case "int64":
			return "Int64Filter"
		case "float64":
			return "FloatFilter"
		case "bool":
			return "BooleanFilter"
		case "time.Time":
			return "DateTimeFilter"
		case "json.RawMessage":
			return "JsonFilter"
		case "[]byte":
			return "BytesFilter"
		}
	}

	// Para enums e relacionamentos, usar StringFilter por padrão
	return "StringFilter"
}

// generateFiltersFile generates all Filter types in a single shared file
func generateFiltersFile(filePath string, schema *parser.Schema) error {
	file, err := os.Create(filePath)
	if err != nil {
		return err
	}
	defer file.Close()

	// Header
	fmt.Fprintf(file, "// Code generated by prisma generate. DO NOT EDIT.\n")
	fmt.Fprintf(file, "package inputs\n\n")

	// Determine which filter types are needed across all models
	neededFilters := make(map[string]bool)
	for _, model := range schema.Models {
		for _, field := range model.Fields {
			if !isRelation(field) && field.Type != nil {
				filterType := getFilterType(field.Type)
				neededFilters[filterType] = true
			}
		}
	}

	// Determine required imports
	imports := []string{}
	if neededFilters["DateTimeFilter"] {
		imports = append(imports, "time")
	}
	if neededFilters["JsonFilter"] {
		imports = append(imports, "encoding/json")
	}

	if len(imports) > 0 {
		fmt.Fprintf(file, "import (\n")
		for _, imp := range imports {
			fmt.Fprintf(file, "\t%q\n", imp)
		}
		fmt.Fprintf(file, ")\n\n")
	}

	// Generate all needed filter types
	if neededFilters["StringFilter"] {
		generateStringFilterType(file)
	}
	if neededFilters["IntFilter"] {
		generateIntFilterType(file)
	}
	if neededFilters["Int64Filter"] {
		generateInt64FilterType(file)
	}
	if neededFilters["FloatFilter"] {
		generateFloatFilterType(file)
	}
	if neededFilters["BooleanFilter"] {
		generateBooleanFilterType(file)
	}
	if neededFilters["DateTimeFilter"] {
		generateDateTimeFilterType(file)
	}
	if neededFilters["JsonFilter"] {
		generateJsonFilterType(file)
	}
	if neededFilters["BytesFilter"] {
		generateBytesFilterType(file)
	}

	return nil
}

// generateFilterTypes is deprecated - use generateFiltersFile instead
// This function is kept for backward compatibility but should not be used
func generateFilterTypes(file *os.File, model *parser.Model) {
	// This function is no longer used - filters are generated in filters.go
}

func generateStringFilterType(file *os.File) {
	fmt.Fprintf(file, "// StringFilter represents filter conditions for string fields\n")
	fmt.Fprintf(file, "type StringFilter struct {\n")
	fmt.Fprintf(file, "\tEquals              *string  `json:\"equals,omitempty\"`\n")
	fmt.Fprintf(file, "\tNotEquals           *string  `json:\"notEquals,omitempty\"`\n")
	fmt.Fprintf(file, "\tContains            *string  `json:\"contains,omitempty\"`\n")
	fmt.Fprintf(file, "\tStartsWith          *string  `json:\"startsWith,omitempty\"`\n")
	fmt.Fprintf(file, "\tEndsWith            *string  `json:\"endsWith,omitempty\"`\n")
	fmt.Fprintf(file, "\tContainsInsensitive *string  `json:\"containsInsensitive,omitempty\"`\n")
	fmt.Fprintf(file, "\tStartsWithInsensitive *string `json:\"startsWithInsensitive,omitempty\"`\n")
	fmt.Fprintf(file, "\tEndsWithInsensitive *string  `json:\"endsWithInsensitive,omitempty\"`\n")
	fmt.Fprintf(file, "\tIn                 []string `json:\"in,omitempty\"`\n")
	fmt.Fprintf(file, "\tNotIn              []string `json:\"notIn,omitempty\"`\n")
	fmt.Fprintf(file, "\tIsNull             *bool    `json:\"isNull,omitempty\"`\n")
	fmt.Fprintf(file, "\tIsNotNull          *bool    `json:\"isNotNull,omitempty\"`\n")
	fmt.Fprintf(file, "}\n\n")
}

func generateIntFilterType(file *os.File) {
	fmt.Fprintf(file, "// IntFilter represents filter conditions for int fields\n")
	fmt.Fprintf(file, "type IntFilter struct {\n")
	fmt.Fprintf(file, "\tEquals    *int   `json:\"equals,omitempty\"`\n")
	fmt.Fprintf(file, "\tNotEquals *int   `json:\"notEquals,omitempty\"`\n")
	fmt.Fprintf(file, "\tGt        *int   `json:\"gt,omitempty\"`\n")
	fmt.Fprintf(file, "\tGte       *int   `json:\"gte,omitempty\"`\n")
	fmt.Fprintf(file, "\tLt        *int   `json:\"lt,omitempty\"`\n")
	fmt.Fprintf(file, "\tLte       *int   `json:\"lte,omitempty\"`\n")
	fmt.Fprintf(file, "\tIn        []int  `json:\"in,omitempty\"`\n")
	fmt.Fprintf(file, "\tNotIn     []int  `json:\"notIn,omitempty\"`\n")
	fmt.Fprintf(file, "\tIsNull    *bool  `json:\"isNull,omitempty\"`\n")
	fmt.Fprintf(file, "\tIsNotNull *bool  `json:\"isNotNull,omitempty\"`\n")
	fmt.Fprintf(file, "}\n\n")
}

func generateInt64FilterType(file *os.File) {
	fmt.Fprintf(file, "// Int64Filter represents filter conditions for int64 (BigInt) fields\n")
	fmt.Fprintf(file, "type Int64Filter struct {\n")
	fmt.Fprintf(file, "\tEquals    *int64  `json:\"equals,omitempty\"`\n")
	fmt.Fprintf(file, "\tNotEquals *int64  `json:\"notEquals,omitempty\"`\n")
	fmt.Fprintf(file, "\tGt        *int64  `json:\"gt,omitempty\"`\n")
	fmt.Fprintf(file, "\tGte       *int64  `json:\"gte,omitempty\"`\n")
	fmt.Fprintf(file, "\tLt        *int64  `json:\"lt,omitempty\"`\n")
	fmt.Fprintf(file, "\tLte       *int64  `json:\"lte,omitempty\"`\n")
	fmt.Fprintf(file, "\tIn        []int64 `json:\"in,omitempty\"`\n")
	fmt.Fprintf(file, "\tNotIn     []int64 `json:\"notIn,omitempty\"`\n")
	fmt.Fprintf(file, "\tIsNull    *bool   `json:\"isNull,omitempty\"`\n")
	fmt.Fprintf(file, "\tIsNotNull *bool   `json:\"isNotNull,omitempty\"`\n")
	fmt.Fprintf(file, "}\n\n")
}

func generateFloatFilterType(file *os.File) {
	fmt.Fprintf(file, "// FloatFilter represents filter conditions for float64 fields\n")
	fmt.Fprintf(file, "type FloatFilter struct {\n")
	fmt.Fprintf(file, "\tEquals    *float64  `json:\"equals,omitempty\"`\n")
	fmt.Fprintf(file, "\tNotEquals *float64  `json:\"notEquals,omitempty\"`\n")
	fmt.Fprintf(file, "\tGt        *float64  `json:\"gt,omitempty\"`\n")
	fmt.Fprintf(file, "\tGte       *float64  `json:\"gte,omitempty\"`\n")
	fmt.Fprintf(file, "\tLt        *float64  `json:\"lt,omitempty\"`\n")
	fmt.Fprintf(file, "\tLte       *float64  `json:\"lte,omitempty\"`\n")
	fmt.Fprintf(file, "\tIn        []float64 `json:\"in,omitempty\"`\n")
	fmt.Fprintf(file, "\tNotIn     []float64 `json:\"notIn,omitempty\"`\n")
	fmt.Fprintf(file, "\tIsNull    *bool     `json:\"isNull,omitempty\"`\n")
	fmt.Fprintf(file, "\tIsNotNull *bool     `json:\"isNotNull,omitempty\"`\n")
	fmt.Fprintf(file, "}\n\n")
}

func generateBooleanFilterType(file *os.File) {
	fmt.Fprintf(file, "// BooleanFilter represents filter conditions for bool fields\n")
	fmt.Fprintf(file, "type BooleanFilter struct {\n")
	fmt.Fprintf(file, "\tEquals    *bool `json:\"equals,omitempty\"`\n")
	fmt.Fprintf(file, "\tNotEquals *bool `json:\"notEquals,omitempty\"`\n")
	fmt.Fprintf(file, "\tIsNull    *bool `json:\"isNull,omitempty\"`\n")
	fmt.Fprintf(file, "\tIsNotNull *bool `json:\"isNotNull,omitempty\"`\n")
	fmt.Fprintf(file, "}\n\n")
}

func generateDateTimeFilterType(file *os.File) {
	fmt.Fprintf(file, "// DateTimeFilter represents filter conditions for time.Time fields\n")
	fmt.Fprintf(file, "type DateTimeFilter struct {\n")
	fmt.Fprintf(file, "\tEquals    *time.Time  `json:\"equals,omitempty\"`\n")
	fmt.Fprintf(file, "\tNotEquals *time.Time  `json:\"notEquals,omitempty\"`\n")
	fmt.Fprintf(file, "\tGt        *time.Time  `json:\"gt,omitempty\"`\n")
	fmt.Fprintf(file, "\tGte       *time.Time  `json:\"gte,omitempty\"`\n")
	fmt.Fprintf(file, "\tLt        *time.Time  `json:\"lt,omitempty\"`\n")
	fmt.Fprintf(file, "\tLte       *time.Time  `json:\"lte,omitempty\"`\n")
	fmt.Fprintf(file, "\tIsNull    *bool       `json:\"isNull,omitempty\"`\n")
	fmt.Fprintf(file, "\tIsNotNull *bool       `json:\"isNotNull,omitempty\"`\n")
	fmt.Fprintf(file, "}\n\n")
}

func generateJsonFilterType(file *os.File) {
	fmt.Fprintf(file, "// JsonFilter represents filter conditions for json.RawMessage fields\n")
	fmt.Fprintf(file, "type JsonFilter struct {\n")
	fmt.Fprintf(file, "\tEquals    *json.RawMessage `json:\"equals,omitempty\"`\n")
	fmt.Fprintf(file, "\tNotEquals *json.RawMessage `json:\"notEquals,omitempty\"`\n")
	fmt.Fprintf(file, "\tIsNull    *bool            `json:\"isNull,omitempty\"`\n")
	fmt.Fprintf(file, "\tIsNotNull *bool            `json:\"isNotNull,omitempty\"`\n")
	fmt.Fprintf(file, "}\n\n")
}

func generateBytesFilterType(file *os.File) {
	fmt.Fprintf(file, "// BytesFilter represents filter conditions for []byte fields\n")
	fmt.Fprintf(file, "type BytesFilter struct {\n")
	fmt.Fprintf(file, "\tEquals    *[]byte `json:\"equals,omitempty\"`\n")
	fmt.Fprintf(file, "\tNotEquals *[]byte `json:\"notEquals,omitempty\"`\n")
	fmt.Fprintf(file, "\tIsNull    *bool   `json:\"isNull,omitempty\"`\n")
	fmt.Fprintf(file, "\tIsNotNull *bool   `json:\"isNotNull,omitempty\"`\n")
	fmt.Fprintf(file, "}\n\n")
}
