package generator

import (
	"fmt"
	"os"
	"path/filepath"

	"github.com/carlosnayan/prisma-go-client/internal/parser"
)

// GenerateInputs generates auxiliary types (CreateInput, UpdateInput) for each model
func GenerateInputs(schema *parser.Schema, outputDir string) error {
	inputsDir := filepath.Join(outputDir, "inputs")
	if err := os.MkdirAll(inputsDir, 0755); err != nil {
		return fmt.Errorf("failed to create inputs directory: %w", err)
	}

	// Generate Filter types once in a shared file
	filtersFile := filepath.Join(inputsDir, "filters.go")
	if err := generateFiltersFile(filtersFile, schema); err != nil {
		return fmt.Errorf("failed to generate filters: %w", err)
	}

	// Generate input types for each model
	for _, model := range schema.Models {
		inputFile := filepath.Join(inputsDir, toSnakeCase(model.Name)+"_input.go")
		if err := generateInputFile(inputFile, model, schema); err != nil {
			return fmt.Errorf("failed to generate inputs for %s: %w", model.Name, err)
		}
	}

	return nil
}

// generateInputFile generates input types for a model
func generateInputFile(filePath string, model *parser.Model, schema *parser.Schema) error {
	file, err := createGeneratedFile(filePath, "inputs")
	if err != nil {
		return err
	}
	defer file.Close()

	pascalModelName := toPascalCase(model.Name)

	// Determine required imports by checking all fields that will be generated
	imports := determineInputImports(model, schema)
	if len(imports) > 0 {
		fmt.Fprintf(file, "import (\n")
		// Separate stdlib and third-party imports
		stdlib := []string{}
		thirdParty := []string{}

		for _, imp := range imports {
			if isStdlibImport(imp) {
				stdlib = append(stdlib, imp)
			} else {
				thirdParty = append(thirdParty, imp)
			}
		}

		// Write stdlib imports
		for _, imp := range stdlib {
			fmt.Fprintf(file, "\t%q\n", imp)
		}

		// Add blank line if both exist
		if len(stdlib) > 0 && len(thirdParty) > 0 {
			fmt.Fprintf(file, "\n")
		}

		// Write third-party imports
		for _, imp := range thirdParty {
			fmt.Fprintf(file, "\t%q\n", imp)
		}

		fmt.Fprintf(file, ")\n\n")
	}

	// Filter types are generated in filters.go, not here

	// CreateInput
	fmt.Fprintf(file, "// %sCreateInput represents data to create a new %s\n", pascalModelName, pascalModelName)
	fmt.Fprintf(file, "type %sCreateInput struct {\n", pascalModelName)
	for _, field := range model.Fields {
		// Skip auto-generated fields and relations for now
		if isAutoGenerated(field) || isRelation(field, schema) {
			continue
		}
		generateInputField(file, field, true)
	}
	fmt.Fprintf(file, "}\n\n")

	// UpdateInput
	fmt.Fprintf(file, "// %sUpdateInput represents data to update a %s\n", pascalModelName, pascalModelName)
	fmt.Fprintf(file, "type %sUpdateInput struct {\n", pascalModelName)
	for _, field := range model.Fields {
		// Skip auto-generated fields, primary keys and relations
		if isAutoGenerated(field) || isPrimaryKey(field) || isRelation(field, schema) {
			continue
		}
		generateInputField(file, field, false)
	}
	fmt.Fprintf(file, "}\n\n")

	// WhereInput (type-safe with Filter types)
	fmt.Fprintf(file, "// %sWhereInput represents filter conditions for %s\n", pascalModelName, pascalModelName)
	fmt.Fprintf(file, "type %sWhereInput struct {\n", pascalModelName)
	for _, field := range model.Fields {
		if isRelation(field, schema) {
			continue
		}
		fieldName := toPascalCase(field.Name)
		filterType := getFilterType(field.Type)

		// For WhereInput, all fields use Filter types for type-safety
		fmt.Fprintf(file, "\t%s *%s `json:\"%s,omitempty\"`\n", fieldName, filterType, toSnakeCase(field.Name))
	}

	// Add OR/AND/NOT support
	fmt.Fprintf(file, "\tOr  []%sWhereInput `json:\"or,omitempty\"`\n", pascalModelName)
	fmt.Fprintf(file, "\tAnd []%sWhereInput `json:\"and,omitempty\"`\n", pascalModelName)
	fmt.Fprintf(file, "\tNot *%sWhereInput `json:\"not,omitempty\"`\n", pascalModelName)
	fmt.Fprintf(file, "}\n\n")

	// SelectInput (for field selection)
	fmt.Fprintf(file, "// %sSelect represents field selection for %s\n", pascalModelName, pascalModelName)
	fmt.Fprintf(file, "type %sSelect struct {\n", pascalModelName)
	for _, field := range model.Fields {
		if isRelation(field, schema) {
			continue
		}
		fieldName := toPascalCase(field.Name)
		fmt.Fprintf(file, "\t%s bool `json:\"%s,omitempty\"`\n", fieldName, toSnakeCase(field.Name))
	}
	fmt.Fprintf(file, "}\n\n")

	return nil
}

// generateInputField generates a field for CreateInput or UpdateInput
func generateInputField(file *os.File, field *parser.ModelField, isCreate bool) {
	fieldName := toPascalCase(field.Name)

	// Get base type without pointers (for inputs, we control pointers ourselves)
	goType := fieldTypeToGoBase(field.Type)

	isOptional := !isCreate || (field.Type != nil && field.Type.IsOptional)

	if isOptional {
		goType = "*" + goType
	}

	jsonTag := toSnakeCase(field.Name)
	fmt.Fprintf(file, "\t%s %s `json:\"%s,omitempty\"`\n", fieldName, goType, jsonTag)
}

// fieldTypeToGoBase returns the base Go type without pointers (for input types)
func fieldTypeToGoBase(fieldType *parser.FieldType) string {
	if fieldType == nil {
		return "interface{}"
	}

	if fieldType.IsUnsupported {
		return "string"
	}

	typeMapping := parser.GetTypeGoMapping()

	var goType string
	if mapped, ok := typeMapping[fieldType.Name]; ok {
		// Primitive type - return without pointer
		goType = mapped
	} else {
		// May be enum or model - for now string
		goType = "string"
	}

	// Se Ã© array
	if fieldType.IsArray {
		return "[]" + goType
	}

	return goType
}

// isAutoGenerated checks if a field is auto-generated (id with autoincrement, created_at, updated_at)
func isAutoGenerated(field *parser.ModelField) bool {
	hasID := false
	hasAutoIncrement := false
	for _, attr := range field.Attributes {
		if attr.Name == "id" {
			hasID = true
		}
		if attr.Name == "default" {
			for _, arg := range attr.Arguments {
				if arg.Value == "autoincrement()" {
					hasAutoIncrement = true
				}
			}
		}
	}

	if hasID && hasAutoIncrement {
		return true
	}

	if field.Name == "created_at" || field.Name == "createdAt" {
		return true
	}
	if field.Name == "updated_at" || field.Name == "updatedAt" {
		for _, attr := range field.Attributes {
			if attr.Name == "updatedAt" {
				return true
			}
		}
	}

	return false
}

// isPrimaryKey checks if a field is a primary key
func isPrimaryKey(field *parser.ModelField) bool {
	for _, attr := range field.Attributes {
		if attr.Name == "id" {
			return true
		}
	}
	return false
}

// isRelation checks if a field is a relationship (non-primitive type)
// It returns false for enums, which are scalar types, not relationships
func isRelation(field *parser.ModelField, schema *parser.Schema) bool {
	if field.Type == nil {
		return false
	}

	// Known builtin types
	builtinTypes := map[string]bool{
		"String":   true,
		"Int":      true,
		"BigInt":   true,
		"Float":    true,
		"Decimal":  true,
		"Boolean":  true,
		"DateTime": true,
		"Json":     true,
		"Bytes":    true,
	}

	// If it's a builtin type, it's not a relation
	if builtinTypes[field.Type.Name] {
		return false
	}

	// Check if it's an enum - enums are scalar types, not relationships
	for _, enum := range schema.Enums {
		if enum.Name == field.Type.Name {
			return false
		}
	}

	// If it's not a builtin type and not an enum, it's probably a relationship
	return true
}

// determineInputImports determines which imports are needed for input types
// Only checks fields that are actually generated in CreateInput or UpdateInput
// WhereInput uses Filter types from filters.go, so it doesn't need imports here
func determineInputImports(model *parser.Model, schema *parser.Schema) []string {
	imports := make(map[string]bool, 2)

	// Check only fields that will be generated in CreateInput or UpdateInput
	for _, field := range model.Fields {
		if field.Type == nil {
			continue
		}

		// Check if field appears in CreateInput (skip auto-generated and relations)
		needsTimeInCreate := false
		needsJsonInCreate := false
		if !isAutoGenerated(field) && !isRelation(field, schema) {
			typeMapping := parser.GetTypeGoMapping()
			if mapped, ok := typeMapping[field.Type.Name]; ok {
				switch mapped {
				case "time.Time":
					needsTimeInCreate = true
				case "json.RawMessage":
					needsJsonInCreate = true
				}
			}
		}

		// Check if field appears in UpdateInput (skip auto-generated, primary keys, and relations)
		needsTimeInUpdate := false
		needsJsonInUpdate := false
		if !isAutoGenerated(field) && !isPrimaryKey(field) && !isRelation(field, schema) {
			typeMapping := parser.GetTypeGoMapping()
			if mapped, ok := typeMapping[field.Type.Name]; ok {
				switch mapped {
				case "time.Time":
					needsTimeInUpdate = true
				case "json.RawMessage":
					needsJsonInUpdate = true
				}
			}
		}

		// Add imports only if field is actually used in CreateInput or UpdateInput
		if needsTimeInCreate || needsTimeInUpdate {
			imports["time"] = true
		}
		if needsJsonInCreate || needsJsonInUpdate {
			imports["encoding/json"] = true
		}
	}

	result := make([]string, 0, len(imports))
	if imports["time"] {
		result = append(result, "time")
	}
	if imports["encoding/json"] {
		result = append(result, "encoding/json")
	}

	return result
}

// getFilterType returns the appropriate Filter type for a field type
func getFilterType(fieldType *parser.FieldType) string {
	if fieldType == nil {
		return "StringFilter" // Default
	}

	typeMapping := parser.GetTypeGoMapping()
	if mapped, ok := typeMapping[fieldType.Name]; ok {
		switch mapped {
		case "string":
			return "StringFilter"
		case "int":
			return "IntFilter"
		case "int64":
			return "Int64Filter"
		case "float64":
			return "FloatFilter"
		case "bool":
			return "BooleanFilter"
		case "time.Time":
			return "DateTimeFilter"
		case "json.RawMessage":
			return "JsonFilter"
		case "[]byte":
			return "BytesFilter"
		}
	}

	// For enums and relationships, use StringFilter by default
	return "StringFilter"
}

// generateFiltersFile generates all Filter types in a single shared file
func generateFiltersFile(filePath string, schema *parser.Schema) error {
	file, err := createGeneratedFile(filePath, "inputs")
	if err != nil {
		return err
	}
	defer file.Close()

	// Determine which filter types are needed across all models
	neededFilters := make(map[string]bool)
	for _, model := range schema.Models {
		for _, field := range model.Fields {
			if !isRelation(field, schema) && field.Type != nil {
				filterType := getFilterType(field.Type)
				neededFilters[filterType] = true
			}
		}
	}

	// Determine required imports
	imports := make([]string, 0, 2)
	if neededFilters["DateTimeFilter"] {
		imports = append(imports, "time")
	}
	if neededFilters["JsonFilter"] {
		imports = append(imports, "encoding/json")
	}

	writeImports(file, imports)

	// Generate all needed filter types
	if neededFilters["StringFilter"] {
		generateStringFilterType(file)
	}
	if neededFilters["IntFilter"] {
		generateIntFilterType(file)
	}
	if neededFilters["Int64Filter"] {
		generateInt64FilterType(file)
	}
	if neededFilters["FloatFilter"] {
		generateFloatFilterType(file)
	}
	if neededFilters["BooleanFilter"] {
		generateBooleanFilterType(file)
	}
	if neededFilters["DateTimeFilter"] {
		generateDateTimeFilterType(file)
	}
	if neededFilters["JsonFilter"] {
		generateJsonFilterType(file)
	}
	if neededFilters["BytesFilter"] {
		generateBytesFilterType(file)
	}

	return nil
}

// generateFilterTypes is deprecated - use generateFiltersFile instead
// This function is kept for backward compatibility but should not be used
// nolint: unused // Kept for reference or compatibility
func generateFilterTypes(file *os.File, model *parser.Model) {
	// This function is no longer used - filters are generated in filters.go
}

func generateStringFilterType(file *os.File) {
	fmt.Fprintf(file, "// StringFilter represents filter conditions for string fields\n")
	fmt.Fprintf(file, "type StringFilter struct {\n")
	fmt.Fprintf(file, "\tEquals              *string  `json:\"equals,omitempty\"`\n")
	fmt.Fprintf(file, "\tNotEquals           *string  `json:\"notEquals,omitempty\"`\n")
	fmt.Fprintf(file, "\tContains            *string  `json:\"contains,omitempty\"`\n")
	fmt.Fprintf(file, "\tStartsWith          *string  `json:\"startsWith,omitempty\"`\n")
	fmt.Fprintf(file, "\tEndsWith            *string  `json:\"endsWith,omitempty\"`\n")
	fmt.Fprintf(file, "\tContainsInsensitive *string  `json:\"containsInsensitive,omitempty\"`\n")
	fmt.Fprintf(file, "\tStartsWithInsensitive *string `json:\"startsWithInsensitive,omitempty\"`\n")
	fmt.Fprintf(file, "\tEndsWithInsensitive *string  `json:\"endsWithInsensitive,omitempty\"`\n")
	fmt.Fprintf(file, "\tIn                 []string `json:\"in,omitempty\"`\n")
	fmt.Fprintf(file, "\tNotIn              []string `json:\"notIn,omitempty\"`\n")
	fmt.Fprintf(file, "\tIsNull             *bool    `json:\"isNull,omitempty\"`\n")
	fmt.Fprintf(file, "\tIsNotNull          *bool    `json:\"isNotNull,omitempty\"`\n")
	fmt.Fprintf(file, "}\n\n")
}

func generateIntFilterType(file *os.File) {
	fmt.Fprintf(file, "// IntFilter represents filter conditions for int fields\n")
	fmt.Fprintf(file, "type IntFilter struct {\n")
	fmt.Fprintf(file, "\tEquals    *int   `json:\"equals,omitempty\"`\n")
	fmt.Fprintf(file, "\tNotEquals *int   `json:\"notEquals,omitempty\"`\n")
	fmt.Fprintf(file, "\tGt        *int   `json:\"gt,omitempty\"`\n")
	fmt.Fprintf(file, "\tGte       *int   `json:\"gte,omitempty\"`\n")
	fmt.Fprintf(file, "\tLt        *int   `json:\"lt,omitempty\"`\n")
	fmt.Fprintf(file, "\tLte       *int   `json:\"lte,omitempty\"`\n")
	fmt.Fprintf(file, "\tIn        []int  `json:\"in,omitempty\"`\n")
	fmt.Fprintf(file, "\tNotIn     []int  `json:\"notIn,omitempty\"`\n")
	fmt.Fprintf(file, "\tIsNull    *bool  `json:\"isNull,omitempty\"`\n")
	fmt.Fprintf(file, "\tIsNotNull *bool  `json:\"isNotNull,omitempty\"`\n")
	fmt.Fprintf(file, "}\n\n")
}

func generateInt64FilterType(file *os.File) {
	fmt.Fprintf(file, "// Int64Filter represents filter conditions for int64 (BigInt) fields\n")
	fmt.Fprintf(file, "type Int64Filter struct {\n")
	fmt.Fprintf(file, "\tEquals    *int64  `json:\"equals,omitempty\"`\n")
	fmt.Fprintf(file, "\tNotEquals *int64  `json:\"notEquals,omitempty\"`\n")
	fmt.Fprintf(file, "\tGt        *int64  `json:\"gt,omitempty\"`\n")
	fmt.Fprintf(file, "\tGte       *int64  `json:\"gte,omitempty\"`\n")
	fmt.Fprintf(file, "\tLt        *int64  `json:\"lt,omitempty\"`\n")
	fmt.Fprintf(file, "\tLte       *int64  `json:\"lte,omitempty\"`\n")
	fmt.Fprintf(file, "\tIn        []int64 `json:\"in,omitempty\"`\n")
	fmt.Fprintf(file, "\tNotIn     []int64 `json:\"notIn,omitempty\"`\n")
	fmt.Fprintf(file, "\tIsNull    *bool   `json:\"isNull,omitempty\"`\n")
	fmt.Fprintf(file, "\tIsNotNull *bool   `json:\"isNotNull,omitempty\"`\n")
	fmt.Fprintf(file, "}\n\n")
}

func generateFloatFilterType(file *os.File) {
	fmt.Fprintf(file, "// FloatFilter represents filter conditions for float64 fields\n")
	fmt.Fprintf(file, "type FloatFilter struct {\n")
	fmt.Fprintf(file, "\tEquals    *float64  `json:\"equals,omitempty\"`\n")
	fmt.Fprintf(file, "\tNotEquals *float64  `json:\"notEquals,omitempty\"`\n")
	fmt.Fprintf(file, "\tGt        *float64  `json:\"gt,omitempty\"`\n")
	fmt.Fprintf(file, "\tGte       *float64  `json:\"gte,omitempty\"`\n")
	fmt.Fprintf(file, "\tLt        *float64  `json:\"lt,omitempty\"`\n")
	fmt.Fprintf(file, "\tLte       *float64  `json:\"lte,omitempty\"`\n")
	fmt.Fprintf(file, "\tIn        []float64 `json:\"in,omitempty\"`\n")
	fmt.Fprintf(file, "\tNotIn     []float64 `json:\"notIn,omitempty\"`\n")
	fmt.Fprintf(file, "\tIsNull    *bool     `json:\"isNull,omitempty\"`\n")
	fmt.Fprintf(file, "\tIsNotNull *bool     `json:\"isNotNull,omitempty\"`\n")
	fmt.Fprintf(file, "}\n\n")
}

func generateBooleanFilterType(file *os.File) {
	fmt.Fprintf(file, "// BooleanFilter represents filter conditions for bool fields\n")
	fmt.Fprintf(file, "type BooleanFilter struct {\n")
	fmt.Fprintf(file, "\tEquals    *bool `json:\"equals,omitempty\"`\n")
	fmt.Fprintf(file, "\tNotEquals *bool `json:\"notEquals,omitempty\"`\n")
	fmt.Fprintf(file, "\tIsNull    *bool `json:\"isNull,omitempty\"`\n")
	fmt.Fprintf(file, "\tIsNotNull *bool `json:\"isNotNull,omitempty\"`\n")
	fmt.Fprintf(file, "}\n\n")
}

func generateDateTimeFilterType(file *os.File) {
	fmt.Fprintf(file, "// DateTimeFilter represents filter conditions for time.Time fields\n")
	fmt.Fprintf(file, "type DateTimeFilter struct {\n")
	fmt.Fprintf(file, "\tEquals    *time.Time  `json:\"equals,omitempty\"`\n")
	fmt.Fprintf(file, "\tNotEquals *time.Time  `json:\"notEquals,omitempty\"`\n")
	fmt.Fprintf(file, "\tGt        *time.Time  `json:\"gt,omitempty\"`\n")
	fmt.Fprintf(file, "\tGte       *time.Time  `json:\"gte,omitempty\"`\n")
	fmt.Fprintf(file, "\tLt        *time.Time  `json:\"lt,omitempty\"`\n")
	fmt.Fprintf(file, "\tLte       *time.Time  `json:\"lte,omitempty\"`\n")
	fmt.Fprintf(file, "\tIsNull    *bool       `json:\"isNull,omitempty\"`\n")
	fmt.Fprintf(file, "\tIsNotNull *bool       `json:\"isNotNull,omitempty\"`\n")
	fmt.Fprintf(file, "}\n\n")
}

func generateJsonFilterType(file *os.File) {
	fmt.Fprintf(file, "// JsonFilter represents filter conditions for json.RawMessage fields\n")
	fmt.Fprintf(file, "type JsonFilter struct {\n")
	fmt.Fprintf(file, "\tEquals    *json.RawMessage `json:\"equals,omitempty\"`\n")
	fmt.Fprintf(file, "\tNotEquals *json.RawMessage `json:\"notEquals,omitempty\"`\n")
	fmt.Fprintf(file, "\tIsNull    *bool            `json:\"isNull,omitempty\"`\n")
	fmt.Fprintf(file, "\tIsNotNull *bool            `json:\"isNotNull,omitempty\"`\n")
	fmt.Fprintf(file, "}\n\n")
}

func generateBytesFilterType(file *os.File) {
	fmt.Fprintf(file, "// BytesFilter represents filter conditions for []byte fields\n")
	fmt.Fprintf(file, "type BytesFilter struct {\n")
	fmt.Fprintf(file, "\tEquals    *[]byte `json:\"equals,omitempty\"`\n")
	fmt.Fprintf(file, "\tNotEquals *[]byte `json:\"notEquals,omitempty\"`\n")
	fmt.Fprintf(file, "\tIsNull    *bool   `json:\"isNull,omitempty\"`\n")
	fmt.Fprintf(file, "\tIsNotNull *bool   `json:\"isNotNull,omitempty\"`\n")
	fmt.Fprintf(file, "}\n\n")
}
