package generator

import (
	"fmt"
	"os"
	"path/filepath"

	"github.com/carlosnayan/prisma-go-client/internal/parser"
)

// GenerateInputs generates auxiliary types (CreateInput, UpdateInput) for each model
func GenerateInputs(schema *parser.Schema, outputDir string) error {
	inputsDir := filepath.Join(outputDir, "inputs")
	if err := os.MkdirAll(inputsDir, 0755); err != nil {
		return fmt.Errorf("failed to create inputs directory: %w", err)
	}

	// Generate Filter types once in a shared file
	filtersFile := filepath.Join(inputsDir, "filters.go")
	if err := generateFiltersFile(filtersFile, schema); err != nil {
		return fmt.Errorf("failed to generate filters: %w", err)
	}

	// Generate input types for each model
	for _, model := range schema.Models {
		inputFile := filepath.Join(inputsDir, toSnakeCase(model.Name)+"_input.go")
		if err := generateInputFile(inputFile, model, schema); err != nil {
			return fmt.Errorf("failed to generate inputs for %s: %w", model.Name, err)
		}
	}

	return nil
}

// generateInputFile generates input types for a model using templates
func generateInputFile(filePath string, model *parser.Model, schema *parser.Schema) error {
	pascalModelName := toPascalCase(model.Name)

	// Determine required imports
	imports := determineInputImports(model, schema)
	stdlib := make([]string, 0, len(imports))
	for _, imp := range imports {
		if isStdlibImport(imp) {
			stdlib = append(stdlib, imp)
		}
	}

	// Prepare CreateInput fields
	createFields := make([]InputFieldInfo, 0)
	for _, field := range model.Fields {
		if isAutoGenerated(field) || isRelation(field, schema) {
			continue
		}
		fieldName := toPascalCase(field.Name)
		goType := fieldTypeToGoBase(field.Type)
		isOptional := field.Type != nil && field.Type.IsOptional
		if isOptional {
			goType = "*" + goType
		}
		jsonTag := toSnakeCase(field.Name)

		createFields = append(createFields, InputFieldInfo{
			FieldName: fieldName,
			GoType:    goType,
			JSONTag:   jsonTag,
		})
	}

	// Prepare UpdateInput fields
	updateFields := make([]InputFieldInfo, 0)
	for _, field := range model.Fields {
		if isAutoGenerated(field) || isPrimaryKey(field) || isRelation(field, schema) {
			continue
		}
		fieldName := toPascalCase(field.Name)
		goType := fieldTypeToGoBase(field.Type)
		// UpdateInput fields are always optional
		goType = "*" + goType
		jsonTag := toSnakeCase(field.Name)

		updateFields = append(updateFields, InputFieldInfo{
			FieldName: fieldName,
			GoType:    goType,
			JSONTag:   jsonTag,
		})
	}

	// Prepare WhereInput fields
	whereInputFields := make([]WhereInputFieldInfo, 0)
	for _, field := range model.Fields {
		if isRelation(field, schema) {
			continue
		}
		fieldName := toPascalCase(field.Name)
		filterType := getFilterType(field.Type)
		jsonTag := toSnakeCase(field.Name)

		whereInputFields = append(whereInputFields, WhereInputFieldInfo{
			FieldName:  fieldName,
			FilterType: filterType,
			JSONTag:    jsonTag,
		})
	}

	// Prepare Select fields
	selectFields := make([]InputSelectFieldInfo, 0)
	for _, field := range model.Fields {
		if isRelation(field, schema) {
			continue
		}
		fieldName := toPascalCase(field.Name)
		jsonTag := toSnakeCase(field.Name)

		selectFields = append(selectFields, InputSelectFieldInfo{
			FieldName: fieldName,
			JSONTag:   jsonTag,
		})
	}

	// Prepare template data
	data := InputTemplateData{
		ModelName:        model.Name,
		PascalName:       pascalModelName,
		StdlibImports:    stdlib,
		CreateFields:     createFields,
		UpdateFields:     updateFields,
		WhereInputFields: whereInputFields,
		SelectFields:     selectFields,
	}

	// Define template order
	templateNames := []string{
		"model_imports.tmpl",
		"create_input.tmpl",
		"update_input.tmpl",
		"where_input.tmpl",
		"select_input.tmpl",
	}

	// Generate input file using templates
	return executeInputTemplates(filePath, templateNames, data)
}

// generateFiltersFile generates all Filter types in a single shared file using templates
func generateFiltersFile(filePath string, schema *parser.Schema) error {
	// Determine which filter types are needed across all models
	neededFilters := make(map[string]bool)
	for _, model := range schema.Models {
		for _, field := range model.Fields {
			if !isRelation(field, schema) && field.Type != nil {
				filterType := getFilterType(field.Type)
				neededFilters[filterType] = true
			}
		}
	}

	// Determine required imports
	stdlibImports := make([]string, 0, 2)
	if neededFilters["DateTimeFilter"] {
		stdlibImports = append(stdlibImports, "time")
	}
	if neededFilters["JsonFilter"] {
		stdlibImports = append(stdlibImports, "encoding/json")
	}

	// Prepare template data
	data := FiltersTemplateData{
		StdlibImports: stdlibImports,
		NeededFilters: neededFilters,
	}

	// Define template order
	templateNames := []string{
		"filters_imports.tmpl",
	}

	// Add filter type templates based on what's needed
	if neededFilters["StringFilter"] {
		templateNames = append(templateNames, "string_filter.tmpl")
	}
	if neededFilters["IntFilter"] {
		templateNames = append(templateNames, "int_filter.tmpl")
	}
	if neededFilters["Int64Filter"] {
		templateNames = append(templateNames, "int64_filter.tmpl")
	}
	if neededFilters["FloatFilter"] {
		templateNames = append(templateNames, "float_filter.tmpl")
	}
	if neededFilters["BooleanFilter"] {
		templateNames = append(templateNames, "boolean_filter.tmpl")
	}
	if neededFilters["DateTimeFilter"] {
		templateNames = append(templateNames, "datetime_filter.tmpl")
	}
	if neededFilters["JsonFilter"] {
		templateNames = append(templateNames, "json_filter.tmpl")
	}
	if neededFilters["BytesFilter"] {
		templateNames = append(templateNames, "bytes_filter.tmpl")
	}

	// Generate filters file using templates
	return executeFiltersTemplates(filePath, templateNames, data)
}

// fieldTypeToGoBase returns the base Go type without pointers (for input types)
func fieldTypeToGoBase(fieldType *parser.FieldType) string {
	if fieldType == nil {
		return "interface{}"
	}

	if fieldType.IsUnsupported {
		return "string"
	}

	typeMapping := parser.GetTypeGoMapping()

	var goType string
	if mapped, ok := typeMapping[fieldType.Name]; ok {
		// Primitive type - return without pointer
		goType = mapped
	} else {
		// May be enum or model - for now string
		goType = "string"
	}

	// Se Ã© array
	if fieldType.IsArray {
		return "[]" + goType
	}

	return goType
}

// isAutoGenerated checks if a field is auto-generated (id with autoincrement)
func isAutoGenerated(field *parser.ModelField) bool {
	hasID := false
	hasAutoIncrement := false
	for _, attr := range field.Attributes {
		if attr.Name == "id" {
			hasID = true
		}
		if attr.Name == "default" {
			for _, arg := range attr.Arguments {
				if arg.Value == "autoincrement()" {
					hasAutoIncrement = true
				}
			}
		}
	}

	if hasID && hasAutoIncrement {
		return true
	}

	return false
}

// isPrimaryKey checks if a field is a primary key
func isPrimaryKey(field *parser.ModelField) bool {
	for _, attr := range field.Attributes {
		if attr.Name == "id" {
			return true
		}
	}
	return false
}

// isRelation checks if a field is a relationship (non-primitive type)
// It returns false for enums, which are scalar types, not relationships
func isRelation(field *parser.ModelField, schema *parser.Schema) bool {
	if field.Type == nil {
		return false
	}

	// Known builtin types
	builtinTypes := map[string]bool{
		"String":   true,
		"Int":      true,
		"BigInt":   true,
		"Float":    true,
		"Decimal":  true,
		"Boolean":  true,
		"DateTime": true,
		"Json":     true,
		"Bytes":    true,
	}

	// If it's a builtin type, it's not a relation
	if builtinTypes[field.Type.Name] {
		return false
	}

	// Check if it's an enum - enums are scalar types, not relationships
	for _, enum := range schema.Enums {
		if enum.Name == field.Type.Name {
			return false
		}
	}

	// If it's not a builtin type and not an enum, it's probably a relationship
	return true
}

// determineInputImports determines which imports are needed for input types
// Only checks fields that are actually generated in CreateInput or UpdateInput
// WhereInput uses Filter types from filters.go, so it doesn't need imports here
func determineInputImports(model *parser.Model, schema *parser.Schema) []string {
	imports := make(map[string]bool, 2)

	// Check only fields that will be generated in CreateInput or UpdateInput
	for _, field := range model.Fields {
		if field.Type == nil {
			continue
		}

		// Check if field appears in CreateInput (skip auto-generated and relations)
		needsTimeInCreate := false
		needsJsonInCreate := false
		if !isAutoGenerated(field) && !isRelation(field, schema) {
			typeMapping := parser.GetTypeGoMapping()
			if mapped, ok := typeMapping[field.Type.Name]; ok {
				switch mapped {
				case "time.Time":
					needsTimeInCreate = true
				case "json.RawMessage":
					needsJsonInCreate = true
				}
			}
		}

		// Check if field appears in UpdateInput (skip auto-generated, primary keys, and relations)
		needsTimeInUpdate := false
		needsJsonInUpdate := false
		if !isAutoGenerated(field) && !isPrimaryKey(field) && !isRelation(field, schema) {
			typeMapping := parser.GetTypeGoMapping()
			if mapped, ok := typeMapping[field.Type.Name]; ok {
				switch mapped {
				case "time.Time":
					needsTimeInUpdate = true
				case "json.RawMessage":
					needsJsonInUpdate = true
				}
			}
		}

		// Add imports only if field is actually used in CreateInput or UpdateInput
		if needsTimeInCreate || needsTimeInUpdate {
			imports["time"] = true
		}
		if needsJsonInCreate || needsJsonInUpdate {
			imports["encoding/json"] = true
		}
	}

	result := make([]string, 0, len(imports))
	if imports["time"] {
		result = append(result, "time")
	}
	if imports["encoding/json"] {
		result = append(result, "encoding/json")
	}

	return result
}

// getFilterType returns the appropriate Filter type for a field type
func getFilterType(fieldType *parser.FieldType) string {
	if fieldType == nil {
		return "StringFilter" // Default
	}

	typeMapping := parser.GetTypeGoMapping()
	if mapped, ok := typeMapping[fieldType.Name]; ok {
		switch mapped {
		case "string":
			return "StringFilter"
		case "int":
			return "IntFilter"
		case "int64":
			return "Int64Filter"
		case "float64":
			return "FloatFilter"
		case "bool":
			return "BooleanFilter"
		case "time.Time":
			return "DateTimeFilter"
		case "json.RawMessage":
			return "JsonFilter"
		case "[]byte":
			return "BytesFilter"
		}
	}

	// For enums and relationships, use StringFilter by default
	return "StringFilter"
}
