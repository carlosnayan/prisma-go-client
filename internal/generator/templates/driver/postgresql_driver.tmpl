// PgxPoolAdapter adapts *pgxpool.Pool to builder.DBTX
type PgxPoolAdapter struct {
	pool *pgxpool.Pool
}

// NewPgxPoolDriver creates a new driver adapter from a pgxpool.Pool
// This allows you to use pgx pool with the Prisma client without
// importing internal packages.
func NewPgxPoolDriver(pool *pgxpool.Pool) builder.DBTX {
	return &PgxPoolAdapter{pool: pool}
}

// NewPgxPoolFromURL creates a new pgx pool from a database URL
// with PgBouncer-compatible settings (prepared statements disabled).
// This is the recommended way to create a pool for use with NewPgxPoolDriver.
// Example: pool, err := db.NewPgxPoolFromURL(ctx, databaseURL)
func NewPgxPoolFromURL(ctx context.Context, databaseURL string) (*pgxpool.Pool, error) {
	cfg, err := pgxpool.ParseConfig(databaseURL)
	if err != nil {
		return nil, fmt.Errorf("error parsing database URL: %w", err)
	}

	// Disable prepared statements for PgBouncer compatibility
	cfg.ConnConfig.DefaultQueryExecMode = pgx.QueryExecModeSimpleProtocol

	pool, err := pgxpool.NewWithConfig(ctx, cfg)
	if err != nil {
		return nil, fmt.Errorf("error creating pool: %w", err)
	}

	return pool, nil
}

// Exec executes a query that doesn't return rows
func (a *PgxPoolAdapter) Exec(ctx context.Context, sql string, args ...interface{}) (builder.Result, error) {
	result, err := a.pool.Exec(ctx, sql, args...)
	if err != nil {
		return nil, err
	}
	return &PgxResult{result: result}, nil
}

// Query executes a query that returns multiple rows
func (a *PgxPoolAdapter) Query(ctx context.Context, sql string, args ...interface{}) (builder.Rows, error) {
	rows, err := a.pool.Query(ctx, sql, args...)
	if err != nil {
		return nil, err
	}
	return &PgxRows{rows: rows}, nil
}

// QueryRow executes a query that returns a single row
func (a *PgxPoolAdapter) QueryRow(ctx context.Context, sql string, args ...interface{}) builder.Row {
	return &PgxRow{row: a.pool.QueryRow(ctx, sql, args...)}
}

// Begin starts a transaction
func (a *PgxPoolAdapter) Begin(ctx context.Context) (builder.Tx, error) {
	tx, err := a.pool.Begin(ctx)
	if err != nil {
		return nil, err
	}
	return &PgxTx{tx: tx}, nil
}

// SQLDB returns nil as pgxpool.Pool doesn't provide *sql.DB directly
func (a *PgxPoolAdapter) SQLDB() *sql.DB {
	return nil
}

// PgxResult wraps pgconn.CommandTag
type PgxResult struct {
	result pgconn.CommandTag
}

// RowsAffected returns the number of rows affected
func (r *PgxResult) RowsAffected() int64 {
	return r.result.RowsAffected()
}

// LastInsertId returns the integer generated by the database
// PostgreSQL doesn't support LastInsertId in the same way as MySQL/SQLite
// This returns 0 and an error indicating that RETURNING should be used instead
func (r *PgxResult) LastInsertId() (int64, error) {
	return 0, fmt.Errorf("PostgreSQL does not support LastInsertId, use RETURNING clause instead")
}

// PgxRows wraps pgx.Rows
type PgxRows struct {
	rows pgx.Rows
}

// Close closes the rows iterator
func (r *PgxRows) Close() {
	r.rows.Close()
}

// Err returns any error that occurred during iteration
func (r *PgxRows) Err() error {
	return r.rows.Err()
}

// Next prepares the next result row for reading
func (r *PgxRows) Next() bool {
	return r.rows.Next()
}

// Scan copies the columns in the current row into the values pointed at by dest
func (r *PgxRows) Scan(dest ...interface{}) error {
	return r.rows.Scan(dest...)
}

// PgxRow wraps pgx.Row
type PgxRow struct {
	row pgx.Row
}

// Scan copies the columns in the current row into the values pointed at by dest
func (r *PgxRow) Scan(dest ...interface{}) error {
	return r.row.Scan(dest...)
}

// PgxTx wraps pgx.Tx
type PgxTx struct {
	tx pgx.Tx
}

// Commit commits the transaction
func (t *PgxTx) Commit(ctx context.Context) error {
	return t.tx.Commit(ctx)
}

// Rollback rolls back the transaction
func (t *PgxTx) Rollback(ctx context.Context) error {
	return t.tx.Rollback(ctx)
}

// Exec executes a query that doesn't return rows
func (t *PgxTx) Exec(ctx context.Context, sql string, args ...interface{}) (builder.Result, error) {
	result, err := t.tx.Exec(ctx, sql, args...)
	if err != nil {
		return nil, err
	}
	return &PgxResult{result: result}, nil
}

// Query executes a query that returns multiple rows
func (t *PgxTx) Query(ctx context.Context, sql string, args ...interface{}) (builder.Rows, error) {
	rows, err := t.tx.Query(ctx, sql, args...)
	if err != nil {
		return nil, err
	}
	return &PgxRows{rows: rows}, nil
}

// QueryRow executes a query that returns a single row
func (t *PgxTx) QueryRow(ctx context.Context, sql string, args ...interface{}) builder.Row {
	row := t.tx.QueryRow(ctx, sql, args...)
	return &PgxRow{row: row}
}

// NewSQLDriver creates a new driver adapter from a *sql.DB
// This allows you to use database/sql with the Prisma client without
// importing internal packages.
// Note: For PostgreSQL, prefer NewPgxPoolDriver for better performance.
func NewSQLDriver(db *sql.DB) builder.DBTX {
	return &SQLDBAdapter{db: db}
}

