// buildSelectQuery builds the SELECT query

func (q *Query) buildSelectQuery(single bool) (string, []interface{}) {

	var parts []string

	var args []interface{}

	argIndex := 1

	// SELECT

	parts = append(parts, "SELECT")

	if len(q.selectFields) > 0 {

		quotedFields := make([]string, len(q.selectFields))

		for i, field := range q.selectFields {

			quotedFields[i] = q.dialect.QuoteIdentifier(field)

		}

		parts = append(parts, strings.Join(quotedFields, ", "))

	} else {

		quotedColumns := make([]string, len(q.columns))

		for i, col := range q.columns {

			quotedColumns[i] = q.dialect.QuoteIdentifier(col)

		}

		parts = append(parts, strings.Join(quotedColumns, ", "))

	}

	// FROM

	parts = append(parts, "FROM", q.dialect.QuoteIdentifier(q.table))

	// JOINs

	for _, join := range q.joins {

		parts = append(parts, fmt.Sprintf("%s JOIN %s ON %s", join.joinType, q.dialect.QuoteIdentifier(join.table), join.on))

		args = append(args, join.args...)

		argIndex += len(join.args)

	}

	// WHERE

	if len(q.whereConditions) > 0 {

		whereClause, whereArgs := q.buildWhereClause(&argIndex)

		parts = append(parts, "WHERE", whereClause)

		args = append(args, whereArgs...)

	}

	// GROUP BY

	if len(q.groupBy) > 0 {

		quotedGroupBy := make([]string, len(q.groupBy))

		for i, field := range q.groupBy {

			quotedGroupBy[i] = q.dialect.QuoteIdentifier(field)

		}

		parts = append(parts, "GROUP BY", strings.Join(quotedGroupBy, ", "))

	}

	// HAVING

	if len(q.having) > 0 {

		havingClause, havingArgs := q.buildHavingClause(&argIndex)

		parts = append(parts, "HAVING", havingClause)

		args = append(args, havingArgs...)

	}

	// ORDER BY

	if len(q.orderBy) > 0 {

		var orderParts []string

		for _, order := range q.orderBy {

			orderParts = append(orderParts, fmt.Sprintf("%s %s", q.dialect.QuoteIdentifier(order.Field), order.Order))

		}

		parts = append(parts, "ORDER BY", strings.Join(orderParts, ", "))

	}

	if single {

		parts = append(parts, "LIMIT 1")

	} else if q.take != nil || q.skip != nil {

		limit := 0

		offset := 0

		if q.take != nil {

			limit = *q.take

		}

		if q.skip != nil {

			offset = *q.skip

		}

		limitOffset := q.dialect.GetLimitOffsetSyntax(limit, offset)

		if limitOffset != "" {

			parts = append(parts, limitOffset)

		}

		// Note: GetLimitOffsetSyntax already includes the values in the SQL string,

		// so we don't need to add them to args

	}

	return strings.Join(parts, " "), args

}

// buildWhereClause builds the WHERE clause

func (q *Query) buildWhereClause(argIndex *int) (string, []interface{}) {

	if len(q.whereConditions) == 0 {

		return "", nil

	}

	var parts []string

	var args []interface{}

	for i, cond := range q.whereConditions {

		if i > 0 {

			if cond.or {

				parts = append(parts, "OR")

			} else {

				parts = append(parts, "AND")

			}

		}

		query := cond.query

		var queryBuilder strings.Builder

		queryBuilder.Grow(len(query) + 100)

		argPos := 0

		for i := 0; i < len(query); i++ {

			if query[i] == '?' && argPos < len(cond.args) {

				arg := cond.args[argPos]

				if reflect.TypeOf(arg).Kind() == reflect.Slice {

					slice := reflect.ValueOf(arg)

					placeholders := make([]string, slice.Len())

					for j := 0; j < slice.Len(); j++ {

						placeholders[j] = q.dialect.GetPlaceholder(*argIndex)

						args = append(args, slice.Index(j).Interface())

						(*argIndex)++

					}

					queryBuilder.WriteString(fmt.Sprintf("(%s)", strings.Join(placeholders, ", ")))

				} else {

					queryBuilder.WriteString(q.dialect.GetPlaceholder(*argIndex))

					args = append(args, arg)

					(*argIndex)++

				}

				argPos++

			} else {

				queryBuilder.WriteByte(query[i])

			}

		}

		query = queryBuilder.String()

		parts = append(parts, query)

	}

	return strings.Join(parts, " "), args

}

// buildHavingClause builds the HAVING clause

func (q *Query) buildHavingClause(argIndex *int) (string, []interface{}) {

	return q.buildWhereClause(argIndex)

}

// buildCountQuery builds the COUNT query

func (q *Query) buildCountQuery() (string, []interface{}) {

	var parts []string

	var args []interface{}

	argIndex := 1

	parts = append(parts, "SELECT COUNT(*) FROM", q.dialect.QuoteIdentifier(q.table))

	// JOINs

	for _, join := range q.joins {

		parts = append(parts, fmt.Sprintf("%s JOIN %s ON %s", join.joinType, q.dialect.QuoteIdentifier(join.table), join.on))

		args = append(args, join.args...)

		argIndex += len(join.args)

	}

	// WHERE

	if len(q.whereConditions) > 0 {

		whereClause, whereArgs := q.buildWhereClause(&argIndex)

		parts = append(parts, "WHERE", whereClause)

		args = append(args, whereArgs...)

	}

	return strings.Join(parts, " "), args

}

// buildInsertQuery builds the INSERT query

func (q *Query) buildInsertQuery(value interface{}) (string, []interface{}) {

	val := reflect.ValueOf(value)

	if val.Kind() == reflect.Ptr {

		val = val.Elem()

	}

	if val.Kind() != reflect.Struct {

		return "", nil

	}

	var columns []string

	var values []string

	var args []interface{}

	argIndex := 1

	typ := val.Type()

	var primaryKeyValue interface{}

	var primaryKeyCol string

	var primaryKeyType reflect.Kind

	var primaryKeyIsZero bool

	for i := 0; i < val.NumField(); i++ {

		field := typ.Field(i)

		fieldVal := val.Field(i)

		// Use db tag if available, otherwise use snake_case of field name

		dbTag := field.Tag.Get("db")

		fieldName := dbTag

		if fieldName == "" {

			fieldName = toSnakeCase(field.Name)

		}

		if fieldName == q.primaryKey {

			primaryKeyCol = fieldName

			primaryKeyValue = fieldVal.Interface()

			primaryKeyType = fieldVal.Kind()

			primaryKeyIsZero = fieldVal.IsZero()

			continue

		}

		if fieldVal.IsZero() {

			continue

		}

		columns = append(columns, fieldName)

		values = append(values, q.dialect.GetPlaceholder(argIndex))

		args = append(args, fieldVal.Interface())

		argIndex++

	}

	if primaryKeyCol != "" {

		if !primaryKeyIsZero {

			columns = append(columns, primaryKeyCol)

			values = append(values, q.dialect.GetPlaceholder(argIndex))

			args = append(args, primaryKeyValue)

			argIndex++

		} else if primaryKeyType == reflect.String {

			generatedUUID := {{.UtilsPackageName}}.GenerateUUID()

			columns = append(columns, primaryKeyCol)

			values = append(values, q.dialect.GetPlaceholder(argIndex))

			args = append(args, generatedUUID)

			argIndex++

		}

	}

	quotedColumns := make([]string, len(columns))

	for i, col := range columns {

		quotedColumns[i] = q.dialect.QuoteIdentifier(col)

	}

	query := fmt.Sprintf(

		"INSERT INTO %s (%s) VALUES (%s)",

		q.dialect.QuoteIdentifier(q.table),

		strings.Join(quotedColumns, ", "),

		strings.Join(values, ", "),

	)

	return query, args

}

// buildUpsertQuery builds an INSERT ... ON CONFLICT (upsert) query

func (q *Query) buildUpsertQuery(value interface{}) (string, []interface{}) {

	val := reflect.ValueOf(value)

	if val.Kind() == reflect.Ptr {

		val = val.Elem()

	}

	if val.Kind() != reflect.Struct {

		return "", nil

	}

	var columns []string

	var values []string

	var args []interface{}

	argIndex := 1

	typ := val.Type()

	var primaryKeyValue interface{}

	var primaryKeyCol string

	for i := 0; i < val.NumField(); i++ {

		field := typ.Field(i)

		fieldVal := val.Field(i)

		// Use db tag if available, otherwise use snake_case of field name

		dbTag := field.Tag.Get("db")

		fieldName := dbTag

		if fieldName == "" {

			fieldName = toSnakeCase(field.Name)

		}

		if fieldName == q.primaryKey {

			primaryKeyCol = fieldName

			primaryKeyValue = fieldVal.Interface()

			continue

		}

		if fieldVal.IsZero() {

			continue

		}

		columns = append(columns, fieldName)

		values = append(values, q.dialect.GetPlaceholder(argIndex))

		args = append(args, fieldVal.Interface())

		argIndex++

	}

	if primaryKeyCol != "" && primaryKeyValue != nil {

		columns = append(columns, primaryKeyCol)

		values = append(values, q.dialect.GetPlaceholder(argIndex))

		args = append(args, primaryKeyValue)

		argIndex++

	}

	quotedColumns := make([]string, len(columns))

	for i, col := range columns {

		quotedColumns[i] = q.dialect.QuoteIdentifier(col)

	}

	quotedTable := q.dialect.QuoteIdentifier(q.table)

	insertPart := fmt.Sprintf(

		"INSERT INTO %s (%s) VALUES (%s)",

		quotedTable,

		strings.Join(quotedColumns, ", "),

		strings.Join(values, ", "),

	)

	dialectName := q.dialect.Name()

	var conflictPart string

	if dialectName == "postgresql" || dialectName == "postgres" || dialectName == "sqlite" {

		if primaryKeyCol != "" {

			quotedPK := q.dialect.QuoteIdentifier(primaryKeyCol)

			var updateParts []string

			for _, col := range columns {

				if col == primaryKeyCol {

					continue

				}

				quotedCol := q.dialect.QuoteIdentifier(col)

				updateParts = append(updateParts, fmt.Sprintf("%s = EXCLUDED.%s", quotedCol, quotedCol))

			}

			conflictPart = fmt.Sprintf("ON CONFLICT (%s) DO UPDATE SET %s", quotedPK, strings.Join(updateParts, ", "))

		} else {

			return insertPart, args

		}

	} else if dialectName == "mysql" || dialectName == "mariadb" {

		if primaryKeyCol != "" {

			var updateParts []string

			for _, col := range columns {

				if col == primaryKeyCol {

					continue

				}

				quotedCol := q.dialect.QuoteIdentifier(col)

				updateParts = append(updateParts, fmt.Sprintf("%s = VALUES(%s)", quotedCol, quotedCol))

			}

			conflictPart = fmt.Sprintf("ON DUPLICATE KEY UPDATE %s", strings.Join(updateParts, ", "))

		} else {

			return insertPart, args

		}

	} else {

		return insertPart, args

	}

	query := fmt.Sprintf("%s %s", insertPart, conflictPart)

	return query, args

}

// buildUpdateQuery builds the UPDATE query

func (q *Query) buildUpdateQuery(column string, value interface{}) (string, []interface{}) {

	var parts []string

	var args []interface{}

	argIndex := 1

	parts = append(parts, fmt.Sprintf("UPDATE %s SET %s = %s",

		q.dialect.QuoteIdentifier(q.table),

		q.dialect.QuoteIdentifier(column),

		q.dialect.GetPlaceholder(argIndex)))

	args = append(args, value)

	argIndex++

	// WHERE

	if len(q.whereConditions) > 0 {

		whereClause, whereArgs := q.buildWhereClause(&argIndex)

		parts = append(parts, "WHERE", whereClause)

		args = append(args, whereArgs...)

	}

	return strings.Join(parts, " "), args

}

// buildUpdatesQuery builds the UPDATE query with multiple columns

func (q *Query) buildUpdatesQuery(values map[string]interface{}) (string, []interface{}) {

	var parts []string

	var args []interface{}

	argIndex := 1

	var setParts []string

	for col, val := range values {

		setParts = append(setParts, fmt.Sprintf("%s = %s",

			q.dialect.QuoteIdentifier(col),

			q.dialect.GetPlaceholder(argIndex)))

		args = append(args, val)

		argIndex++

	}

	parts = append(parts, fmt.Sprintf("UPDATE %s SET %s",

		q.dialect.QuoteIdentifier(q.table),

		strings.Join(setParts, ", ")))

	// WHERE

	if len(q.whereConditions) > 0 {

		whereClause, whereArgs := q.buildWhereClause(&argIndex)

		parts = append(parts, "WHERE", whereClause)

		args = append(args, whereArgs...)

	}

	return strings.Join(parts, " "), args

}

// buildDeleteQuery builds the DELETE query

func (q *Query) buildDeleteQuery() (string, []interface{}) {

	var parts []string

	var args []interface{}

	argIndex := 1

	parts = append(parts, fmt.Sprintf("DELETE FROM %s", q.dialect.QuoteIdentifier(q.table)))

	// WHERE

	if len(q.whereConditions) > 0 {

		whereClause, whereArgs := q.buildWhereClause(&argIndex)

		parts = append(parts, "WHERE", whereClause)

		args = append(args, whereArgs...)

	}

	return strings.Join(parts, " "), args

}