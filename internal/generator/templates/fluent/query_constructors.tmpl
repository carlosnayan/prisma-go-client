// NewQuery creates a new query builder with fluent API
func NewQuery(db DBTX, table string, columns []string) *Query {
	return &Query{
		db:              db,
		table:           table,
		columns:         columns,
		dialect:         GetDialect("{{.Provider}}"),
		logger:          GetDefaultLogger(),
		whereConditions: []whereCondition{},
		orderBy:         []OrderBy{},
		joins:           []join{},
		selectFields:    []string{},
		groupBy:         []string{},
		having:          []whereCondition{},
	}
}

// SetDialect sets the database dialect
func (q *Query) SetDialect(d Dialect) *Query {
	q.dialect = d
	return q
}

// SetDialectFromProvider sets the dialect from provider name
func (q *Query) SetDialectFromProvider(provider string) *Query {
	q.dialect = GetDialect(provider)
	return q
}

// SetPrimaryKey sets the primary key
func (q *Query) SetPrimaryKey(pk string) *Query {
	q.primaryKey = pk
	return q
}

// SetModelType sets the model type for automatic scanning
func (q *Query) SetModelType(modelType reflect.Type) *Query {
	q.modelType = modelType
	return q
}

// GetDB returns the database connection
func (q *Query) GetDB() DBTX {
	return q.db
}

// GetDialect returns the database dialect
func (q *Query) GetDialect() Dialect {
	return q.dialect
}

// GetTable returns the table name
func (q *Query) GetTable() string {
	return q.table
}

// GetColumns returns the column names
func (q *Query) GetColumns() []string {
	return q.columns
}

// GetPrimaryKey returns the primary key column name
func (q *Query) GetPrimaryKey() string {
	return q.primaryKey
}

// getLogger returns the logger, always getting the current default logger
// This ensures that if the logger is configured after Query creation, it will use the updated logger
func (q *Query) getLogger() *Logger {
	// Always get the current default logger to ensure it's up to date
	currentLogger := GetDefaultLogger()
	// Update q.logger if it's different (for efficiency, but always use current)
	if currentLogger != q.logger {
		q.logger = currentLogger
	}
	return q.logger
}

// Reset clears all mutable state from the Query (whereConditions, orderBy, take, skip, etc.)
// This should be called at the beginning of each operation to prevent state accumulation
// between operations, especially in transactions where the same Query instance is reused.
func (q *Query) Reset() *Query {
	q.whereConditions = []whereCondition{}
	q.orderBy = []OrderBy{}
	q.take = nil
	q.skip = nil
	q.selectFields = []string{}
	q.groupBy = []string{}
	q.having = []whereCondition{}
	q.joins = []join{}
	return q
}

// WithContext sets the context for this query builder.
// The context will be used automatically when Exec() is called without parameters.
// If a context is passed explicitly to Exec(ctx), it takes priority over the stored context.
// Example:
//   query := client.User.WithContext(ctx)
//   user, err := query.Create().Data(...).Exec() // Uses stored context
func (q *Query) WithContext(ctx context.Context) *Query {
	q.ctx = ctx
	return q
}

// GetContext returns the context to use for operations.
// Priority: explicit context > stored context > context.Background()
func (q *Query) GetContext(ctx ...context.Context) context.Context {
	if len(ctx) > 0 && ctx[0] != nil {
		return ctx[0]
	}
	if q.ctx != nil {
		return q.ctx
	}
	return context.Background()
}

