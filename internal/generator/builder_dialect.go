package generator

import (
	"fmt"
	"os"
	"path/filepath"
)

// generateBuilderDialect generates dialect.go with interface and implementations
func generateBuilderDialect(builderDir string) error {
	file, err := os.Create(filepath.Join(builderDir, "dialect.go"))
	if err != nil {
		return err
	}
	defer file.Close()

	// Header
	fmt.Fprintf(file, "// Code generated by prisma generate. DO NOT EDIT.\n")
	fmt.Fprintf(file, "package builder\n\n")
	fmt.Fprintf(file, "import (\n")
	fmt.Fprintf(file, "\t\"fmt\"\n")
	fmt.Fprintf(file, "\t\"strings\"\n")
	fmt.Fprintf(file, ")\n\n")

	// Dialect interface
	fmt.Fprintf(file, "// Dialect representa um dialeto de banco de dados\n")
	fmt.Fprintf(file, "// Abstrai as diferenças entre PostgreSQL, MySQL, SQLite, etc.\n")
	fmt.Fprintf(file, "type Dialect interface {\n")
	fmt.Fprintf(file, "\t// Name retorna o nome do dialeto (ex: \"postgresql\", \"mysql\", \"sqlite\")\n")
	fmt.Fprintf(file, "\tName() string\n\n")
	fmt.Fprintf(file, "\t// QuoteIdentifier cita um identificador (tabela, coluna, etc.)\n")
	fmt.Fprintf(file, "\t// PostgreSQL: \"table_name\", MySQL: `table_name`, SQLite: \"table_name\"\n")
	fmt.Fprintf(file, "\tQuoteIdentifier(name string) string\n\n")
	fmt.Fprintf(file, "\t// QuoteString cita uma string literal\n")
	fmt.Fprintf(file, "\t// PostgreSQL: 'value', MySQL: 'value', SQLite: 'value'\n")
	fmt.Fprintf(file, "\tQuoteString(value string) string\n\n")
	fmt.Fprintf(file, "\t// MapType mapeia um tipo Prisma para tipo SQL do banco\n")
	fmt.Fprintf(file, "\t// Exemplo: \"String\" -> \"VARCHAR(255)\" (MySQL) ou \"TEXT\" (PostgreSQL)\n")
	fmt.Fprintf(file, "\tMapType(prismaType string, isNullable bool) string\n\n")
	fmt.Fprintf(file, "\t// MapDefaultValue mapeia um valor default do Prisma para SQL\n")
	fmt.Fprintf(file, "\t// Exemplo: \"autoincrement()\" -> \"AUTO_INCREMENT\" (MySQL) ou \"SERIAL\" (PostgreSQL)\n")
	fmt.Fprintf(file, "\tMapDefaultValue(value string) string\n\n")
	fmt.Fprintf(file, "\t// GetPlaceholder retorna o placeholder para parâmetros\n")
	fmt.Fprintf(file, "\t// PostgreSQL: $1, $2, MySQL: ?, ?, SQLite: ?, ?\n")
	fmt.Fprintf(file, "\tGetPlaceholder(index int) string\n\n")
	fmt.Fprintf(file, "\t// GetAutoIncrementKeyword retorna a palavra-chave para auto incremento\n")
	fmt.Fprintf(file, "\t// PostgreSQL: SERIAL/BIGSERIAL, MySQL: AUTO_INCREMENT, SQLite: AUTOINCREMENT\n")
	fmt.Fprintf(file, "\tGetAutoIncrementKeyword() string\n\n")
	fmt.Fprintf(file, "\t// GetNowFunction retorna a função para obter data/hora atual\n")
	fmt.Fprintf(file, "\t// PostgreSQL: NOW(), MySQL: NOW(), SQLite: datetime('now')\n")
	fmt.Fprintf(file, "\tGetNowFunction() string\n\n")
	fmt.Fprintf(file, "\t// GetDriverName retorna o nome do driver Go para database/sql\n")
	fmt.Fprintf(file, "\t// PostgreSQL: \"pgx\", MySQL: \"mysql\", SQLite: \"sqlite3\"\n")
	fmt.Fprintf(file, "\tGetDriverName() string\n\n")
	fmt.Fprintf(file, "\t// SupportsFullTextSearch indica se o banco suporta busca full-text\n")
	fmt.Fprintf(file, "\tSupportsFullTextSearch() bool\n\n")
	fmt.Fprintf(file, "\t// GetFullTextSearchQuery retorna a query de busca full-text\n")
	fmt.Fprintf(file, "\t// PostgreSQL: field @@ to_tsquery('query')\n")
	fmt.Fprintf(file, "\t// MySQL: MATCH(field) AGAINST('query' IN BOOLEAN MODE)\n")
	fmt.Fprintf(file, "\tGetFullTextSearchQuery(field string, query string) string\n\n")
	fmt.Fprintf(file, "\t// SupportsJSON indica se o banco suporta campos JSON\n")
	fmt.Fprintf(file, "\tSupportsJSON() bool\n\n")
	fmt.Fprintf(file, "\t// GetJSONContainsQuery retorna query para verificar se JSON contém valor\n")
	fmt.Fprintf(file, "\t// PostgreSQL: field @> 'value'::jsonb\n")
	fmt.Fprintf(file, "\t// MySQL: JSON_CONTAINS(field, 'value')\n")
	fmt.Fprintf(file, "\tGetJSONContainsQuery(field string, value string) string\n\n")
	fmt.Fprintf(file, "\t// GetLimitOffsetSyntax retorna a sintaxe LIMIT/OFFSET\n")
	fmt.Fprintf(file, "\t// PostgreSQL: LIMIT n OFFSET m, MySQL: LIMIT m, n (ou LIMIT n OFFSET m)\n")
	fmt.Fprintf(file, "\tGetLimitOffsetSyntax(limit, offset int) string\n")
	fmt.Fprintf(file, "}\n\n")

	// GetDialect function
	fmt.Fprintf(file, "// GetDialect retorna o dialeto apropriado para o provider\n")
	fmt.Fprintf(file, "func GetDialect(provider string) Dialect {\n")
	fmt.Fprintf(file, "\tprovider = strings.ToLower(provider)\n\n")
	fmt.Fprintf(file, "\tswitch provider {\n")
	fmt.Fprintf(file, "\tcase \"postgresql\", \"postgres\":\n")
	fmt.Fprintf(file, "\t\treturn &PostgreSQLDialect{}\n")
	fmt.Fprintf(file, "\tcase \"mysql\", \"mariadb\":\n")
	fmt.Fprintf(file, "\t\treturn &MySQLDialect{}\n")
	fmt.Fprintf(file, "\tcase \"sqlite\":\n")
	fmt.Fprintf(file, "\t\treturn &SQLiteDialect{}\n")
	fmt.Fprintf(file, "\tdefault:\n")
	fmt.Fprintf(file, "\t\t// Default para PostgreSQL\n")
	fmt.Fprintf(file, "\t\treturn &PostgreSQLDialect{}\n")
	fmt.Fprintf(file, "\t}\n")
	fmt.Fprintf(file, "}\n\n")

	// PostgreSQLDialect implementation
	generatePostgreSQLDialect(file)

	// MySQLDialect implementation
	generateMySQLDialect(file)

	// SQLiteDialect implementation
	generateSQLiteDialect(file)

	return nil
}

func generatePostgreSQLDialect(file *os.File) {
	fmt.Fprintf(file, "// PostgreSQLDialect implements the PostgreSQL dialect\n")
	fmt.Fprintf(file, "type PostgreSQLDialect struct{}\n\n")
	fmt.Fprintf(file, "func (d *PostgreSQLDialect) Name() string { return \"postgresql\" }\n\n")
	fmt.Fprintf(file, "func (d *PostgreSQLDialect) QuoteIdentifier(name string) string {\n")
	fmt.Fprintf(file, "\treturn fmt.Sprintf(`\"%%s\"`, name)\n")
	fmt.Fprintf(file, "}\n\n")
	fmt.Fprintf(file, "func (d *PostgreSQLDialect) QuoteString(value string) string {\n")
	fmt.Fprintf(file, "\tescaped := strings.ReplaceAll(value, \"'\", \"''\")\n")
	fmt.Fprintf(file, "\treturn fmt.Sprintf(\"'%%s'\", escaped)\n")
	fmt.Fprintf(file, "}\n\n")
	fmt.Fprintf(file, "func (d *PostgreSQLDialect) MapType(prismaType string, isNullable bool) string {\n")
	fmt.Fprintf(file, "\tswitch strings.ToLower(prismaType) {\n")
	fmt.Fprintf(file, "\tcase \"string\":\n")
	fmt.Fprintf(file, "\t\treturn \"TEXT\"\n")
	fmt.Fprintf(file, "\tcase \"int\":\n")
	fmt.Fprintf(file, "\t\treturn \"INTEGER\"\n")
	fmt.Fprintf(file, "\tcase \"bigint\":\n")
	fmt.Fprintf(file, "\t\treturn \"BIGINT\"\n")
	fmt.Fprintf(file, "\tcase \"boolean\", \"bool\":\n")
	fmt.Fprintf(file, "\t\treturn \"BOOLEAN\"\n")
	fmt.Fprintf(file, "\tcase \"datetime\":\n")
	fmt.Fprintf(file, "\t\treturn \"TIMESTAMP\"\n")
	fmt.Fprintf(file, "\tcase \"float\":\n")
	fmt.Fprintf(file, "\t\treturn \"DOUBLE PRECISION\"\n")
	fmt.Fprintf(file, "\tcase \"decimal\":\n")
	fmt.Fprintf(file, "\t\treturn \"DECIMAL(65, 30)\"\n")
	fmt.Fprintf(file, "\tcase \"json\":\n")
	fmt.Fprintf(file, "\t\treturn \"JSONB\"\n")
	fmt.Fprintf(file, "\tcase \"bytes\":\n")
	fmt.Fprintf(file, "\t\treturn \"BYTEA\"\n")
	fmt.Fprintf(file, "\tcase \"uuid\":\n")
	fmt.Fprintf(file, "\t\treturn \"UUID\"\n")
	fmt.Fprintf(file, "\tdefault:\n")
	fmt.Fprintf(file, "\t\tif strings.HasPrefix(strings.ToUpper(prismaType), \"VARCHAR\") {\n")
	fmt.Fprintf(file, "\t\t\treturn prismaType\n")
	fmt.Fprintf(file, "\t\t}\n")
	fmt.Fprintf(file, "\t\treturn \"TEXT\"\n")
	fmt.Fprintf(file, "\t}\n")
	fmt.Fprintf(file, "}\n\n")
	fmt.Fprintf(file, "func (d *PostgreSQLDialect) MapDefaultValue(value string) string {\n")
	fmt.Fprintf(file, "\tvalue = strings.ToLower(value)\n")
	fmt.Fprintf(file, "\tswitch {\n")
	fmt.Fprintf(file, "\tcase value == \"autoincrement()\" || value == \"autoincrement\":\n")
	fmt.Fprintf(file, "\t\treturn \"\"\n")
	fmt.Fprintf(file, "\tcase value == \"now()\" || value == \"now\":\n")
	fmt.Fprintf(file, "\t\treturn \"NOW()\"\n")
	fmt.Fprintf(file, "\tcase strings.HasPrefix(value, \"uuid()\") || strings.HasPrefix(value, \"uuid\"):\n")
	fmt.Fprintf(file, "\t\treturn \"gen_random_uuid()\"\n")
	fmt.Fprintf(file, "\tcase strings.HasPrefix(value, \"cuid()\") || strings.HasPrefix(value, \"cuid\"):\n")
	fmt.Fprintf(file, "\t\treturn \"gen_random_uuid()\"\n")
	fmt.Fprintf(file, "\tdefault:\n")
	fmt.Fprintf(file, "\t\treturn value\n")
	fmt.Fprintf(file, "\t}\n")
	fmt.Fprintf(file, "}\n\n")
	fmt.Fprintf(file, "func (d *PostgreSQLDialect) GetPlaceholder(index int) string {\n")
	fmt.Fprintf(file, "\treturn fmt.Sprintf(\"$%%d\", index)\n")
	fmt.Fprintf(file, "}\n\n")
	fmt.Fprintf(file, "func (d *PostgreSQLDialect) GetAutoIncrementKeyword() string { return \"SERIAL\" }\n\n")
	fmt.Fprintf(file, "func (d *PostgreSQLDialect) GetNowFunction() string { return \"NOW()\" }\n\n")
	fmt.Fprintf(file, "func (d *PostgreSQLDialect) GetDriverName() string { return \"pgx\" }\n\n")
	fmt.Fprintf(file, "func (d *PostgreSQLDialect) SupportsFullTextSearch() bool { return true }\n\n")
	fmt.Fprintf(file, "func (d *PostgreSQLDialect) GetFullTextSearchQuery(field string, query string) string {\n")
	fmt.Fprintf(file, "\treturn fmt.Sprintf(\"%%s @@ to_tsquery(%%s)\", d.QuoteIdentifier(field), d.QuoteString(query))\n")
	fmt.Fprintf(file, "}\n\n")
	fmt.Fprintf(file, "func (d *PostgreSQLDialect) SupportsJSON() bool { return true }\n\n")
	fmt.Fprintf(file, "func (d *PostgreSQLDialect) GetJSONContainsQuery(field string, value string) string {\n")
	fmt.Fprintf(file, "\treturn fmt.Sprintf(\"%%s @> %%s::jsonb\", d.QuoteIdentifier(field), d.QuoteString(value))\n")
	fmt.Fprintf(file, "}\n\n")
	fmt.Fprintf(file, "func (d *PostgreSQLDialect) GetLimitOffsetSyntax(limit, offset int) string {\n")
	fmt.Fprintf(file, "\tif limit > 0 && offset > 0 {\n")
	fmt.Fprintf(file, "\t\treturn fmt.Sprintf(\"LIMIT %%d OFFSET %%d\", limit, offset)\n")
	fmt.Fprintf(file, "\t} else if limit > 0 {\n")
	fmt.Fprintf(file, "\t\treturn fmt.Sprintf(\"LIMIT %%d\", limit)\n")
	fmt.Fprintf(file, "\t} else if offset > 0 {\n")
	fmt.Fprintf(file, "\t\treturn fmt.Sprintf(\"OFFSET %%d\", offset)\n")
	fmt.Fprintf(file, "\t}\n")
	fmt.Fprintf(file, "\treturn \"\"\n")
	fmt.Fprintf(file, "}\n\n")
}

func generateMySQLDialect(file *os.File) {
	fmt.Fprintf(file, "// MySQLDialect implements the MySQL dialect\n")
	fmt.Fprintf(file, "type MySQLDialect struct{}\n\n")
	fmt.Fprintf(file, "func (d *MySQLDialect) Name() string { return \"mysql\" }\n\n")
	fmt.Fprintf(file, "func (d *MySQLDialect) QuoteIdentifier(name string) string {\n")
	fmt.Fprintf(file, "\treturn fmt.Sprintf(\"`%%s`\", name)\n")
	fmt.Fprintf(file, "}\n\n")
	fmt.Fprintf(file, "func (d *MySQLDialect) QuoteString(value string) string {\n")
	fmt.Fprintf(file, "\tescaped := strings.ReplaceAll(value, \"\\\\\", \"\\\\\\\\\")\n")
	fmt.Fprintf(file, "\tescaped = strings.ReplaceAll(escaped, \"'\", \"''\")\n")
	fmt.Fprintf(file, "\treturn fmt.Sprintf(\"'%%s'\", escaped)\n")
	fmt.Fprintf(file, "}\n\n")
	fmt.Fprintf(file, "func (d *MySQLDialect) MapType(prismaType string, isNullable bool) string {\n")
	fmt.Fprintf(file, "\tswitch strings.ToLower(prismaType) {\n")
	fmt.Fprintf(file, "\tcase \"string\":\n")
	fmt.Fprintf(file, "\t\treturn \"VARCHAR(191)\"\n")
	fmt.Fprintf(file, "\tcase \"int\":\n")
	fmt.Fprintf(file, "\t\treturn \"INT\"\n")
	fmt.Fprintf(file, "\tcase \"bigint\":\n")
	fmt.Fprintf(file, "\t\treturn \"BIGINT\"\n")
	fmt.Fprintf(file, "\tcase \"boolean\", \"bool\":\n")
	fmt.Fprintf(file, "\t\treturn \"TINYINT(1)\"\n")
	fmt.Fprintf(file, "\tcase \"datetime\":\n")
	fmt.Fprintf(file, "\t\treturn \"DATETIME\"\n")
	fmt.Fprintf(file, "\tcase \"float\":\n")
	fmt.Fprintf(file, "\t\treturn \"DOUBLE\"\n")
	fmt.Fprintf(file, "\tcase \"decimal\":\n")
	fmt.Fprintf(file, "\t\treturn \"DECIMAL(65, 30)\"\n")
	fmt.Fprintf(file, "\tcase \"json\":\n")
	fmt.Fprintf(file, "\t\treturn \"JSON\"\n")
	fmt.Fprintf(file, "\tcase \"bytes\":\n")
	fmt.Fprintf(file, "\t\treturn \"BLOB\"\n")
	fmt.Fprintf(file, "\tdefault:\n")
	fmt.Fprintf(file, "\t\treturn \"VARCHAR(191)\"\n")
	fmt.Fprintf(file, "\t}\n")
	fmt.Fprintf(file, "}\n\n")
	fmt.Fprintf(file, "func (d *MySQLDialect) MapDefaultValue(value string) string {\n")
	fmt.Fprintf(file, "\tvalue = strings.ToLower(value)\n")
	fmt.Fprintf(file, "\tswitch {\n")
	fmt.Fprintf(file, "\tcase value == \"autoincrement()\" || value == \"autoincrement\":\n")
	fmt.Fprintf(file, "\t\treturn \"\"\n")
	fmt.Fprintf(file, "\tcase value == \"now()\" || value == \"now\":\n")
	fmt.Fprintf(file, "\t\treturn \"CURRENT_TIMESTAMP\"\n")
	fmt.Fprintf(file, "\tcase strings.HasPrefix(value, \"uuid()\") || strings.HasPrefix(value, \"uuid\"):\n")
	fmt.Fprintf(file, "\t\treturn \"UUID()\"\n")
	fmt.Fprintf(file, "\tcase strings.HasPrefix(value, \"cuid()\") || strings.HasPrefix(value, \"cuid\"):\n")
	fmt.Fprintf(file, "\t\treturn \"UUID()\"\n")
	fmt.Fprintf(file, "\tdefault:\n")
	fmt.Fprintf(file, "\t\treturn value\n")
	fmt.Fprintf(file, "\t}\n")
	fmt.Fprintf(file, "}\n\n")
	fmt.Fprintf(file, "func (d *MySQLDialect) GetPlaceholder(index int) string { return \"?\" }\n\n")
	fmt.Fprintf(file, "func (d *MySQLDialect) GetAutoIncrementKeyword() string { return \"AUTO_INCREMENT\" }\n\n")
	fmt.Fprintf(file, "func (d *MySQLDialect) GetNowFunction() string { return \"NOW()\" }\n\n")
	fmt.Fprintf(file, "func (d *MySQLDialect) GetDriverName() string { return \"mysql\" }\n\n")
	fmt.Fprintf(file, "func (d *MySQLDialect) SupportsFullTextSearch() bool { return true }\n\n")
	fmt.Fprintf(file, "func (d *MySQLDialect) GetFullTextSearchQuery(field string, query string) string {\n")
	fmt.Fprintf(file, "\treturn fmt.Sprintf(\"MATCH(%%s) AGAINST(%%s IN BOOLEAN MODE)\", d.QuoteIdentifier(field), d.QuoteString(query))\n")
	fmt.Fprintf(file, "}\n\n")
	fmt.Fprintf(file, "func (d *MySQLDialect) SupportsJSON() bool { return true }\n\n")
	fmt.Fprintf(file, "func (d *MySQLDialect) GetJSONContainsQuery(field string, value string) string {\n")
	fmt.Fprintf(file, "\treturn fmt.Sprintf(\"JSON_CONTAINS(%%s, %%s)\", d.QuoteIdentifier(field), d.QuoteString(value))\n")
	fmt.Fprintf(file, "}\n\n")
	fmt.Fprintf(file, "func (d *MySQLDialect) GetLimitOffsetSyntax(limit, offset int) string {\n")
	fmt.Fprintf(file, "\tif limit > 0 && offset > 0 {\n")
	fmt.Fprintf(file, "\t\treturn fmt.Sprintf(\"LIMIT %%d, %%d\", offset, limit)\n")
	fmt.Fprintf(file, "\t} else if limit > 0 {\n")
	fmt.Fprintf(file, "\t\treturn fmt.Sprintf(\"LIMIT %%d\", limit)\n")
	fmt.Fprintf(file, "\t} else if offset > 0 {\n")
	fmt.Fprintf(file, "\t\treturn fmt.Sprintf(\"LIMIT 18446744073709551615 OFFSET %%d\", offset)\n")
	fmt.Fprintf(file, "\t}\n")
	fmt.Fprintf(file, "\treturn \"\"\n")
	fmt.Fprintf(file, "}\n\n")
}

func generateSQLiteDialect(file *os.File) {
	fmt.Fprintf(file, "// SQLiteDialect implements the SQLite dialect\n")
	fmt.Fprintf(file, "type SQLiteDialect struct{}\n\n")
	fmt.Fprintf(file, "func (d *SQLiteDialect) Name() string { return \"sqlite\" }\n\n")
	fmt.Fprintf(file, "func (d *SQLiteDialect) QuoteIdentifier(name string) string {\n")
	fmt.Fprintf(file, "\treturn fmt.Sprintf(`\"%%s\"`, name)\n")
	fmt.Fprintf(file, "}\n\n")
	fmt.Fprintf(file, "func (d *SQLiteDialect) QuoteString(value string) string {\n")
	fmt.Fprintf(file, "\tescaped := strings.ReplaceAll(value, \"'\", \"''\")\n")
	fmt.Fprintf(file, "\treturn fmt.Sprintf(\"'%%s'\", escaped)\n")
	fmt.Fprintf(file, "}\n\n")
	fmt.Fprintf(file, "func (d *SQLiteDialect) MapType(prismaType string, isNullable bool) string {\n")
	fmt.Fprintf(file, "\tswitch strings.ToLower(prismaType) {\n")
	fmt.Fprintf(file, "\tcase \"string\":\n")
	fmt.Fprintf(file, "\t\treturn \"TEXT\"\n")
	fmt.Fprintf(file, "\tcase \"int\":\n")
	fmt.Fprintf(file, "\t\treturn \"INTEGER\"\n")
	fmt.Fprintf(file, "\tcase \"bigint\":\n")
	fmt.Fprintf(file, "\t\treturn \"INTEGER\"\n")
	fmt.Fprintf(file, "\tcase \"boolean\", \"bool\":\n")
	fmt.Fprintf(file, "\t\treturn \"INTEGER\"\n")
	fmt.Fprintf(file, "\tcase \"datetime\":\n")
	fmt.Fprintf(file, "\t\treturn \"TEXT\"\n")
	fmt.Fprintf(file, "\tcase \"float\":\n")
	fmt.Fprintf(file, "\t\treturn \"REAL\"\n")
	fmt.Fprintf(file, "\tcase \"decimal\":\n")
	fmt.Fprintf(file, "\t\treturn \"NUMERIC\"\n")
	fmt.Fprintf(file, "\tcase \"json\":\n")
	fmt.Fprintf(file, "\t\treturn \"TEXT\"\n")
	fmt.Fprintf(file, "\tcase \"bytes\":\n")
	fmt.Fprintf(file, "\t\treturn \"BLOB\"\n")
	fmt.Fprintf(file, "\tdefault:\n")
	fmt.Fprintf(file, "\t\treturn \"TEXT\"\n")
	fmt.Fprintf(file, "\t}\n")
	fmt.Fprintf(file, "}\n\n")
	fmt.Fprintf(file, "func (d *SQLiteDialect) MapDefaultValue(value string) string {\n")
	fmt.Fprintf(file, "\tvalue = strings.ToLower(value)\n")
	fmt.Fprintf(file, "\tswitch {\n")
	fmt.Fprintf(file, "\tcase value == \"autoincrement()\" || value == \"autoincrement\":\n")
	fmt.Fprintf(file, "\t\treturn \"\"\n")
	fmt.Fprintf(file, "\tcase value == \"now()\" || value == \"now\":\n")
	fmt.Fprintf(file, "\t\treturn \"datetime('now')\"\n")
	fmt.Fprintf(file, "\tcase strings.HasPrefix(value, \"uuid()\") || strings.HasPrefix(value, \"uuid\"):\n")
	fmt.Fprintf(file, "\t\treturn \"(lower(hex(randomblob(4))) || '-' || lower(hex(randomblob(2))) || '-4' || substr(lower(hex(randomblob(2))),2) || '-' || substr('89ab',abs(random()) %% 4 + 1, 1) || substr(lower(hex(randomblob(2))),2) || '-' || lower(hex(randomblob(6))))\"\n")
	fmt.Fprintf(file, "\tcase strings.HasPrefix(value, \"cuid()\") || strings.HasPrefix(value, \"cuid\"):\n")
	fmt.Fprintf(file, "\t\treturn \"(lower(hex(randomblob(4))) || '-' || lower(hex(randomblob(2))) || '-4' || substr(lower(hex(randomblob(2))),2) || '-' || substr('89ab',abs(random()) %% 4 + 1, 1) || substr(lower(hex(randomblob(2))),2) || '-' || lower(hex(randomblob(6))))\"\n")
	fmt.Fprintf(file, "\tdefault:\n")
	fmt.Fprintf(file, "\t\treturn value\n")
	fmt.Fprintf(file, "\t}\n")
	fmt.Fprintf(file, "}\n\n")
	fmt.Fprintf(file, "func (d *SQLiteDialect) GetPlaceholder(index int) string { return \"?\" }\n\n")
	fmt.Fprintf(file, "func (d *SQLiteDialect) GetAutoIncrementKeyword() string { return \"AUTOINCREMENT\" }\n\n")
	fmt.Fprintf(file, "func (d *SQLiteDialect) GetNowFunction() string { return \"datetime('now')\" }\n\n")
	fmt.Fprintf(file, "func (d *SQLiteDialect) GetDriverName() string { return \"sqlite3\" }\n\n")
	fmt.Fprintf(file, "func (d *SQLiteDialect) SupportsFullTextSearch() bool { return false }\n\n")
	fmt.Fprintf(file, "func (d *SQLiteDialect) GetFullTextSearchQuery(field string, query string) string {\n")
	fmt.Fprintf(file, "\treturn fmt.Sprintf(\"%%s LIKE %%s\", d.QuoteIdentifier(field), d.QuoteString(\"%%\"+query+\"%%\"))\n")
	fmt.Fprintf(file, "}\n\n")
	fmt.Fprintf(file, "func (d *SQLiteDialect) SupportsJSON() bool { return true }\n\n")
	fmt.Fprintf(file, "func (d *SQLiteDialect) GetJSONContainsQuery(field string, value string) string {\n")
	fmt.Fprintf(file, "\treturn fmt.Sprintf(\"json_extract(%%s, '$') = %%s\", d.QuoteIdentifier(field), d.QuoteString(value))\n")
	fmt.Fprintf(file, "}\n\n")
	fmt.Fprintf(file, "func (d *SQLiteDialect) GetLimitOffsetSyntax(limit, offset int) string {\n")
	fmt.Fprintf(file, "\tif limit > 0 && offset > 0 {\n")
	fmt.Fprintf(file, "\t\treturn fmt.Sprintf(\"LIMIT %%d OFFSET %%d\", limit, offset)\n")
	fmt.Fprintf(file, "\t} else if limit > 0 {\n")
	fmt.Fprintf(file, "\t\treturn fmt.Sprintf(\"LIMIT %%d\", limit)\n")
	fmt.Fprintf(file, "\t} else if offset > 0 {\n")
	fmt.Fprintf(file, "\t\treturn fmt.Sprintf(\"OFFSET %%d\", offset)\n")
	fmt.Fprintf(file, "\t}\n")
	fmt.Fprintf(file, "\treturn \"\"\n")
	fmt.Fprintf(file, "}\n")
}
