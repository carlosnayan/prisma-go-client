package generator

import (
	"fmt"
	"os"
	"path/filepath"
)

// generateBuilderDialect generates dialect.go with interface and implementations
func generateBuilderDialect(builderDir string) error {
	file, err := createGeneratedFile(filepath.Join(builderDir, "dialect.go"), "builder")
	if err != nil {
		return err
	}
	defer file.Close()
	fmt.Fprintf(file, "import (\n")
	fmt.Fprintf(file, "\t\"fmt\"\n")
	fmt.Fprintf(file, "\t\"strings\"\n")
	fmt.Fprintf(file, ")\n\n")

	// Dialect interface
	fmt.Fprintf(file, "// Dialect represents a database dialect\n")
	fmt.Fprintf(file, "// Abstracts differences between PostgreSQL, MySQL, SQLite, etc.\n")
	fmt.Fprintf(file, "type Dialect interface {\n")
	fmt.Fprintf(file, "\t// Name returns the dialect name (e.g., \"postgresql\", \"mysql\", \"sqlite\")\n")
	fmt.Fprintf(file, "\tName() string\n\n")
	fmt.Fprintf(file, "\t// QuoteIdentifier quotes an identifier (table, column, etc.)\n")
	fmt.Fprintf(file, "\t// PostgreSQL: \"table_name\", MySQL: `table_name`, SQLite: \"table_name\"\n")
	fmt.Fprintf(file, "\tQuoteIdentifier(name string) string\n\n")
	fmt.Fprintf(file, "\t// QuoteString quotes a string literal\n")
	fmt.Fprintf(file, "\t// PostgreSQL: 'value', MySQL: 'value', SQLite: 'value'\n")
	fmt.Fprintf(file, "\tQuoteString(value string) string\n\n")
	fmt.Fprintf(file, "\t// MapType maps a Prisma type to SQL database type\n")
	fmt.Fprintf(file, "\t// Example: \"String\" -> \"VARCHAR(255)\" (MySQL) or \"TEXT\" (PostgreSQL)\n")
	fmt.Fprintf(file, "\tMapType(prismaType string, isNullable bool) string\n\n")
	fmt.Fprintf(file, "\t// MapDefaultValue maps a Prisma default value to SQL\n")
	fmt.Fprintf(file, "\t// Example: \"autoincrement()\" -> \"AUTO_INCREMENT\" (MySQL) or \"SERIAL\" (PostgreSQL)\n")
	fmt.Fprintf(file, "\tMapDefaultValue(value string) string\n\n")
	fmt.Fprintf(file, "\t// GetPlaceholder returns the placeholder for parameters\n")
	fmt.Fprintf(file, "\t// PostgreSQL: $1, $2, MySQL: ?, ?, SQLite: ?, ?\n")
	fmt.Fprintf(file, "\tGetPlaceholder(index int) string\n\n")
	fmt.Fprintf(file, "\t// GetAutoIncrementKeyword returns the keyword for auto increment\n")
	fmt.Fprintf(file, "\t// PostgreSQL: SERIAL/BIGSERIAL, MySQL: AUTO_INCREMENT, SQLite: AUTOINCREMENT\n")
	fmt.Fprintf(file, "\tGetAutoIncrementKeyword() string\n\n")
	fmt.Fprintf(file, "\t// GetNowFunction returns the function to get current date/time\n")
	fmt.Fprintf(file, "\t// PostgreSQL: NOW(), MySQL: NOW(), SQLite: datetime('now')\n")
	fmt.Fprintf(file, "\tGetNowFunction() string\n\n")
	fmt.Fprintf(file, "\t// GetDriverName returns the Go driver name for database/sql\n")
	fmt.Fprintf(file, "\t// PostgreSQL: \"pgx\", MySQL: \"mysql\", SQLite: \"sqlite3\"\n")
	fmt.Fprintf(file, "\tGetDriverName() string\n\n")
	fmt.Fprintf(file, "\t// SupportsFullTextSearch indicates if the database supports full-text search\n")
	fmt.Fprintf(file, "\tSupportsFullTextSearch() bool\n\n")
	fmt.Fprintf(file, "\t// GetFullTextSearchQuery returns the full-text search query\n")
	fmt.Fprintf(file, "\t// PostgreSQL: field @@ to_tsquery('query')\n")
	fmt.Fprintf(file, "\t// MySQL: MATCH(field) AGAINST('query' IN BOOLEAN MODE)\n")
	fmt.Fprintf(file, "\tGetFullTextSearchQuery(field string, query string) string\n\n")
	fmt.Fprintf(file, "\t// SupportsJSON indicates if the database supports JSON fields\n")
	fmt.Fprintf(file, "\tSupportsJSON() bool\n\n")
	fmt.Fprintf(file, "\t// GetJSONContainsQuery returns query to check if JSON contains value\n")
	fmt.Fprintf(file, "\t// PostgreSQL: field @> 'value'::jsonb\n")
	fmt.Fprintf(file, "\t// MySQL: JSON_CONTAINS(field, 'value')\n")
	fmt.Fprintf(file, "\tGetJSONContainsQuery(field string, value string) string\n\n")
	fmt.Fprintf(file, "\t// GetLimitOffsetSyntax returns the LIMIT/OFFSET syntax\n")
	fmt.Fprintf(file, "\t// PostgreSQL: LIMIT n OFFSET m, MySQL: LIMIT m, n (or LIMIT n OFFSET m)\n")
	fmt.Fprintf(file, "\tGetLimitOffsetSyntax(limit, offset int) string\n")
	fmt.Fprintf(file, "}\n\n")

	// GetDialect function
	fmt.Fprintf(file, "// GetDialect returns the appropriate dialect for the provider\n")
	fmt.Fprintf(file, "func GetDialect(provider string) Dialect {\n")
	fmt.Fprintf(file, "\tprovider = strings.ToLower(provider)\n\n")
	fmt.Fprintf(file, "\tswitch provider {\n")
	fmt.Fprintf(file, "\tcase \"postgresql\", \"postgres\":\n")
	fmt.Fprintf(file, "\t\treturn &PostgreSQLDialect{}\n")
	fmt.Fprintf(file, "\tcase \"mysql\", \"mariadb\":\n")
	fmt.Fprintf(file, "\t\treturn &MySQLDialect{}\n")
	fmt.Fprintf(file, "\tcase \"sqlite\":\n")
	fmt.Fprintf(file, "\t\treturn &SQLiteDialect{}\n")
	fmt.Fprintf(file, "\tdefault:\n")
	fmt.Fprintf(file, "\t\t// Default to PostgreSQL\n")
	fmt.Fprintf(file, "\t\treturn &PostgreSQLDialect{}\n")
	fmt.Fprintf(file, "\t}\n")
	fmt.Fprintf(file, "}\n\n")

	// PostgreSQLDialect implementation
	generatePostgreSQLDialect(file)

	// MySQLDialect implementation
	generateMySQLDialect(file)

	// SQLiteDialect implementation
	generateSQLiteDialect(file)

	return nil
}

func generatePostgreSQLDialect(file *os.File) {
	fmt.Fprintf(file, "// PostgreSQLDialect implements the PostgreSQL dialect\n")
	fmt.Fprintf(file, "type PostgreSQLDialect struct{}\n\n")
	fmt.Fprintf(file, "func (d *PostgreSQLDialect) Name() string { return \"postgresql\" }\n\n")
	fmt.Fprintf(file, "func (d *PostgreSQLDialect) QuoteIdentifier(name string) string {\n")
	fmt.Fprintf(file, "\treturn fmt.Sprintf(`\"%%s\"`, name)\n")
	fmt.Fprintf(file, "}\n\n")
	fmt.Fprintf(file, "func (d *PostgreSQLDialect) QuoteString(value string) string {\n")
	fmt.Fprintf(file, "\tescaped := strings.ReplaceAll(value, \"'\", \"''\")\n")
	fmt.Fprintf(file, "\treturn fmt.Sprintf(\"'%%s'\", escaped)\n")
	fmt.Fprintf(file, "}\n\n")
	fmt.Fprintf(file, "func (d *PostgreSQLDialect) MapType(prismaType string, isNullable bool) string {\n")
	fmt.Fprintf(file, "\tswitch strings.ToLower(prismaType) {\n")
	fmt.Fprintf(file, "\tcase \"string\":\n")
	fmt.Fprintf(file, "\t\treturn \"TEXT\"\n")
	fmt.Fprintf(file, "\tcase \"int\":\n")
	fmt.Fprintf(file, "\t\treturn \"INTEGER\"\n")
	fmt.Fprintf(file, "\tcase \"bigint\":\n")
	fmt.Fprintf(file, "\t\treturn \"BIGINT\"\n")
	fmt.Fprintf(file, "\tcase \"boolean\", \"bool\":\n")
	fmt.Fprintf(file, "\t\treturn \"BOOLEAN\"\n")
	fmt.Fprintf(file, "\tcase \"datetime\":\n")
	fmt.Fprintf(file, "\t\treturn \"TIMESTAMP\"\n")
	fmt.Fprintf(file, "\tcase \"float\":\n")
	fmt.Fprintf(file, "\t\treturn \"DOUBLE PRECISION\"\n")
	fmt.Fprintf(file, "\tcase \"decimal\":\n")
	fmt.Fprintf(file, "\t\treturn \"DECIMAL(65, 30)\"\n")
	fmt.Fprintf(file, "\tcase \"json\":\n")
	fmt.Fprintf(file, "\t\treturn \"JSONB\"\n")
	fmt.Fprintf(file, "\tcase \"bytes\":\n")
	fmt.Fprintf(file, "\t\treturn \"BYTEA\"\n")
	fmt.Fprintf(file, "\tcase \"uuid\":\n")
	fmt.Fprintf(file, "\t\treturn \"UUID\"\n")
	fmt.Fprintf(file, "\tdefault:\n")
	fmt.Fprintf(file, "\t\tif strings.HasPrefix(strings.ToUpper(prismaType), \"VARCHAR\") {\n")
	fmt.Fprintf(file, "\t\t\treturn prismaType\n")
	fmt.Fprintf(file, "\t\t}\n")
	fmt.Fprintf(file, "\t\treturn \"TEXT\"\n")
	fmt.Fprintf(file, "\t}\n")
	fmt.Fprintf(file, "}\n\n")
	fmt.Fprintf(file, "func (d *PostgreSQLDialect) MapDefaultValue(value string) string {\n")
	fmt.Fprintf(file, "\tvalue = strings.ToLower(value)\n")
	fmt.Fprintf(file, "\tswitch {\n")
	fmt.Fprintf(file, "\tcase value == \"autoincrement()\" || value == \"autoincrement\":\n")
	fmt.Fprintf(file, "\t\treturn \"\"\n")
	fmt.Fprintf(file, "\tcase value == \"now()\" || value == \"now\":\n")
	fmt.Fprintf(file, "\t\treturn \"NOW()\"\n")
	fmt.Fprintf(file, "\tcase strings.HasPrefix(value, \"uuid()\") || strings.HasPrefix(value, \"uuid\"):\n")
	fmt.Fprintf(file, "\t\treturn \"gen_random_uuid()\"\n")
	fmt.Fprintf(file, "\tcase strings.HasPrefix(value, \"cuid()\") || strings.HasPrefix(value, \"cuid\"):\n")
	fmt.Fprintf(file, "\t\treturn \"gen_random_uuid()\"\n")
	fmt.Fprintf(file, "\tdefault:\n")
	fmt.Fprintf(file, "\t\treturn value\n")
	fmt.Fprintf(file, "\t}\n")
	fmt.Fprintf(file, "}\n\n")
	fmt.Fprintf(file, "func (d *PostgreSQLDialect) GetPlaceholder(index int) string {\n")
	fmt.Fprintf(file, "\treturn fmt.Sprintf(\"$%%d\", index)\n")
	fmt.Fprintf(file, "}\n\n")
	fmt.Fprintf(file, "func (d *PostgreSQLDialect) GetAutoIncrementKeyword() string { return \"SERIAL\" }\n\n")
	fmt.Fprintf(file, "func (d *PostgreSQLDialect) GetNowFunction() string { return \"NOW()\" }\n\n")
	fmt.Fprintf(file, "func (d *PostgreSQLDialect) GetDriverName() string { return \"pgx\" }\n\n")
	fmt.Fprintf(file, "func (d *PostgreSQLDialect) SupportsFullTextSearch() bool { return true }\n\n")
	fmt.Fprintf(file, "func (d *PostgreSQLDialect) GetFullTextSearchQuery(field string, query string) string {\n")
	fmt.Fprintf(file, "\treturn fmt.Sprintf(\"%%s @@ to_tsquery(%%s)\", d.QuoteIdentifier(field), d.QuoteString(query))\n")
	fmt.Fprintf(file, "}\n\n")
	fmt.Fprintf(file, "func (d *PostgreSQLDialect) SupportsJSON() bool { return true }\n\n")
	fmt.Fprintf(file, "func (d *PostgreSQLDialect) GetJSONContainsQuery(field string, value string) string {\n")
	fmt.Fprintf(file, "\treturn fmt.Sprintf(\"%%s @> %%s::jsonb\", d.QuoteIdentifier(field), d.QuoteString(value))\n")
	fmt.Fprintf(file, "}\n\n")
	fmt.Fprintf(file, "func (d *PostgreSQLDialect) GetLimitOffsetSyntax(limit, offset int) string {\n")
	fmt.Fprintf(file, "\tif limit > 0 && offset > 0 {\n")
	fmt.Fprintf(file, "\t\treturn fmt.Sprintf(\"LIMIT %%d OFFSET %%d\", limit, offset)\n")
	fmt.Fprintf(file, "\t} else if limit > 0 {\n")
	fmt.Fprintf(file, "\t\treturn fmt.Sprintf(\"LIMIT %%d\", limit)\n")
	fmt.Fprintf(file, "\t} else if offset > 0 {\n")
	fmt.Fprintf(file, "\t\treturn fmt.Sprintf(\"OFFSET %%d\", offset)\n")
	fmt.Fprintf(file, "\t}\n")
	fmt.Fprintf(file, "\treturn \"\"\n")
	fmt.Fprintf(file, "}\n\n")
}

func generateMySQLDialect(file *os.File) {
	fmt.Fprintf(file, "// MySQLDialect implements the MySQL dialect\n")
	fmt.Fprintf(file, "type MySQLDialect struct{}\n\n")
	fmt.Fprintf(file, "func (d *MySQLDialect) Name() string { return \"mysql\" }\n\n")
	fmt.Fprintf(file, "func (d *MySQLDialect) QuoteIdentifier(name string) string {\n")
	fmt.Fprintf(file, "\treturn fmt.Sprintf(\"`%%s`\", name)\n")
	fmt.Fprintf(file, "}\n\n")
	fmt.Fprintf(file, "func (d *MySQLDialect) QuoteString(value string) string {\n")
	fmt.Fprintf(file, "\tescaped := strings.ReplaceAll(value, \"\\\\\", \"\\\\\\\\\")\n")
	fmt.Fprintf(file, "\tescaped = strings.ReplaceAll(escaped, \"'\", \"''\")\n")
	fmt.Fprintf(file, "\treturn fmt.Sprintf(\"'%%s'\", escaped)\n")
	fmt.Fprintf(file, "}\n\n")
	fmt.Fprintf(file, "func (d *MySQLDialect) MapType(prismaType string, isNullable bool) string {\n")
	fmt.Fprintf(file, "\tswitch strings.ToLower(prismaType) {\n")
	fmt.Fprintf(file, "\tcase \"string\":\n")
	fmt.Fprintf(file, "\t\treturn \"VARCHAR(191)\"\n")
	fmt.Fprintf(file, "\tcase \"int\":\n")
	fmt.Fprintf(file, "\t\treturn \"INT\"\n")
	fmt.Fprintf(file, "\tcase \"bigint\":\n")
	fmt.Fprintf(file, "\t\treturn \"BIGINT\"\n")
	fmt.Fprintf(file, "\tcase \"boolean\", \"bool\":\n")
	fmt.Fprintf(file, "\t\treturn \"TINYINT(1)\"\n")
	fmt.Fprintf(file, "\tcase \"datetime\":\n")
	fmt.Fprintf(file, "\t\treturn \"DATETIME\"\n")
	fmt.Fprintf(file, "\tcase \"float\":\n")
	fmt.Fprintf(file, "\t\treturn \"DOUBLE\"\n")
	fmt.Fprintf(file, "\tcase \"decimal\":\n")
	fmt.Fprintf(file, "\t\treturn \"DECIMAL(65, 30)\"\n")
	fmt.Fprintf(file, "\tcase \"json\":\n")
	fmt.Fprintf(file, "\t\treturn \"JSON\"\n")
	fmt.Fprintf(file, "\tcase \"bytes\":\n")
	fmt.Fprintf(file, "\t\treturn \"BLOB\"\n")
	fmt.Fprintf(file, "\tdefault:\n")
	fmt.Fprintf(file, "\t\treturn \"VARCHAR(191)\"\n")
	fmt.Fprintf(file, "\t}\n")
	fmt.Fprintf(file, "}\n\n")
	fmt.Fprintf(file, "func (d *MySQLDialect) MapDefaultValue(value string) string {\n")
	fmt.Fprintf(file, "\tvalue = strings.ToLower(value)\n")
	fmt.Fprintf(file, "\tswitch {\n")
	fmt.Fprintf(file, "\tcase value == \"autoincrement()\" || value == \"autoincrement\":\n")
	fmt.Fprintf(file, "\t\treturn \"\"\n")
	fmt.Fprintf(file, "\tcase value == \"now()\" || value == \"now\":\n")
	fmt.Fprintf(file, "\t\treturn \"CURRENT_TIMESTAMP\"\n")
	fmt.Fprintf(file, "\tcase strings.HasPrefix(value, \"uuid()\") || strings.HasPrefix(value, \"uuid\"):\n")
	fmt.Fprintf(file, "\t\treturn \"UUID()\"\n")
	fmt.Fprintf(file, "\tcase strings.HasPrefix(value, \"cuid()\") || strings.HasPrefix(value, \"cuid\"):\n")
	fmt.Fprintf(file, "\t\treturn \"UUID()\"\n")
	fmt.Fprintf(file, "\tdefault:\n")
	fmt.Fprintf(file, "\t\treturn value\n")
	fmt.Fprintf(file, "\t}\n")
	fmt.Fprintf(file, "}\n\n")
	fmt.Fprintf(file, "func (d *MySQLDialect) GetPlaceholder(index int) string { return \"?\" }\n\n")
	fmt.Fprintf(file, "func (d *MySQLDialect) GetAutoIncrementKeyword() string { return \"AUTO_INCREMENT\" }\n\n")
	fmt.Fprintf(file, "func (d *MySQLDialect) GetNowFunction() string { return \"NOW()\" }\n\n")
	fmt.Fprintf(file, "func (d *MySQLDialect) GetDriverName() string { return \"mysql\" }\n\n")
	fmt.Fprintf(file, "func (d *MySQLDialect) SupportsFullTextSearch() bool { return true }\n\n")
	fmt.Fprintf(file, "func (d *MySQLDialect) GetFullTextSearchQuery(field string, query string) string {\n")
	fmt.Fprintf(file, "\treturn fmt.Sprintf(\"MATCH(%%s) AGAINST(%%s IN BOOLEAN MODE)\", d.QuoteIdentifier(field), d.QuoteString(query))\n")
	fmt.Fprintf(file, "}\n\n")
	fmt.Fprintf(file, "func (d *MySQLDialect) SupportsJSON() bool { return true }\n\n")
	fmt.Fprintf(file, "func (d *MySQLDialect) GetJSONContainsQuery(field string, value string) string {\n")
	fmt.Fprintf(file, "\treturn fmt.Sprintf(\"JSON_CONTAINS(%%s, %%s)\", d.QuoteIdentifier(field), d.QuoteString(value))\n")
	fmt.Fprintf(file, "}\n\n")
	fmt.Fprintf(file, "func (d *MySQLDialect) GetLimitOffsetSyntax(limit, offset int) string {\n")
	fmt.Fprintf(file, "\tif limit > 0 && offset > 0 {\n")
	fmt.Fprintf(file, "\t\treturn fmt.Sprintf(\"LIMIT %%d, %%d\", offset, limit)\n")
	fmt.Fprintf(file, "\t} else if limit > 0 {\n")
	fmt.Fprintf(file, "\t\treturn fmt.Sprintf(\"LIMIT %%d\", limit)\n")
	fmt.Fprintf(file, "\t} else if offset > 0 {\n")
	fmt.Fprintf(file, "\t\treturn fmt.Sprintf(\"LIMIT 18446744073709551615 OFFSET %%d\", offset)\n")
	fmt.Fprintf(file, "\t}\n")
	fmt.Fprintf(file, "\treturn \"\"\n")
	fmt.Fprintf(file, "}\n\n")
}

func generateSQLiteDialect(file *os.File) {
	fmt.Fprintf(file, "// SQLiteDialect implements the SQLite dialect\n")
	fmt.Fprintf(file, "type SQLiteDialect struct{}\n\n")
	fmt.Fprintf(file, "func (d *SQLiteDialect) Name() string { return \"sqlite\" }\n\n")
	fmt.Fprintf(file, "func (d *SQLiteDialect) QuoteIdentifier(name string) string {\n")
	fmt.Fprintf(file, "\treturn fmt.Sprintf(`\"%%s\"`, name)\n")
	fmt.Fprintf(file, "}\n\n")
	fmt.Fprintf(file, "func (d *SQLiteDialect) QuoteString(value string) string {\n")
	fmt.Fprintf(file, "\tescaped := strings.ReplaceAll(value, \"'\", \"''\")\n")
	fmt.Fprintf(file, "\treturn fmt.Sprintf(\"'%%s'\", escaped)\n")
	fmt.Fprintf(file, "}\n\n")
	fmt.Fprintf(file, "func (d *SQLiteDialect) MapType(prismaType string, isNullable bool) string {\n")
	fmt.Fprintf(file, "\tswitch strings.ToLower(prismaType) {\n")
	fmt.Fprintf(file, "\tcase \"string\":\n")
	fmt.Fprintf(file, "\t\treturn \"TEXT\"\n")
	fmt.Fprintf(file, "\tcase \"int\":\n")
	fmt.Fprintf(file, "\t\treturn \"INTEGER\"\n")
	fmt.Fprintf(file, "\tcase \"bigint\":\n")
	fmt.Fprintf(file, "\t\treturn \"INTEGER\"\n")
	fmt.Fprintf(file, "\tcase \"boolean\", \"bool\":\n")
	fmt.Fprintf(file, "\t\treturn \"INTEGER\"\n")
	fmt.Fprintf(file, "\tcase \"datetime\":\n")
	fmt.Fprintf(file, "\t\treturn \"TEXT\"\n")
	fmt.Fprintf(file, "\tcase \"float\":\n")
	fmt.Fprintf(file, "\t\treturn \"REAL\"\n")
	fmt.Fprintf(file, "\tcase \"decimal\":\n")
	fmt.Fprintf(file, "\t\treturn \"NUMERIC\"\n")
	fmt.Fprintf(file, "\tcase \"json\":\n")
	fmt.Fprintf(file, "\t\treturn \"TEXT\"\n")
	fmt.Fprintf(file, "\tcase \"bytes\":\n")
	fmt.Fprintf(file, "\t\treturn \"BLOB\"\n")
	fmt.Fprintf(file, "\tdefault:\n")
	fmt.Fprintf(file, "\t\treturn \"TEXT\"\n")
	fmt.Fprintf(file, "\t}\n")
	fmt.Fprintf(file, "}\n\n")
	fmt.Fprintf(file, "func (d *SQLiteDialect) MapDefaultValue(value string) string {\n")
	fmt.Fprintf(file, "\tvalue = strings.ToLower(value)\n")
	fmt.Fprintf(file, "\tswitch {\n")
	fmt.Fprintf(file, "\tcase value == \"autoincrement()\" || value == \"autoincrement\":\n")
	fmt.Fprintf(file, "\t\treturn \"\"\n")
	fmt.Fprintf(file, "\tcase value == \"now()\" || value == \"now\":\n")
	fmt.Fprintf(file, "\t\treturn \"datetime('now')\"\n")
	fmt.Fprintf(file, "\tcase strings.HasPrefix(value, \"uuid()\") || strings.HasPrefix(value, \"uuid\"):\n")
	fmt.Fprintf(file, "\t\treturn \"(lower(hex(randomblob(4))) || '-' || lower(hex(randomblob(2))) || '-4' || substr(lower(hex(randomblob(2))),2) || '-' || substr('89ab',abs(random()) %% 4 + 1, 1) || substr(lower(hex(randomblob(2))),2) || '-' || lower(hex(randomblob(6))))\"\n")
	fmt.Fprintf(file, "\tcase strings.HasPrefix(value, \"cuid()\") || strings.HasPrefix(value, \"cuid\"):\n")
	fmt.Fprintf(file, "\t\treturn \"(lower(hex(randomblob(4))) || '-' || lower(hex(randomblob(2))) || '-4' || substr(lower(hex(randomblob(2))),2) || '-' || substr('89ab',abs(random()) %% 4 + 1, 1) || substr(lower(hex(randomblob(2))),2) || '-' || lower(hex(randomblob(6))))\"\n")
	fmt.Fprintf(file, "\tdefault:\n")
	fmt.Fprintf(file, "\t\treturn value\n")
	fmt.Fprintf(file, "\t}\n")
	fmt.Fprintf(file, "}\n\n")
	fmt.Fprintf(file, "func (d *SQLiteDialect) GetPlaceholder(index int) string { return \"?\" }\n\n")
	fmt.Fprintf(file, "func (d *SQLiteDialect) GetAutoIncrementKeyword() string { return \"AUTOINCREMENT\" }\n\n")
	fmt.Fprintf(file, "func (d *SQLiteDialect) GetNowFunction() string { return \"datetime('now')\" }\n\n")
	fmt.Fprintf(file, "func (d *SQLiteDialect) GetDriverName() string { return \"sqlite3\" }\n\n")
	fmt.Fprintf(file, "func (d *SQLiteDialect) SupportsFullTextSearch() bool { return false }\n\n")
	fmt.Fprintf(file, "func (d *SQLiteDialect) GetFullTextSearchQuery(field string, query string) string {\n")
	fmt.Fprintf(file, "\treturn fmt.Sprintf(\"%%s LIKE %%s\", d.QuoteIdentifier(field), d.QuoteString(\"%%\"+query+\"%%\"))\n")
	fmt.Fprintf(file, "}\n\n")
	fmt.Fprintf(file, "func (d *SQLiteDialect) SupportsJSON() bool { return true }\n\n")
	fmt.Fprintf(file, "func (d *SQLiteDialect) GetJSONContainsQuery(field string, value string) string {\n")
	fmt.Fprintf(file, "\treturn fmt.Sprintf(\"json_extract(%%s, '$') = %%s\", d.QuoteIdentifier(field), d.QuoteString(value))\n")
	fmt.Fprintf(file, "}\n\n")
	fmt.Fprintf(file, "func (d *SQLiteDialect) GetLimitOffsetSyntax(limit, offset int) string {\n")
	fmt.Fprintf(file, "\tif limit > 0 && offset > 0 {\n")
	fmt.Fprintf(file, "\t\treturn fmt.Sprintf(\"LIMIT %%d OFFSET %%d\", limit, offset)\n")
	fmt.Fprintf(file, "\t} else if limit > 0 {\n")
	fmt.Fprintf(file, "\t\treturn fmt.Sprintf(\"LIMIT %%d\", limit)\n")
	fmt.Fprintf(file, "\t} else if offset > 0 {\n")
	fmt.Fprintf(file, "\t\treturn fmt.Sprintf(\"OFFSET %%d\", offset)\n")
	fmt.Fprintf(file, "\t}\n")
	fmt.Fprintf(file, "\treturn \"\"\n")
	fmt.Fprintf(file, "}\n")
}
