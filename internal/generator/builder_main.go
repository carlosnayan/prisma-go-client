package generator

import (
	"fmt"
	"path/filepath"
)

// generateBuilderMain generates builder.go with TableQueryBuilder
// This is a large file (571 lines), so we inline the entire builder/builder.go
func generateBuilderMain(builderDir string, provider string) error {
	file, err := createGeneratedFile(filepath.Join(builderDir, "builder.go"), "builder")
	if err != nil {
		return err
	}
	defer file.Close()
	fmt.Fprintf(file, "import (\n")
	fmt.Fprintf(file, "\t\"context\"\n")
	fmt.Fprintf(file, "\t\"fmt\"\n")
	fmt.Fprintf(file, "\t\"reflect\"\n")
	fmt.Fprintf(file, "\t\"strings\"\n")
	fmt.Fprintf(file, ")\n\n")

	// Generate DB interface with Begin method (builder-specific)
	fmt.Fprintf(file, "// DB is the main database interface that abstracts different database drivers\n")
	fmt.Fprintf(file, "type DB interface {\n")
	fmt.Fprintf(file, "\t// Exec executes a query that doesn't return rows\n")
	fmt.Fprintf(file, "\tExec(ctx context.Context, sql string, args ...interface{}) (Result, error)\n\n")
	fmt.Fprintf(file, "\t// Query executes a query that returns multiple rows\n")
	fmt.Fprintf(file, "\tQuery(ctx context.Context, sql string, args ...interface{}) (Rows, error)\n\n")
	fmt.Fprintf(file, "\t// QueryRow executes a query that returns a single row\n")
	fmt.Fprintf(file, "\tQueryRow(ctx context.Context, sql string, args ...interface{}) Row\n\n")
	fmt.Fprintf(file, "\t// Begin starts a new transaction\n")
	fmt.Fprintf(file, "\tBegin(ctx context.Context) (Tx, error)\n")
	fmt.Fprintf(file, "}\n\n")

	// Generate other shared interfaces (Result, Rows, Row)
	fmt.Fprintf(file, "// Result represents the result of an Exec operation\n")
	fmt.Fprintf(file, "type Result interface {\n")
	fmt.Fprintf(file, "\t// RowsAffected returns the number of rows affected\n")
	fmt.Fprintf(file, "\tRowsAffected() int64\n")
	fmt.Fprintf(file, "}\n\n")

	fmt.Fprintf(file, "// Rows represents a set of query results\n")
	fmt.Fprintf(file, "type Rows interface {\n")
	fmt.Fprintf(file, "\t// Close closes the rows iterator\n")
	fmt.Fprintf(file, "\tClose()\n\n")
	fmt.Fprintf(file, "\t// Err returns any error that occurred during iteration\n")
	fmt.Fprintf(file, "\tErr() error\n\n")
	fmt.Fprintf(file, "\t// Next prepares the next result row for reading\n")
	fmt.Fprintf(file, "\tNext() bool\n\n")
	fmt.Fprintf(file, "\t// Scan copies the columns in the current row into the values pointed at by dest\n")
	fmt.Fprintf(file, "\tScan(dest ...interface{}) error\n")
	fmt.Fprintf(file, "}\n\n")

	fmt.Fprintf(file, "// Row represents a single row result\n")
	fmt.Fprintf(file, "type Row interface {\n")
	fmt.Fprintf(file, "\t// Scan copies the columns in the current row into the values pointed at by dest\n")
	fmt.Fprintf(file, "\tScan(dest ...interface{}) error\n")
	fmt.Fprintf(file, "}\n\n")

	// Generate Tx interface
	generateTxInterface(file)

	// Type aliases
	fmt.Fprintf(file, "// DBTX is an alias for DB for backward compatibility\n")
	fmt.Fprintf(file, "type DBTX = DB\n\n")

	// TableQueryBuilder struct
	fmt.Fprintf(file, "// TableQueryBuilder provides a Prisma-like query builder for database tables\n")
	fmt.Fprintf(file, "type TableQueryBuilder struct {\n")
	fmt.Fprintf(file, "\tdb         DBTX\n")
	fmt.Fprintf(file, "\ttable      string\n")
	fmt.Fprintf(file, "\tcolumns    []string\n")
	fmt.Fprintf(file, "\tprimaryKey string\n")
	fmt.Fprintf(file, "\thasDeleted bool\n")
	fmt.Fprintf(file, "\tmodelType  reflect.Type\n")
	fmt.Fprintf(file, "\tdialect    Dialect\n")
	fmt.Fprintf(file, "}\n\n")

	// NewTableQueryBuilder
	fmt.Fprintf(file, "// NewTableQueryBuilder creates a new query builder for a table\n")
	fmt.Fprintf(file, "func NewTableQueryBuilder(db DBTX, table string, columns []string) *TableQueryBuilder {\n")
	fmt.Fprintf(file, "\treturn &TableQueryBuilder{\n")
	fmt.Fprintf(file, "\t\tdb:      db,\n")
	fmt.Fprintf(file, "\t\ttable:   table,\n")
	fmt.Fprintf(file, "\t\tcolumns: columns,\n")
	fmt.Fprintf(file, "\t\tdialect: GetDialect(%q), // Default based on provider\n", provider)
	fmt.Fprintf(file, "\t}\n")
	fmt.Fprintf(file, "}\n\n")

	// Setter methods
	fmt.Fprintf(file, "// SetDialect sets the database dialect\n")
	fmt.Fprintf(file, "func (b *TableQueryBuilder) SetDialect(d Dialect) *TableQueryBuilder {\n")
	fmt.Fprintf(file, "\tb.dialect = d\n")
	fmt.Fprintf(file, "\treturn b\n")
	fmt.Fprintf(file, "}\n\n")

	fmt.Fprintf(file, "// SetPrimaryKey defines the primary key column name\n")
	fmt.Fprintf(file, "func (b *TableQueryBuilder) SetPrimaryKey(pk string) *TableQueryBuilder {\n")
	fmt.Fprintf(file, "\tb.primaryKey = pk\n")
	fmt.Fprintf(file, "\treturn b\n")
	fmt.Fprintf(file, "}\n\n")

	fmt.Fprintf(file, "// SetHasDeleted indicates if the table has a deleted_at column for soft deletes\n")
	fmt.Fprintf(file, "func (b *TableQueryBuilder) SetHasDeleted(has bool) *TableQueryBuilder {\n")
	fmt.Fprintf(file, "\tb.hasDeleted = has\n")
	fmt.Fprintf(file, "\treturn b\n")
	fmt.Fprintf(file, "}\n\n")

	fmt.Fprintf(file, "// SetModelType defines the model type for automatic scanning\n")
	fmt.Fprintf(file, "func (b *TableQueryBuilder) SetModelType(modelType reflect.Type) *TableQueryBuilder {\n")
	fmt.Fprintf(file, "\tb.modelType = modelType\n")
	fmt.Fprintf(file, "\treturn b\n")
	fmt.Fprintf(file, "}\n\n")

	// FindFirst
	fmt.Fprintf(file, "// FindFirst finds the first record matching the where conditions\n")
	fmt.Fprintf(file, "func (b *TableQueryBuilder) FindFirst(ctx context.Context, where Where) (interface{}, error) {\n")
	fmt.Fprintf(file, "\tctx, cancel := WithQueryTimeout(ctx)\n")
	fmt.Fprintf(file, "\tdefer cancel()\n\n")
	fmt.Fprintf(file, "\tquery, args := b.buildQuery(where, nil, true)\n")
	fmt.Fprintf(file, "\trow := b.db.QueryRow(ctx, query, args...)\n\n")
	fmt.Fprintf(file, "\tif b.modelType == nil {\n")
	fmt.Fprintf(file, "\t\treturn row, nil\n")
	fmt.Fprintf(file, "\t}\n\n")
	fmt.Fprintf(file, "\treturn b.scanRow(row)\n")
	fmt.Fprintf(file, "}\n\n")

	// FindMany
	fmt.Fprintf(file, "// FindMany finds multiple records matching the query options\n")
	fmt.Fprintf(file, "func (b *TableQueryBuilder) FindMany(ctx context.Context, opts QueryOptions) (interface{}, error) {\n")
	fmt.Fprintf(file, "\tctx, cancel := WithQueryTimeout(ctx)\n")
	fmt.Fprintf(file, "\tdefer cancel()\n\n")
	fmt.Fprintf(file, "\tquery, args := b.buildQuery(opts.Where, &opts, false)\n")
	fmt.Fprintf(file, "\trows, err := b.db.Query(ctx, query, args...)\n")
	fmt.Fprintf(file, "\tif err != nil {\n")
	fmt.Fprintf(file, "\t\treturn nil, err\n")
	fmt.Fprintf(file, "\t}\n")
	fmt.Fprintf(file, "\tdefer rows.Close()\n\n")
	fmt.Fprintf(file, "\tif b.modelType == nil {\n")
	fmt.Fprintf(file, "\t\treturn rows, nil\n")
	fmt.Fprintf(file, "\t}\n\n")
	fmt.Fprintf(file, "\treturn b.scanRows(rows)\n")
	fmt.Fprintf(file, "}\n\n")

	// Count
	fmt.Fprintf(file, "// Count counts records matching the where conditions\n")
	fmt.Fprintf(file, "func (b *TableQueryBuilder) Count(ctx context.Context, where Where) (int, error) {\n")
	fmt.Fprintf(file, "\tctx, cancel := WithQueryTimeout(ctx)\n")
	fmt.Fprintf(file, "\tdefer cancel()\n\n")
	fmt.Fprintf(file, "\tvar parts []string\n")
	fmt.Fprintf(file, "\tvar args []interface{}\n")
	fmt.Fprintf(file, "\targIndex := 1\n\n")
	fmt.Fprintf(file, "\tquotedTable := b.dialect.QuoteIdentifier(b.table)\n")
	fmt.Fprintf(file, "\tparts = append(parts, fmt.Sprintf(\"SELECT COUNT(*) FROM %%s\", quotedTable))\n\n")
	fmt.Fprintf(file, "\tif len(where) > 0 {\n")
	fmt.Fprintf(file, "\t\twhereClause, whereArgs := b.buildWhereFromMap(where, &argIndex)\n")
	fmt.Fprintf(file, "\t\tif whereClause != \"\" {\n")
	fmt.Fprintf(file, "\t\t\tparts = append(parts, \"WHERE \"+whereClause)\n")
	fmt.Fprintf(file, "\t\t\targs = append(args, whereArgs...)\n")
	fmt.Fprintf(file, "\t\t}\n")
	fmt.Fprintf(file, "\t}\n\n")
	fmt.Fprintf(file, "\tquery := strings.Join(parts, \" \")\n")
	fmt.Fprintf(file, "\tvar count int\n")
	fmt.Fprintf(file, "\terr := b.db.QueryRow(ctx, query, args...).Scan(&count)\n")
	fmt.Fprintf(file, "\tif err != nil {\n")
	fmt.Fprintf(file, "\t\treturn 0, SanitizeError(err)\n")
	fmt.Fprintf(file, "\t}\n")
	fmt.Fprintf(file, "\treturn count, nil\n")
	fmt.Fprintf(file, "}\n\n")

	// Create - simplified version that uses dialect placeholders
	fmt.Fprintf(file, "// Create inserts a new record and returns the created model\n")
	fmt.Fprintf(file, "func (b *TableQueryBuilder) Create(ctx context.Context, data interface{}) (interface{}, error) {\n")
	fmt.Fprintf(file, "\tctx, cancel := WithQueryTimeout(ctx)\n")
	fmt.Fprintf(file, "\tdefer cancel()\n\n")
	fmt.Fprintf(file, "\tval := reflect.ValueOf(data)\n")
	fmt.Fprintf(file, "\tif val.Kind() == reflect.Ptr {\n")
	fmt.Fprintf(file, "\t\tval = val.Elem()\n")
	fmt.Fprintf(file, "\t}\n")
	fmt.Fprintf(file, "\tif val.Kind() != reflect.Struct {\n")
	fmt.Fprintf(file, "\t\treturn nil, fmt.Errorf(\"data must be a struct\")\n")
	fmt.Fprintf(file, "\t}\n\n")
	fmt.Fprintf(file, "\tvar insertColumns []string\n")
	fmt.Fprintf(file, "\tvar values []string\n")
	fmt.Fprintf(file, "\tvar args []interface{}\n")
	fmt.Fprintf(file, "\targIndex := 1\n\n")
	fmt.Fprintf(file, "\ttyp := val.Type()\n")
	fmt.Fprintf(file, "\tfor i := 0; i < val.NumField(); i++ {\n")
	fmt.Fprintf(file, "\t\tfield := typ.Field(i)\n")
	fmt.Fprintf(file, "\t\tfieldVal := val.Field(i)\n\n")
	fmt.Fprintf(file, "\t\tif fieldVal.IsZero() {\n")
	fmt.Fprintf(file, "\t\t\tcontinue\n")
	fmt.Fprintf(file, "\t}\n\n")
	fmt.Fprintf(file, "\t\tfieldName := toSnakeCase(field.Name)\n")
	fmt.Fprintf(file, "\t\tif fieldName == b.primaryKey || fieldName == \"created_at\" || fieldName == \"updated_at\" {\n")
	fmt.Fprintf(file, "\t\t\tcontinue\n")
	fmt.Fprintf(file, "\t\t}\n\n")
	fmt.Fprintf(file, "\t\tinsertColumns = append(insertColumns, fieldName)\n")
	fmt.Fprintf(file, "\t\tvalues = append(values, b.dialect.GetPlaceholder(argIndex))\n")
	fmt.Fprintf(file, "\t\targs = append(args, fieldVal.Interface())\n")
	fmt.Fprintf(file, "\t\targIndex++\n")
	fmt.Fprintf(file, "\t}\n\n")
	fmt.Fprintf(file, "\thasCreatedAt := contains(b.columns, \"created_at\")\n")
	fmt.Fprintf(file, "\thasUpdatedAt := contains(b.columns, \"updated_at\")\n")
	fmt.Fprintf(file, "\tvar returningColumns []string\n\n")
	fmt.Fprintf(file, "\tif hasCreatedAt {\n")
	fmt.Fprintf(file, "\t\tinsertColumns = append(insertColumns, \"created_at\")\n")
	fmt.Fprintf(file, "\t\tvalues = append(values, b.dialect.GetNowFunction())\n")
	fmt.Fprintf(file, "\t\treturningColumns = append(returningColumns, \"created_at\")\n")
	fmt.Fprintf(file, "\t}\n")
	fmt.Fprintf(file, "\tif hasUpdatedAt {\n")
	fmt.Fprintf(file, "\t\tinsertColumns = append(insertColumns, \"updated_at\")\n")
	fmt.Fprintf(file, "\t\tvalues = append(values, b.dialect.GetNowFunction())\n")
	fmt.Fprintf(file, "\t\treturningColumns = append(returningColumns, \"updated_at\")\n")
	fmt.Fprintf(file, "\t}\n\n")
	fmt.Fprintf(file, "\treturningColumns = append(returningColumns, b.columns...)\n\n")
	fmt.Fprintf(file, "\tquotedTable := b.dialect.QuoteIdentifier(b.table)\n")
	fmt.Fprintf(file, "\tquotedInsertCols := make([]string, len(insertColumns))\n")
	fmt.Fprintf(file, "\tfor i, col := range insertColumns {\n")
	fmt.Fprintf(file, "\t\tquotedInsertCols[i] = b.dialect.QuoteIdentifier(col)\n")
	fmt.Fprintf(file, "\t}\n")
	fmt.Fprintf(file, "\tquotedReturnCols := make([]string, len(returningColumns))\n")
	fmt.Fprintf(file, "\tfor i, col := range returningColumns {\n")
	fmt.Fprintf(file, "\t\tquotedReturnCols[i] = b.dialect.QuoteIdentifier(col)\n")
	fmt.Fprintf(file, "\t}\n")
	fmt.Fprintf(file, "\tquery := fmt.Sprintf(\n")
	fmt.Fprintf(file, "\t\t\"INSERT INTO %%s (%%s) VALUES (%%s) RETURNING %%s\",\n")
	fmt.Fprintf(file, "\t\tquotedTable,\n")
	fmt.Fprintf(file, "\t\tstrings.Join(quotedInsertCols, \", \"),\n")
	fmt.Fprintf(file, "\t\tstrings.Join(values, \", \"),\n")
	fmt.Fprintf(file, "\t\tstrings.Join(quotedReturnCols, \", \"),\n")
	fmt.Fprintf(file, "\t)\n\n")
	fmt.Fprintf(file, "\trow := b.db.QueryRow(ctx, query, args...)\n\n")
	fmt.Fprintf(file, "\tif b.modelType == nil {\n")
	fmt.Fprintf(file, "\t\treturn row, nil\n")
	fmt.Fprintf(file, "\t}\n\n")
	fmt.Fprintf(file, "\treturn b.scanRow(row)\n")
	fmt.Fprintf(file, "}\n\n")

	// Update
	fmt.Fprintf(file, "// Update updates a record by primary key and returns the updated model\n")
	fmt.Fprintf(file, "func (b *TableQueryBuilder) Update(ctx context.Context, id interface{}, data interface{}) (interface{}, error) {\n")
	fmt.Fprintf(file, "\tctx, cancel := WithQueryTimeout(ctx)\n")
	fmt.Fprintf(file, "\tdefer cancel()\n\n")
	fmt.Fprintf(file, "\tif b.primaryKey == \"\" {\n")
	fmt.Fprintf(file, "\t\terr := fmt.Errorf(\"primary key not defined for table %%s\", b.table)\n")
	fmt.Fprintf(file, "\t\treturn nil, SanitizeError(err)\n")
	fmt.Fprintf(file, "\t}\n\n")
	fmt.Fprintf(file, "\tval := reflect.ValueOf(data)\n")
	fmt.Fprintf(file, "\tif val.Kind() == reflect.Ptr {\n")
	fmt.Fprintf(file, "\t\tval = val.Elem()\n")
	fmt.Fprintf(file, "\t}\n")
	fmt.Fprintf(file, "\tif val.Kind() != reflect.Struct {\n")
	fmt.Fprintf(file, "\t\treturn nil, fmt.Errorf(\"data must be a struct\")\n")
	fmt.Fprintf(file, "\t}\n\n")
	fmt.Fprintf(file, "\tvar updateColumns []string\n")
	fmt.Fprintf(file, "\tvar args []interface{}\n")
	fmt.Fprintf(file, "\targIndex := 1\n\n")
	fmt.Fprintf(file, "\ttyp := val.Type()\n")
	fmt.Fprintf(file, "\tfor i := 0; i < val.NumField(); i++ {\n")
	fmt.Fprintf(file, "\t\tfield := typ.Field(i)\n")
	fmt.Fprintf(file, "\t\tfieldVal := val.Field(i)\n\n")
	fmt.Fprintf(file, "\t\tfieldName := toSnakeCase(field.Name)\n")
	fmt.Fprintf(file, "\t\tquotedFieldName := b.dialect.QuoteIdentifier(fieldName)\n\n")
	fmt.Fprintf(file, "\t\tif fieldName == b.primaryKey || fieldName == \"created_at\" || fieldName == \"deleted_at\" {\n")
	fmt.Fprintf(file, "\t\t\tcontinue\n")
	fmt.Fprintf(file, "\t\t}\n\n")
	fmt.Fprintf(file, "\t\tif fieldName == \"updated_at\" {\n")
	fmt.Fprintf(file, "\t\t\tquotedUpdatedAt := b.dialect.QuoteIdentifier(\"updated_at\")\n")
	fmt.Fprintf(file, "\t\t\tupdateColumns = append(updateColumns, fmt.Sprintf(\"%%s = %%s\", quotedUpdatedAt, b.dialect.GetNowFunction()))\n")
	fmt.Fprintf(file, "\t\t\tcontinue\n")
	fmt.Fprintf(file, "\t\t}\n\n")
	fmt.Fprintf(file, "\t\tif fieldVal.IsZero() {\n")
	fmt.Fprintf(file, "\t\t\tcontinue\n")
	fmt.Fprintf(file, "\t}\n\n")
	fmt.Fprintf(file, "\t\tupdateColumns = append(updateColumns, fmt.Sprintf(\"%%s = %%s\", quotedFieldName, b.dialect.GetPlaceholder(argIndex)))\n")
	fmt.Fprintf(file, "\t\targs = append(args, fieldVal.Interface())\n")
	fmt.Fprintf(file, "\t\targIndex++\n")
	fmt.Fprintf(file, "\t}\n\n")
	fmt.Fprintf(file, "\tif len(updateColumns) == 0 {\n")
	fmt.Fprintf(file, "\t\terr := fmt.Errorf(\"no fields to update\")\n")
	fmt.Fprintf(file, "\t\treturn nil, SanitizeError(err)\n")
	fmt.Fprintf(file, "\t}\n\n")
	fmt.Fprintf(file, "\thasUpdatedAt := contains(b.columns, \"updated_at\")\n")
	fmt.Fprintf(file, "\tif hasUpdatedAt && !contains(updateColumns, \"updated_at\") {\n")
	fmt.Fprintf(file, "\t\tquotedUpdatedAt := b.dialect.QuoteIdentifier(\"updated_at\")\n")
	fmt.Fprintf(file, "\t\tupdateColumns = append(updateColumns, fmt.Sprintf(\"%%s = %%s\", quotedUpdatedAt, b.dialect.GetNowFunction()))\n")
	fmt.Fprintf(file, "\t}\n\n")
	fmt.Fprintf(file, "\tquotedPK := b.dialect.QuoteIdentifier(b.primaryKey)\n")
	fmt.Fprintf(file, "\twhereClause := fmt.Sprintf(\"%%s = %%s\", quotedPK, b.dialect.GetPlaceholder(argIndex))\n")
	fmt.Fprintf(file, "\targs = append(args, id)\n\n")
	fmt.Fprintf(file, "\tif b.hasDeleted {\n")
	fmt.Fprintf(file, "\t\tquotedDeletedAt := b.dialect.QuoteIdentifier(\"deleted_at\")\n")
	fmt.Fprintf(file, "\t\twhereClause += fmt.Sprintf(\" AND %%s IS NULL\", quotedDeletedAt)\n")
	fmt.Fprintf(file, "\t}\n\n")
	fmt.Fprintf(file, "\tquotedReturnCols := make([]string, len(b.columns))\n")
	fmt.Fprintf(file, "\tfor i, col := range b.columns {\n")
	fmt.Fprintf(file, "\t\tquotedReturnCols[i] = b.dialect.QuoteIdentifier(col)\n")
	fmt.Fprintf(file, "\t}\n")
	fmt.Fprintf(file, "\treturningColumns := quotedReturnCols\n\n")
	fmt.Fprintf(file, "\tquotedTable := b.dialect.QuoteIdentifier(b.table)\n")
	fmt.Fprintf(file, "\tquery := fmt.Sprintf(\n")
	fmt.Fprintf(file, "\t\t\"UPDATE %%s SET %%s WHERE %%s RETURNING %%s\",\n")
	fmt.Fprintf(file, "\t\tquotedTable,\n")
	fmt.Fprintf(file, "\t\tstrings.Join(updateColumns, \", \"),\n")
	fmt.Fprintf(file, "\t\twhereClause,\n")
	fmt.Fprintf(file, "\t\tstrings.Join(returningColumns, \", \"),\n")
	fmt.Fprintf(file, "\t)\n\n")
	fmt.Fprintf(file, "\trow := b.db.QueryRow(ctx, query, args...)\n\n")
	fmt.Fprintf(file, "\tif b.modelType == nil {\n")
	fmt.Fprintf(file, "\t\treturn row, nil\n")
	fmt.Fprintf(file, "\t}\n\n")
	fmt.Fprintf(file, "\treturn b.scanRow(row)\n")
	fmt.Fprintf(file, "}\n\n")

	// Delete
	fmt.Fprintf(file, "// Delete removes a record (soft delete if has deleted_at, otherwise hard delete)\n")
	fmt.Fprintf(file, "func (b *TableQueryBuilder) Delete(ctx context.Context, id interface{}) error {\n")
	fmt.Fprintf(file, "\tctx, cancel := WithQueryTimeout(ctx)\n")
	fmt.Fprintf(file, "\tdefer cancel()\n\n")
	fmt.Fprintf(file, "\tif b.primaryKey == \"\" {\n")
	fmt.Fprintf(file, "\t\terr := fmt.Errorf(\"primary key not defined for table %%s\", b.table)\n")
	fmt.Fprintf(file, "\t\treturn SanitizeError(err)\n")
	fmt.Fprintf(file, "\t}\n\n")
	fmt.Fprintf(file, "\tvar query string\n")
	fmt.Fprintf(file, "\tvar args []interface{}\n\n")
	fmt.Fprintf(file, "\tquotedTable := b.dialect.QuoteIdentifier(b.table)\n")
	fmt.Fprintf(file, "\tquotedPK := b.dialect.QuoteIdentifier(b.primaryKey)\n")
	fmt.Fprintf(file, "\tquotedDeletedAt := b.dialect.QuoteIdentifier(\"deleted_at\")\n")
	fmt.Fprintf(file, "\tif b.hasDeleted {\n")
	fmt.Fprintf(file, "\t\tquery = fmt.Sprintf(\n")
	fmt.Fprintf(file, "\t\t\t\"UPDATE %%s SET %%s = %%s WHERE %%s = %%s AND %%s IS NULL\",\n")
	fmt.Fprintf(file, "\t\t\tquotedTable,\n")
	fmt.Fprintf(file, "\t\t\tquotedDeletedAt,\n")
	fmt.Fprintf(file, "\t\t\tb.dialect.GetNowFunction(),\n")
	fmt.Fprintf(file, "\t\t\tquotedPK,\n")
	fmt.Fprintf(file, "\t\t\tb.dialect.GetPlaceholder(1),\n")
	fmt.Fprintf(file, "\t\t\tquotedDeletedAt,\n")
	fmt.Fprintf(file, "\t\t)\n")
	fmt.Fprintf(file, "\t\targs = []interface{}{id}\n")
	fmt.Fprintf(file, "\t} else {\n")
	fmt.Fprintf(file, "\t\tquery = fmt.Sprintf(\n")
	fmt.Fprintf(file, "\t\t\t\"DELETE FROM %%s WHERE %%s = %%s\",\n")
	fmt.Fprintf(file, "\t\t\tquotedTable,\n")
	fmt.Fprintf(file, "\t\t\tquotedPK,\n")
	fmt.Fprintf(file, "\t\t\tb.dialect.GetPlaceholder(1),\n")
	fmt.Fprintf(file, "\t\t)\n")
	fmt.Fprintf(file, "\t\targs = []interface{}{id}\n")
	fmt.Fprintf(file, "\t}\n\n")
	fmt.Fprintf(file, "\t_, err := b.db.Exec(ctx, query, args...)\n")
	fmt.Fprintf(file, "\treturn err\n")
	fmt.Fprintf(file, "}\n\n")

	// buildQuery
	fmt.Fprintf(file, "// buildQuery constructs the SQL query\n")
	fmt.Fprintf(file, "func (b *TableQueryBuilder) buildQuery(where Where, opts *QueryOptions, single bool) (string, []interface{}) {\n")
	fmt.Fprintf(file, "\tvar parts []string\n")
	fmt.Fprintf(file, "\tvar args []interface{}\n")
	fmt.Fprintf(file, "\targIndex := 1\n\n")
	fmt.Fprintf(file, "\tquotedColumns := make([]string, len(b.columns))\n")
	fmt.Fprintf(file, "\tfor i, col := range b.columns {\n")
	fmt.Fprintf(file, "\t\tquotedColumns[i] = b.dialect.QuoteIdentifier(col)\n")
	fmt.Fprintf(file, "\t}\n")
	fmt.Fprintf(file, "\tcolumns := strings.Join(quotedColumns, \", \")\n")
	fmt.Fprintf(file, "\tquotedTable := b.dialect.QuoteIdentifier(b.table)\n")
	fmt.Fprintf(file, "\tparts = append(parts, fmt.Sprintf(\"SELECT %%s FROM %%s\", columns, quotedTable))\n\n")
	fmt.Fprintf(file, "\tif len(where) > 0 {\n")
	fmt.Fprintf(file, "\t\twhereClause, whereArgs := b.buildWhereFromMap(where, &argIndex)\n")
	fmt.Fprintf(file, "\t\tif whereClause != \"\" {\n")
	fmt.Fprintf(file, "\t\t\tparts = append(parts, \"WHERE \"+whereClause)\n")
	fmt.Fprintf(file, "\t\t\targs = append(args, whereArgs...)\n")
	fmt.Fprintf(file, "\t\t\targIndex += len(whereArgs)\n")
	fmt.Fprintf(file, "\t\t}\n")
	fmt.Fprintf(file, "\t}\n\n")
	fmt.Fprintf(file, "\tif opts != nil && len(opts.OrderBy) > 0 {\n")
	fmt.Fprintf(file, "\t\tvar orderParts []string\n")
	fmt.Fprintf(file, "\t\tfor _, order := range opts.OrderBy {\n")
	fmt.Fprintf(file, "\t\t\tquotedField := b.dialect.QuoteIdentifier(order.Field)\n")
	fmt.Fprintf(file, "\t\t\torderDir := strings.ToUpper(strings.TrimSpace(order.Order))\n")
	fmt.Fprintf(file, "\t\t\tif orderDir != \"ASC\" && orderDir != \"DESC\" {\n")
	fmt.Fprintf(file, "\t\t\t\torderDir = \"ASC\"\n")
	fmt.Fprintf(file, "\t\t\t}\n")
	fmt.Fprintf(file, "\t\t\torderParts = append(orderParts, fmt.Sprintf(\"%%s %%s\", quotedField, orderDir))\n")
	fmt.Fprintf(file, "\t\t}\n")
	fmt.Fprintf(file, "\t\tparts = append(parts, \"ORDER BY \"+strings.Join(orderParts, \", \"))\n")
	fmt.Fprintf(file, "\t}\n\n")
	fmt.Fprintf(file, "\tif !single {\n")
	fmt.Fprintf(file, "\t\tif opts != nil && opts.Take != nil {\n")
	fmt.Fprintf(file, "\t\t\tparts = append(parts, fmt.Sprintf(\"LIMIT %%s\", b.dialect.GetPlaceholder(argIndex)))\n")
	fmt.Fprintf(file, "\t\t\targs = append(args, *opts.Take)\n")
	fmt.Fprintf(file, "\t\t\targIndex++\n")
	fmt.Fprintf(file, "\t\t}\n")
	fmt.Fprintf(file, "\t\tif opts != nil && opts.Skip != nil {\n")
	fmt.Fprintf(file, "\t\t\tparts = append(parts, fmt.Sprintf(\"OFFSET %%s\", b.dialect.GetPlaceholder(argIndex)))\n")
	fmt.Fprintf(file, "\t\t\targs = append(args, *opts.Skip)\n")
	fmt.Fprintf(file, "\t\t\targIndex++\n")
	fmt.Fprintf(file, "\t\t}\n")
	fmt.Fprintf(file, "\t} else {\n")
	fmt.Fprintf(file, "\t\tparts = append(parts, \"LIMIT 1\")\n")
	fmt.Fprintf(file, "\t}\n\n")
	fmt.Fprintf(file, "\treturn strings.Join(parts, \" \"), args\n")
	fmt.Fprintf(file, "}\n\n")

	// buildWhereFromMap
	fmt.Fprintf(file, "// buildWhereFromMap constructs the WHERE clause from a Prisma-style map\n")
	fmt.Fprintf(file, "func (b *TableQueryBuilder) buildWhereFromMap(where Where, argIndex *int) (string, []interface{}) {\n")
	fmt.Fprintf(file, "\tvar parts []string\n")
	fmt.Fprintf(file, "\tvar args []interface{}\n\n")
	fmt.Fprintf(file, "\tfor field, value := range where {\n")
	fmt.Fprintf(file, "\t\tquotedField := b.dialect.QuoteIdentifier(field)\n")
	fmt.Fprintf(file, "\t\tif op, ok := value.(WhereOperator); ok {\n")
	fmt.Fprintf(file, "\t\t\tswitch op.GetOp() {\n")
	fmt.Fprintf(file, "\t\t\tcase \"IS NULL\", \"IS NOT NULL\":\n")
	fmt.Fprintf(file, "\t\t\t\tparts = append(parts, fmt.Sprintf(\"%%s %%s\", quotedField, op.GetOp()))\n")
	fmt.Fprintf(file, "\t\t\tcase \"IN\", \"NOT IN\":\n")
	fmt.Fprintf(file, "\t\t\t\tif values, ok := op.GetValue().([]interface{}); ok {\n")
	fmt.Fprintf(file, "\t\t\t\t\tplaceholders := make([]string, len(values))\n")
	fmt.Fprintf(file, "\t\t\t\t\tfor i := range values {\n")
	fmt.Fprintf(file, "\t\t\t\t\t\tplaceholders[i] = b.dialect.GetPlaceholder(*argIndex)\n")
	fmt.Fprintf(file, "\t\t\t\t\t\targs = append(args, values[i])\n")
	fmt.Fprintf(file, "\t\t\t\t\t\t(*argIndex)++\n")
	fmt.Fprintf(file, "\t\t\t\t\t}\n")
	fmt.Fprintf(file, "\t\t\t\t\tparts = append(parts, fmt.Sprintf(\"%%s %%s (%%s)\", quotedField, op.GetOp(), strings.Join(placeholders, \", \")))\n")
	fmt.Fprintf(file, "\t\t\t\t}\n")
	fmt.Fprintf(file, "\t\t\tdefault:\n")
	fmt.Fprintf(file, "\t\t\t\tparts = append(parts, fmt.Sprintf(\"%%s %%s %%s\", quotedField, op.GetOp(), b.dialect.GetPlaceholder(*argIndex)))\n")
	fmt.Fprintf(file, "\t\t\t\targs = append(args, op.GetValue())\n")
	fmt.Fprintf(file, "\t\t\t\t(*argIndex)++\n")
	fmt.Fprintf(file, "\t\t\t}\n")
	fmt.Fprintf(file, "\t\t} else if value == nil {\n")
	fmt.Fprintf(file, "\t\t\tparts = append(parts, fmt.Sprintf(\"%%s IS NULL\", quotedField))\n")
	fmt.Fprintf(file, "\t\t} else {\n")
	fmt.Fprintf(file, "\t\t\tparts = append(parts, fmt.Sprintf(\"%%s = %%s\", quotedField, b.dialect.GetPlaceholder(*argIndex)))\n")
	fmt.Fprintf(file, "\t\t\targs = append(args, value)\n")
	fmt.Fprintf(file, "\t\t\t(*argIndex)++\n")
	fmt.Fprintf(file, "\t\t}\n")
	fmt.Fprintf(file, "\t}\n\n")
	fmt.Fprintf(file, "\treturn strings.Join(parts, \" AND \"), args\n")
	fmt.Fprintf(file, "}\n\n")

	// scanRow
	fmt.Fprintf(file, "// scanRow scans a single row into the model type\n")
	fmt.Fprintf(file, "func (b *TableQueryBuilder) scanRow(row Row) (interface{}, error) {\n")
	fmt.Fprintf(file, "\tif b.modelType == nil {\n")
	fmt.Fprintf(file, "\t\terr := fmt.Errorf(\"modelType not defined\")\n")
	fmt.Fprintf(file, "\t\treturn nil, SanitizeError(err)\n")
	fmt.Fprintf(file, "\t}\n\n")
	fmt.Fprintf(file, "\tmodelValue := reflect.New(b.modelType).Elem()\n\n")
	fmt.Fprintf(file, "\tcolumnToField := make(map[string]int)\n")
	fmt.Fprintf(file, "\tfor i := 0; i < b.modelType.NumField(); i++ {\n")
	fmt.Fprintf(file, "\t\tfield := b.modelType.Field(i)\n")
	fmt.Fprintf(file, "\t\tjsonTag := field.Tag.Get(\"json\")\n")
	fmt.Fprintf(file, "\t\tif jsonTag != \"\" && jsonTag != \"-\" {\n")
	fmt.Fprintf(file, "\t\t\tif idx := strings.Index(jsonTag, \",\"); idx != -1 {\n")
	fmt.Fprintf(file, "\t\t\t\tjsonTag = jsonTag[:idx]\n")
	fmt.Fprintf(file, "\t\t\t}\n")
	fmt.Fprintf(file, "\t\t\tcolumnToField[jsonTag] = i\n")
	fmt.Fprintf(file, "\t\t}\n")
	fmt.Fprintf(file, "\t}\n\n")
	fmt.Fprintf(file, "\tfields := make([]interface{}, len(b.columns))\n")
	fmt.Fprintf(file, "\tfor i, colName := range b.columns {\n")
	fmt.Fprintf(file, "\t\tif fieldIdx, ok := columnToField[colName]; ok {\n")
	fmt.Fprintf(file, "\t\t\tfield := modelValue.Field(fieldIdx)\n")
	fmt.Fprintf(file, "\t\t\tfields[i] = field.Addr().Interface()\n")
	fmt.Fprintf(file, "\t\t} else {\n")
	fmt.Fprintf(file, "\t\t\tvar dummy interface{}\n")
	fmt.Fprintf(file, "\t\t\tfields[i] = &dummy\n")
	fmt.Fprintf(file, "\t\t}\n")
	fmt.Fprintf(file, "\t}\n\n")
	fmt.Fprintf(file, "\terr := row.Scan(fields...)\n")
	fmt.Fprintf(file, "\tif err != nil {\n")
	fmt.Fprintf(file, "\t\treturn nil, err\n")
	fmt.Fprintf(file, "\t}\n\n")
	fmt.Fprintf(file, "\treturn modelValue.Interface(), nil\n")
	fmt.Fprintf(file, "}\n\n")

	// scanRows
	fmt.Fprintf(file, "// scanRows scans multiple rows into a slice of models\n")
	fmt.Fprintf(file, "func (b *TableQueryBuilder) scanRows(rows Rows) (interface{}, error) {\n")
	fmt.Fprintf(file, "\tif b.modelType == nil {\n")
	fmt.Fprintf(file, "\t\terr := fmt.Errorf(\"modelType not defined\")\n")
	fmt.Fprintf(file, "\t\treturn nil, SanitizeError(err)\n")
	fmt.Fprintf(file, "\t}\n\n")
	fmt.Fprintf(file, "\tcolumnToField := make(map[string]int)\n")
	fmt.Fprintf(file, "\tfor i := 0; i < b.modelType.NumField(); i++ {\n")
	fmt.Fprintf(file, "\t\tfield := b.modelType.Field(i)\n")
	fmt.Fprintf(file, "\t\tjsonTag := field.Tag.Get(\"json\")\n")
	fmt.Fprintf(file, "\t\tif jsonTag != \"\" && jsonTag != \"-\" {\n")
	fmt.Fprintf(file, "\t\t\tif idx := strings.Index(jsonTag, \",\"); idx != -1 {\n")
	fmt.Fprintf(file, "\t\t\t\tjsonTag = jsonTag[:idx]\n")
	fmt.Fprintf(file, "\t\t\t}\n")
	fmt.Fprintf(file, "\t\t\tcolumnToField[jsonTag] = i\n")
	fmt.Fprintf(file, "\t\t}\n")
	fmt.Fprintf(file, "\t}\n\n")
	fmt.Fprintf(file, "\tsliceType := reflect.SliceOf(b.modelType)\n")
	fmt.Fprintf(file, "\tconst initialCapacity = 100\n")
	fmt.Fprintf(file, "\tsliceValue := reflect.MakeSlice(sliceType, 0, initialCapacity)\n\n")
	fmt.Fprintf(file, "\trowCount := 0\n")
	fmt.Fprintf(file, "\tfor rows.Next() {\n")
	fmt.Fprintf(file, "\t\tif rowCount >= MaxScanRows {\n")
	fmt.Fprintf(file, "\t\t\treturn nil, fmt.Errorf(\"result set too large: maximum %%d rows allowed\", MaxScanRows)\n")
	fmt.Fprintf(file, "\t\t}\n\n")
	fmt.Fprintf(file, "\t\tmodelValue := reflect.New(b.modelType).Elem()\n\n")
	fmt.Fprintf(file, "\t\tfields := make([]interface{}, len(b.columns))\n")
	fmt.Fprintf(file, "\t\tfor i, colName := range b.columns {\n")
	fmt.Fprintf(file, "\t\t\tif fieldIdx, ok := columnToField[colName]; ok {\n")
	fmt.Fprintf(file, "\t\t\t\tfield := modelValue.Field(fieldIdx)\n")
	fmt.Fprintf(file, "\t\t\t\tfields[i] = field.Addr().Interface()\n")
	fmt.Fprintf(file, "\t\t\t} else {\n")
	fmt.Fprintf(file, "\t\t\t\tvar dummy interface{}\n")
	fmt.Fprintf(file, "\t\t\t\tfields[i] = &dummy\n")
	fmt.Fprintf(file, "\t\t\t}\n")
	fmt.Fprintf(file, "\t\t}\n\n")
	fmt.Fprintf(file, "\t\tif err := rows.Scan(fields...); err != nil {\n")
	fmt.Fprintf(file, "\t\t\treturn nil, err\n")
	fmt.Fprintf(file, "\t\t}\n\n")
	fmt.Fprintf(file, "\t\tsliceValue = reflect.Append(sliceValue, modelValue)\n")
	fmt.Fprintf(file, "\t\trowCount++\n")
	fmt.Fprintf(file, "\t}\n\n")
	fmt.Fprintf(file, "\tif err := rows.Err(); err != nil {\n")
	fmt.Fprintf(file, "\t\treturn nil, err\n")
	fmt.Fprintf(file, "\t}\n\n")
	fmt.Fprintf(file, "\treturn sliceValue.Interface(), nil\n")
	fmt.Fprintf(file, "}\n\n")

	// Generate helper functions
	generateHelperFunctions(file)

	return nil
}
