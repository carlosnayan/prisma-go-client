package generator

import (
	"fmt"
	"path/filepath"
)

// generateBuilderLimits generates limits.go
func generateBuilderLimits(builderDir string) error {
	file, err := createGeneratedFile(filepath.Join(builderDir, "limits.go"), "builder")
	if err != nil {
		return err
	}
	defer file.Close()
	fmt.Fprintf(file, "// Memory safety limits to prevent unbounded growth and OOM\n\n")
	fmt.Fprintf(file, "const (\n")
	fmt.Fprintf(file, "\t// MaxScanRows is the maximum number of rows that can be scanned into memory\n")
	fmt.Fprintf(file, "\t// This prevents OOM when querying very large datasets\n")
	fmt.Fprintf(file, "\tMaxScanRows = 100000\n\n")
	fmt.Fprintf(file, "\t// MaxQueryConditions is the maximum number of WHERE conditions in a single query\n")
	fmt.Fprintf(file, "\t// This prevents unbounded growth of whereConditions slice\n")
	fmt.Fprintf(file, "\tMaxQueryConditions = 1000\n\n")
	fmt.Fprintf(file, "\t// MaxJoins is the maximum number of JOINs in a single query\n")
	fmt.Fprintf(file, "\t// This prevents unbounded growth of joins slice\n")
	fmt.Fprintf(file, "\tMaxJoins = 50\n\n")
	fmt.Fprintf(file, "\t// MaxOrderByFields is the maximum number of ORDER BY fields\n")
	fmt.Fprintf(file, "\tMaxOrderByFields = 20\n\n")
	fmt.Fprintf(file, "\t// MaxGroupByFields is the maximum number of GROUP BY fields\n")
	fmt.Fprintf(file, "\tMaxGroupByFields = 20\n\n")
	fmt.Fprintf(file, "\t// MaxSelectFields is the maximum number of SELECT fields\n")
	fmt.Fprintf(file, "\tMaxSelectFields = 100\n")
	fmt.Fprintf(file, ")\n")

	return nil
}

// generateBuilderContext generates context.go
func generateBuilderContext(builderDir string) error {
	file, err := createGeneratedFile(filepath.Join(builderDir, "context.go"), "builder")
	if err != nil {
		return err
	}
	defer file.Close()
	fmt.Fprintf(file, "import (\n")
	fmt.Fprintf(file, "\t\"context\"\n")
	fmt.Fprintf(file, "\t\"time\"\n")
	fmt.Fprintf(file, ")\n\n")
	fmt.Fprintf(file, "// DefaultTimeout is the default timeout for database operations\n")
	fmt.Fprintf(file, "var DefaultTimeout = 30 * time.Second\n\n")
	fmt.Fprintf(file, "// WithTimeout creates a context with timeout, using the default timeout if not specified\n")
	fmt.Fprintf(file, "func WithTimeout(ctx context.Context, timeout ...time.Duration) (context.Context, context.CancelFunc) {\n")
	fmt.Fprintf(file, "\tt := DefaultTimeout\n")
	fmt.Fprintf(file, "\tif len(timeout) > 0 && timeout[0] > 0 {\n")
	fmt.Fprintf(file, "\t\tt = timeout[0]\n")
	fmt.Fprintf(file, "\t}\n")
	fmt.Fprintf(file, "\treturn context.WithTimeout(ctx, t)\n")
	fmt.Fprintf(file, "}\n\n")
	fmt.Fprintf(file, "// WithQueryTimeout creates a context with timeout for queries (5 seconds)\n")
	fmt.Fprintf(file, "func WithQueryTimeout(ctx context.Context) (context.Context, context.CancelFunc) {\n")
	fmt.Fprintf(file, "\treturn context.WithTimeout(ctx, 5*time.Second)\n")
	fmt.Fprintf(file, "}\n\n")
	fmt.Fprintf(file, "// WithTransactionTimeout cria um contexto com timeout para transações (30 segundos)\n")
	fmt.Fprintf(file, "func WithTransactionTimeout(ctx context.Context) (context.Context, context.CancelFunc) {\n")
	fmt.Fprintf(file, "\treturn context.WithTimeout(ctx, 30*time.Second)\n")
	fmt.Fprintf(file, "}\n\n")
	fmt.Fprintf(file, "// WithMigrationTimeout cria um contexto com timeout para migrations (5 minutos)\n")
	fmt.Fprintf(file, "func WithMigrationTimeout(ctx context.Context) (context.Context, context.CancelFunc) {\n")
	fmt.Fprintf(file, "\treturn context.WithTimeout(ctx, 5*time.Minute)\n")
	fmt.Fprintf(file, "}\n")

	return nil
}

// generateBuilderErrors generates errors.go
func generateBuilderErrors(builderDir string) error {
	file, err := createGeneratedFile(filepath.Join(builderDir, "errors.go"), "builder")
	if err != nil {
		return err
	}
	defer file.Close()
	fmt.Fprintf(file, "import (\n")
	fmt.Fprintf(file, "\t\"fmt\"\n")
	fmt.Fprintf(file, "\t\"os\"\n")
	fmt.Fprintf(file, "\t\"strings\"\n")
	fmt.Fprintf(file, ")\n\n")
	fmt.Fprintf(file, "// ProductionMode indicates if we are in production mode (hides internal details)\n")
	fmt.Fprintf(file, "var ProductionMode = os.Getenv(\"ENV\") == \"production\" || os.Getenv(\"ENV\") == \"prod\"\n\n")
	fmt.Fprintf(file, "// SanitizeError sanitizes an error message to not expose internal information\n")
	fmt.Fprintf(file, "func SanitizeError(err error) error {\n")
	fmt.Fprintf(file, "\tif err == nil {\n")
	fmt.Fprintf(file, "\t\treturn nil\n")
	fmt.Fprintf(file, "\t}\n\n")
	fmt.Fprintf(file, "\tif !ProductionMode {\n")
	fmt.Fprintf(file, "\t\t// In development, return full error\n")
	fmt.Fprintf(file, "\t\treturn err\n")
	fmt.Fprintf(file, "\t}\n\n")
	fmt.Fprintf(file, "\terrMsg := err.Error()\n\n")
	fmt.Fprintf(file, "\t// Remove table and column names\n")
	fmt.Fprintf(file, "\terrMsg = sanitizeTableNames(errMsg)\n")
	fmt.Fprintf(file, "\terrMsg = sanitizeColumnNames(errMsg)\n")
	fmt.Fprintf(file, "\terrMsg = sanitizeSQLDetails(errMsg)\n\n")
	fmt.Fprintf(file, "\t// Return sanitized error\n")
	fmt.Fprintf(file, "\treturn fmt.Errorf(\"%%s\", errMsg)\n")
	fmt.Fprintf(file, "}\n\n")
	fmt.Fprintf(file, "// sanitizeTableNames removes table names from error messages\n")
	fmt.Fprintf(file, "func sanitizeTableNames(msg string) string {\n")
	fmt.Fprintf(file, "\t// Common patterns that may contain table names\n")
	fmt.Fprintf(file, "\tpatterns := []string{\n")
	fmt.Fprintf(file, "\t\t\"table\",\n")
	fmt.Fprintf(file, "\t\t\"relation\",\n")
	fmt.Fprintf(file, "\t\t\"FROM\",\n")
	fmt.Fprintf(file, "\t\t\"INTO\",\n")
	fmt.Fprintf(file, "\t\t\"UPDATE\",\n")
	fmt.Fprintf(file, "\t\t\"DELETE FROM\",\n")
	fmt.Fprintf(file, "\t}\n\n")
	fmt.Fprintf(file, "\tfor _, pattern := range patterns {\n")
	fmt.Fprintf(file, "\t\tif strings.Contains(strings.ToLower(msg), strings.ToLower(pattern)) {\n")
	fmt.Fprintf(file, "\t\t\treturn \"database operation failed\"\n")
	fmt.Fprintf(file, "\t\t}\n")
	fmt.Fprintf(file, "\t}\n\n")
	fmt.Fprintf(file, "\treturn msg\n")
	fmt.Fprintf(file, "}\n\n")
	fmt.Fprintf(file, "// sanitizeColumnNames removes column names from error messages\n")
	fmt.Fprintf(file, "func sanitizeColumnNames(msg string) string {\n")
	fmt.Fprintf(file, "\tpatterns := []string{\n")
	fmt.Fprintf(file, "\t\t\"column\",\n")
	fmt.Fprintf(file, "\t\t\"field\",\n")
	fmt.Fprintf(file, "\t\t\"SET\",\n")
	fmt.Fprintf(file, "\t\t\"WHERE\",\n")
	fmt.Fprintf(file, "\t}\n\n")
	fmt.Fprintf(file, "\tfor _, pattern := range patterns {\n")
	fmt.Fprintf(file, "\t\tif strings.Contains(strings.ToLower(msg), strings.ToLower(pattern)) {\n")
	fmt.Fprintf(file, "\t\t\treturn \"database operation failed\"\n")
	fmt.Fprintf(file, "\t\t}\n")
	fmt.Fprintf(file, "\t}\n\n")
	fmt.Fprintf(file, "\treturn msg\n")
	fmt.Fprintf(file, "}\n\n")
	fmt.Fprintf(file, "// sanitizeSQLDetails removes SQL details from error messages\n")
	fmt.Fprintf(file, "func sanitizeSQLDetails(msg string) string {\n")
	fmt.Fprintf(file, "\tif strings.Contains(strings.ToLower(msg), \"sql\") ||\n")
	fmt.Fprintf(file, "\t\tstrings.Contains(strings.ToLower(msg), \"syntax\") ||\n")
	fmt.Fprintf(file, "\t\tstrings.Contains(strings.ToLower(msg), \"constraint\") {\n")
	fmt.Fprintf(file, "\t\treturn \"database operation failed\"\n")
	fmt.Fprintf(file, "\t}\n\n")
	fmt.Fprintf(file, "\treturn msg\n")
	fmt.Fprintf(file, "}\n\n")
	fmt.Fprintf(file, "// WrapError wraps an error with a generic message in production\n")
	fmt.Fprintf(file, "func WrapError(err error, genericMsg string) error {\n")
	fmt.Fprintf(file, "\tif err == nil {\n")
	fmt.Fprintf(file, "\t\treturn nil\n")
	fmt.Fprintf(file, "\t}\n\n")
	fmt.Fprintf(file, "\tif ProductionMode {\n")
	fmt.Fprintf(file, "\t\treturn fmt.Errorf(\"%%s\", genericMsg)\n")
	fmt.Fprintf(file, "\t}\n\n")
	fmt.Fprintf(file, "\treturn fmt.Errorf(\"%%s: %%w\", genericMsg, err)\n")
	fmt.Fprintf(file, "}\n")

	return nil
}

// generateBuilderOptions generates options.go
func generateBuilderOptions(builderDir string) error {
	file, err := createGeneratedFile(filepath.Join(builderDir, "options.go"), "builder")
	if err != nil {
		return err
	}
	defer file.Close()
	fmt.Fprintf(file, "// QueryOptions defines options for FindMany queries, similar to Prisma's findMany options\n")
	fmt.Fprintf(file, "type QueryOptions struct {\n")
	fmt.Fprintf(file, "\t// Where conditions to filter records\n")
	fmt.Fprintf(file, "\tWhere Where\n\n")
	fmt.Fprintf(file, "\t// OrderBy defines sorting order\n")
	fmt.Fprintf(file, "\tOrderBy []OrderBy\n\n")
	fmt.Fprintf(file, "\t// Limit restricts the number of records returned\n")
	fmt.Fprintf(file, "\tLimit *int\n\n")
	fmt.Fprintf(file, "\t// Offset skips a number of records\n")
	fmt.Fprintf(file, "\tOffset *int\n")
	fmt.Fprintf(file, "}\n\n")
	fmt.Fprintf(file, "// OrderBy defines sorting for a single field\n")
	fmt.Fprintf(file, "type OrderBy struct {\n")
	fmt.Fprintf(file, "\t// Field name to sort by\n")
	fmt.Fprintf(file, "\tField string\n\n")
	fmt.Fprintf(file, "\t// Order direction: \"ASC\" or \"DESC\"\n")
	fmt.Fprintf(file, "\tOrder string\n")
	fmt.Fprintf(file, "}\n\n")
	fmt.Fprintf(file, "// Ptr is a helper function to create a pointer to an int\n")
	fmt.Fprintf(file, "func Ptr(i int) *int {\n")
	fmt.Fprintf(file, "\treturn &i\n")
	fmt.Fprintf(file, "}\n")

	return nil
}

// generateBuilderWhere generates where.go
func generateBuilderWhere(builderDir string) error {
	file, err := createGeneratedFile(filepath.Join(builderDir, "where.go"), "builder")
	if err != nil {
		return err
	}
	defer file.Close()
	fmt.Fprintf(file, "// Where represents a map of field conditions for queries, similar to Prisma's where clause.\n")
	fmt.Fprintf(file, "// Each key is a field name, and the value can be either:\n")
	fmt.Fprintf(file, "//   - A direct value for equality comparison\n")
	fmt.Fprintf(file, "//   - A WhereOperator for complex comparisons\n")
	fmt.Fprintf(file, "//   - nil for IS NULL checks\n")
	fmt.Fprintf(file, "//\n")
	fmt.Fprintf(file, "// Example:\n")
	fmt.Fprintf(file, "//\n")
	fmt.Fprintf(file, "//\twhere := builder.Where{\n")
	fmt.Fprintf(file, "//\t    \"email\": \"user@example.com\",\n")
	fmt.Fprintf(file, "//\t    \"age\": builder.Gte(18),\n")
	fmt.Fprintf(file, "//\t    \"status\": builder.In(\"active\", \"pending\"),\n")
	fmt.Fprintf(file, "//\t    \"deleted_at\": nil,\n")
	fmt.Fprintf(file, "//\t}\n")
	fmt.Fprintf(file, "type Where map[string]interface{}\n\n")
	fmt.Fprintf(file, "// WhereOperator represents a conditional operator with its value\n")
	fmt.Fprintf(file, "type WhereOperator struct {\n")
	fmt.Fprintf(file, "\top    string\n")
	fmt.Fprintf(file, "\tvalue interface{}\n")
	fmt.Fprintf(file, "}\n\n")
	fmt.Fprintf(file, "// Comparison operators for building WHERE clauses\n\n")
	fmt.Fprintf(file, "// Equals creates an equality operator (=)\n")
	fmt.Fprintf(file, "func Equals(value interface{}) WhereOperator {\n")
	fmt.Fprintf(file, "\treturn WhereOperator{op: \"=\", value: value}\n")
	fmt.Fprintf(file, "}\n\n")
	fmt.Fprintf(file, "// NotEquals creates a not equal operator (!=)\n")
	fmt.Fprintf(file, "func NotEquals(value interface{}) WhereOperator {\n")
	fmt.Fprintf(file, "\treturn WhereOperator{op: \"!=\", value: value}\n")
	fmt.Fprintf(file, "}\n\n")
	fmt.Fprintf(file, "// Gt creates a greater than operator (>)\n")
	fmt.Fprintf(file, "func Gt(value interface{}) WhereOperator {\n")
	fmt.Fprintf(file, "\treturn WhereOperator{op: \">\", value: value}\n")
	fmt.Fprintf(file, "}\n\n")
	fmt.Fprintf(file, "// Gte creates a greater than or equal operator (>=)\n")
	fmt.Fprintf(file, "func Gte(value interface{}) WhereOperator {\n")
	fmt.Fprintf(file, "\treturn WhereOperator{op: \">=\", value: value}\n")
	fmt.Fprintf(file, "}\n\n")
	fmt.Fprintf(file, "// Lt creates a less than operator (<)\n")
	fmt.Fprintf(file, "func Lt(value interface{}) WhereOperator {\n")
	fmt.Fprintf(file, "\treturn WhereOperator{op: \"<\", value: value}\n")
	fmt.Fprintf(file, "}\n\n")
	fmt.Fprintf(file, "// Lte creates a less than or equal operator (<=)\n")
	fmt.Fprintf(file, "func Lte(value interface{}) WhereOperator {\n")
	fmt.Fprintf(file, "\treturn WhereOperator{op: \"<=\", value: value}\n")
	fmt.Fprintf(file, "}\n\n")
	fmt.Fprintf(file, "// Like creates a LIKE operator (case-sensitive pattern matching)\n")
	fmt.Fprintf(file, "func Like(value string) WhereOperator {\n")
	fmt.Fprintf(file, "\treturn WhereOperator{op: \"LIKE\", value: value}\n")
	fmt.Fprintf(file, "}\n\n")
	fmt.Fprintf(file, "// ILike creates an ILIKE operator (case-insensitive pattern matching)\n")
	fmt.Fprintf(file, "func ILike(value string) WhereOperator {\n")
	fmt.Fprintf(file, "\treturn WhereOperator{op: \"ILIKE\", value: value}\n")
	fmt.Fprintf(file, "}\n\n")
	fmt.Fprintf(file, "// In creates an IN operator for matching any value in a list\n")
	fmt.Fprintf(file, "func In(values ...interface{}) WhereOperator {\n")
	fmt.Fprintf(file, "\treturn WhereOperator{op: \"IN\", value: values}\n")
	fmt.Fprintf(file, "}\n\n")
	fmt.Fprintf(file, "// NotIn creates a NOT IN operator\n")
	fmt.Fprintf(file, "func NotIn(values ...interface{}) WhereOperator {\n")
	fmt.Fprintf(file, "\treturn WhereOperator{op: \"NOT IN\", value: values}\n")
	fmt.Fprintf(file, "}\n\n")
	fmt.Fprintf(file, "// IsNull creates an IS NULL operator\n")
	fmt.Fprintf(file, "func IsNull() WhereOperator {\n")
	fmt.Fprintf(file, "\treturn WhereOperator{op: \"IS NULL\", value: nil}\n")
	fmt.Fprintf(file, "}\n\n")
	fmt.Fprintf(file, "// IsNotNull creates an IS NOT NULL operator\n")
	fmt.Fprintf(file, "func IsNotNull() WhereOperator {\n")
	fmt.Fprintf(file, "\treturn WhereOperator{op: \"IS NOT NULL\", value: nil}\n")
	fmt.Fprintf(file, "}\n\n")
	fmt.Fprintf(file, "// Contains creates a LIKE operator with %%value%% pattern (case-sensitive)\n")
	fmt.Fprintf(file, "func Contains(value string) WhereOperator {\n")
	fmt.Fprintf(file, "\treturn WhereOperator{op: \"LIKE\", value: \"%%\" + value + \"%%\"}\n")
	fmt.Fprintf(file, "}\n\n")
	fmt.Fprintf(file, "// StartsWith creates a LIKE operator with value%% pattern (case-sensitive)\n")
	fmt.Fprintf(file, "func StartsWith(value string) WhereOperator {\n")
	fmt.Fprintf(file, "\treturn WhereOperator{op: \"LIKE\", value: value + \"%%\"}\n")
	fmt.Fprintf(file, "}\n\n")
	fmt.Fprintf(file, "// EndsWith creates a LIKE operator with %%value pattern (case-sensitive)\n")
	fmt.Fprintf(file, "func EndsWith(value string) WhereOperator {\n")
	fmt.Fprintf(file, "\treturn WhereOperator{op: \"LIKE\", value: \"%%\" + value}\n")
	fmt.Fprintf(file, "}\n\n")
	fmt.Fprintf(file, "// ContainsInsensitive creates an ILIKE operator with %%value%% pattern (case-insensitive)\n")
	fmt.Fprintf(file, "func ContainsInsensitive(value string) WhereOperator {\n")
	fmt.Fprintf(file, "\treturn WhereOperator{op: \"ILIKE\", value: \"%%\" + value + \"%%\"}\n")
	fmt.Fprintf(file, "}\n\n")
	fmt.Fprintf(file, "// StartsWithInsensitive creates an ILIKE operator with value%% pattern (case-insensitive)\n")
	fmt.Fprintf(file, "func StartsWithInsensitive(value string) WhereOperator {\n")
	fmt.Fprintf(file, "\treturn WhereOperator{op: \"ILIKE\", value: value + \"%%\"}\n")
	fmt.Fprintf(file, "}\n\n")
	fmt.Fprintf(file, "// EndsWithInsensitive creates an ILIKE operator with %%value pattern (case-insensitive)\n")
	fmt.Fprintf(file, "func EndsWithInsensitive(value string) WhereOperator {\n")
	fmt.Fprintf(file, "\treturn WhereOperator{op: \"ILIKE\", value: \"%%\" + value}\n")
	fmt.Fprintf(file, "}\n\n")
	fmt.Fprintf(file, "// Has checks if an array/JSON field contains a value\n")
	fmt.Fprintf(file, "func Has(value interface{}) WhereOperator {\n")
	fmt.Fprintf(file, "\treturn WhereOperator{op: \"HAS\", value: value}\n")
	fmt.Fprintf(file, "}\n\n")
	fmt.Fprintf(file, "// HasEvery checks if an array/JSON field contains all values\n")
	fmt.Fprintf(file, "func HasEvery(values ...interface{}) WhereOperator {\n")
	fmt.Fprintf(file, "\treturn WhereOperator{op: \"HAS_EVERY\", value: values}\n")
	fmt.Fprintf(file, "}\n\n")
	fmt.Fprintf(file, "// HasSome checks if an array/JSON field contains any value\n")
	fmt.Fprintf(file, "func HasSome(values ...interface{}) WhereOperator {\n")
	fmt.Fprintf(file, "\treturn WhereOperator{op: \"HAS_SOME\", value: values}\n")
	fmt.Fprintf(file, "}\n\n")
	fmt.Fprintf(file, "// IsEmpty checks if an array/JSON field is empty\n")
	fmt.Fprintf(file, "func IsEmpty() WhereOperator {\n")
	fmt.Fprintf(file, "\treturn WhereOperator{op: \"IS_EMPTY\", value: nil}\n")
	fmt.Fprintf(file, "}\n\n")
	fmt.Fprintf(file, "// GetOp returns the operator string (exported for internal use)\n")
	fmt.Fprintf(file, "func (wo WhereOperator) GetOp() string {\n")
	fmt.Fprintf(file, "\treturn wo.op\n")
	fmt.Fprintf(file, "}\n\n")
	fmt.Fprintf(file, "// GetValue returns the operator value (exported for internal use)\n")
	fmt.Fprintf(file, "func (wo WhereOperator) GetValue() interface{} {\n")
	fmt.Fprintf(file, "\treturn wo.value\n")
	fmt.Fprintf(file, "}\n")

	return nil
}
