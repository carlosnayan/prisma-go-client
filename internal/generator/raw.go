package generator

import (
	"fmt"
	"os"
	"path/filepath"
)

// GenerateRaw generates a standalone raw package in the output directory
// This package has no external dependencies on github.com/carlosnayan/prisma-go-client
func GenerateRaw(outputDir string) error {
	rawDir := filepath.Join(outputDir, "raw")
	if err := os.MkdirAll(rawDir, 0755); err != nil {
		return fmt.Errorf("erro ao criar diret√≥rio raw: %w", err)
	}

	rawFile := filepath.Join(rawDir, "raw.go")
	file, err := os.Create(rawFile)
	if err != nil {
		return fmt.Errorf("erro ao criar arquivo raw.go: %w", err)
	}
	defer file.Close()

	// Header
	fmt.Fprintf(file, "// Code generated by prisma generate. DO NOT EDIT.\n")
	fmt.Fprintf(file, "package raw\n\n")

	// Imports - only stdlib
	fmt.Fprintf(file, "import (\n")
	fmt.Fprintf(file, "\t\"context\"\n")
	fmt.Fprintf(file, "\t\"fmt\"\n")
	fmt.Fprintf(file, ")\n\n")

	// Inline interfaces from internal/driver
	fmt.Fprintf(file, "// DB is the main database interface that abstracts different database drivers\n")
	fmt.Fprintf(file, "type DB interface {\n")
	fmt.Fprintf(file, "\t// Exec executes a query that doesn't return rows\n")
	fmt.Fprintf(file, "\tExec(ctx context.Context, sql string, args ...interface{}) (Result, error)\n\n")
	fmt.Fprintf(file, "\t// Query executes a query that returns multiple rows\n")
	fmt.Fprintf(file, "\tQuery(ctx context.Context, sql string, args ...interface{}) (Rows, error)\n\n")
	fmt.Fprintf(file, "\t// QueryRow executes a query that returns a single row\n")
	fmt.Fprintf(file, "\tQueryRow(ctx context.Context, sql string, args ...interface{}) Row\n")
	fmt.Fprintf(file, "}\n\n")

	fmt.Fprintf(file, "// Result represents the result of an Exec operation\n")
	fmt.Fprintf(file, "type Result interface {\n")
	fmt.Fprintf(file, "\t// RowsAffected returns the number of rows affected\n")
	fmt.Fprintf(file, "\tRowsAffected() int64\n")
	fmt.Fprintf(file, "}\n\n")

	fmt.Fprintf(file, "// Rows represents a set of query results\n")
	fmt.Fprintf(file, "type Rows interface {\n")
	fmt.Fprintf(file, "\t// Close closes the rows iterator\n")
	fmt.Fprintf(file, "\tClose()\n\n")
	fmt.Fprintf(file, "\t// Err returns any error that occurred during iteration\n")
	fmt.Fprintf(file, "\tErr() error\n\n")
	fmt.Fprintf(file, "\t// Next prepares the next result row for reading\n")
	fmt.Fprintf(file, "\tNext() bool\n\n")
	fmt.Fprintf(file, "\t// Scan copies the columns in the current row into the values pointed at by dest\n")
	fmt.Fprintf(file, "\tScan(dest ...interface{}) error\n")
	fmt.Fprintf(file, "}\n\n")

	fmt.Fprintf(file, "// Row represents a single row result\n")
	fmt.Fprintf(file, "type Row interface {\n")
	fmt.Fprintf(file, "\t// Scan copies the columns in the current row into the values pointed at by dest\n")
	fmt.Fprintf(file, "\tScan(dest ...interface{}) error\n")
	fmt.Fprintf(file, "}\n\n")

	// DBTX alias for backward compatibility
	fmt.Fprintf(file, "// DBTX is an alias for DB for backward compatibility\n")
	fmt.Fprintf(file, "type DBTX = DB\n\n")

	// Executor struct and methods
	fmt.Fprintf(file, "// Executor provides methods for executing raw SQL queries\n")
	fmt.Fprintf(file, "type Executor struct {\n")
	fmt.Fprintf(file, "\tdb DB\n")
	fmt.Fprintf(file, "}\n\n")

	fmt.Fprintf(file, "// New creates a new raw query executor\n")
	fmt.Fprintf(file, "// Accepts both raw.DB and builder.DB (compatible interfaces)\n")
	fmt.Fprintf(file, "func New(db interface{}) *Executor {\n")
	fmt.Fprintf(file, "\t// Try direct cast to raw.DB first\n")
	fmt.Fprintf(file, "\tif rawDB, ok := db.(DB); ok {\n")
	fmt.Fprintf(file, "\t\treturn &Executor{db: rawDB}\n")
	fmt.Fprintf(file, "\t}\n")
	fmt.Fprintf(file, "\t// Try builder.DB - create adapter\n")
	fmt.Fprintf(file, "\tif builderDB, ok := db.(interface {\n")
	fmt.Fprintf(file, "\t\tExec(ctx context.Context, sql string, args ...interface{}) (interface{}, error)\n")
	fmt.Fprintf(file, "\t\tQuery(ctx context.Context, sql string, args ...interface{}) (interface{}, error)\n")
	fmt.Fprintf(file, "\t\tQueryRow(ctx context.Context, sql string, args ...interface{}) interface{}\n")
	fmt.Fprintf(file, "\t}); ok {\n")
	fmt.Fprintf(file, "\t\treturn &Executor{db: &builderDBAdapter{db: builderDB}}\n")
	fmt.Fprintf(file, "\t}\n")
	fmt.Fprintf(file, "\tpanic(\"db must implement raw.DB or builder.DB\")\n")
	fmt.Fprintf(file, "}\n\n")

	fmt.Fprintf(file, "// builderDBAdapter adapts builder.DB to raw.DB\n")
	fmt.Fprintf(file, "type builderDBAdapter struct {\n")
	fmt.Fprintf(file, "\tdb interface {\n")
	fmt.Fprintf(file, "\t\tExec(ctx context.Context, sql string, args ...interface{}) (interface{}, error)\n")
	fmt.Fprintf(file, "\t\tQuery(ctx context.Context, sql string, args ...interface{}) (interface{}, error)\n")
	fmt.Fprintf(file, "\t\tQueryRow(ctx context.Context, sql string, args ...interface{}) interface{}\n")
	fmt.Fprintf(file, "\t}\n")
	fmt.Fprintf(file, "}\n\n")

	fmt.Fprintf(file, "func (a *builderDBAdapter) Exec(ctx context.Context, sql string, args ...interface{}) (Result, error) {\n")
	fmt.Fprintf(file, "\tresult, err := a.db.Exec(ctx, sql, args...)\n")
	fmt.Fprintf(file, "\tif err != nil {\n")
	fmt.Fprintf(file, "\t\treturn nil, err\n")
	fmt.Fprintf(file, "\t}\n")
	fmt.Fprintf(file, "\tif r, ok := result.(Result); ok {\n")
	fmt.Fprintf(file, "\t\treturn r, nil\n")
	fmt.Fprintf(file, "\t}\n")
	fmt.Fprintf(file, "\treturn &resultAdapter{result: result}, nil\n")
	fmt.Fprintf(file, "}\n\n")

	fmt.Fprintf(file, "func (a *builderDBAdapter) Query(ctx context.Context, sql string, args ...interface{}) (Rows, error) {\n")
	fmt.Fprintf(file, "\trows, err := a.db.Query(ctx, sql, args...)\n")
	fmt.Fprintf(file, "\tif err != nil {\n")
	fmt.Fprintf(file, "\t\treturn nil, err\n")
	fmt.Fprintf(file, "\t}\n")
	fmt.Fprintf(file, "\tif r, ok := rows.(Rows); ok {\n")
	fmt.Fprintf(file, "\t\treturn r, nil\n")
	fmt.Fprintf(file, "\t}\n")
	fmt.Fprintf(file, "\treturn &rowsAdapter{rows: rows}, nil\n")
	fmt.Fprintf(file, "}\n\n")

	fmt.Fprintf(file, "func (a *builderDBAdapter) QueryRow(ctx context.Context, sql string, args ...interface{}) Row {\n")
	fmt.Fprintf(file, "\trow := a.db.QueryRow(ctx, sql, args...)\n")
	fmt.Fprintf(file, "\tif r, ok := row.(Row); ok {\n")
	fmt.Fprintf(file, "\t\treturn r\n")
	fmt.Fprintf(file, "\t}\n")
	fmt.Fprintf(file, "\treturn &rowAdapter{row: row}\n")
	fmt.Fprintf(file, "}\n\n")

	fmt.Fprintf(file, "// Adapters for result types\n")
	fmt.Fprintf(file, "type resultAdapter struct {\n")
	fmt.Fprintf(file, "\tresult interface{}\n")
	fmt.Fprintf(file, "}\n\n")

	fmt.Fprintf(file, "func (r *resultAdapter) RowsAffected() int64 {\n")
	fmt.Fprintf(file, "\tif res, ok := r.result.(interface{ RowsAffected() int64 }); ok {\n")
	fmt.Fprintf(file, "\t\treturn res.RowsAffected()\n")
	fmt.Fprintf(file, "\t}\n")
	fmt.Fprintf(file, "\treturn 0\n")
	fmt.Fprintf(file, "}\n\n")

	fmt.Fprintf(file, "type rowsAdapter struct {\n")
	fmt.Fprintf(file, "\trows interface{}\n")
	fmt.Fprintf(file, "}\n\n")

	fmt.Fprintf(file, "func (r *rowsAdapter) Close() {\n")
	fmt.Fprintf(file, "\tif closer, ok := r.rows.(interface{ Close() }); ok {\n")
	fmt.Fprintf(file, "\t\tcloser.Close()\n")
	fmt.Fprintf(file, "\t}\n")
	fmt.Fprintf(file, "}\n\n")

	fmt.Fprintf(file, "func (r *rowsAdapter) Err() error {\n")
	fmt.Fprintf(file, "\tif errer, ok := r.rows.(interface{ Err() error }); ok {\n")
	fmt.Fprintf(file, "\t\treturn errer.Err()\n")
	fmt.Fprintf(file, "\t}\n")
	fmt.Fprintf(file, "\treturn nil\n")
	fmt.Fprintf(file, "}\n\n")

	fmt.Fprintf(file, "func (r *rowsAdapter) Next() bool {\n")
	fmt.Fprintf(file, "\tif next, ok := r.rows.(interface{ Next() bool }); ok {\n")
	fmt.Fprintf(file, "\t\treturn next.Next()\n")
	fmt.Fprintf(file, "\t}\n")
	fmt.Fprintf(file, "\treturn false\n")
	fmt.Fprintf(file, "}\n\n")

	fmt.Fprintf(file, "func (r *rowsAdapter) Scan(dest ...interface{}) error {\n")
	fmt.Fprintf(file, "\tif scanner, ok := r.rows.(interface{ Scan(...interface{}) error }); ok {\n")
	fmt.Fprintf(file, "\t\treturn scanner.Scan(dest...)\n")
	fmt.Fprintf(file, "\t}\n")
	fmt.Fprintf(file, "\treturn fmt.Errorf(\"rows does not implement Scan\")\n")
	fmt.Fprintf(file, "}\n\n")

	fmt.Fprintf(file, "type rowAdapter struct {\n")
	fmt.Fprintf(file, "\trow interface{}\n")
	fmt.Fprintf(file, "}\n\n")

	fmt.Fprintf(file, "func (r *rowAdapter) Scan(dest ...interface{}) error {\n")
	fmt.Fprintf(file, "\tif scanner, ok := r.row.(interface{ Scan(...interface{}) error }); ok {\n")
	fmt.Fprintf(file, "\t\treturn scanner.Scan(dest...)\n")
	fmt.Fprintf(file, "\t}\n")
	fmt.Fprintf(file, "\treturn fmt.Errorf(\"row does not implement Scan\")\n")
	fmt.Fprintf(file, "}\n\n")

	fmt.Fprintf(file, "// Query executes a raw SQL query that returns multiple rows\n")
	fmt.Fprintf(file, "//\n")
	fmt.Fprintf(file, "// Example:\n")
	fmt.Fprintf(file, "//\n")
	fmt.Fprintf(file, "//\trows, err := executor.Query(ctx, `\n")
	fmt.Fprintf(file, "//\t    SELECT u.*, t.tenant_name\n")
	fmt.Fprintf(file, "//\t    FROM users u\n")
	fmt.Fprintf(file, "//\t    JOIN tenants t ON u.id_tenant = t.id_tenant\n")
	fmt.Fprintf(file, "//\t    WHERE u.deleted_at IS NULL AND t.id_tenant = $1\n")
	fmt.Fprintf(file, "//\t`, tenantId)\n")
	fmt.Fprintf(file, "func (e *Executor) Query(ctx context.Context, sql string, args ...interface{}) (Rows, error) {\n")
	fmt.Fprintf(file, "\treturn e.db.Query(ctx, sql, args...)\n")
	fmt.Fprintf(file, "}\n\n")

	fmt.Fprintf(file, "// QueryRow executes a raw SQL query that returns a single row\n")
	fmt.Fprintf(file, "//\n")
	fmt.Fprintf(file, "// Example:\n")
	fmt.Fprintf(file, "//\n")
	fmt.Fprintf(file, "//\trow := executor.QueryRow(ctx, `\n")
	fmt.Fprintf(file, "//\t    SELECT COUNT(*) as total,\n")
	fmt.Fprintf(file, "//\t           COUNT(CASE WHEN enabled = true THEN 1 END) as enabled_count\n")
	fmt.Fprintf(file, "//\t    FROM users\n")
	fmt.Fprintf(file, "//\t    WHERE id_tenant = $1\n")
	fmt.Fprintf(file, "//\t`, tenantId)\n")
	fmt.Fprintf(file, "//\n")
	fmt.Fprintf(file, "//\tvar total, enabled int\n")
	fmt.Fprintf(file, "//\terr := row.Scan(&total, &enabled)\n")
	fmt.Fprintf(file, "func (e *Executor) QueryRow(ctx context.Context, sql string, args ...interface{}) Row {\n")
	fmt.Fprintf(file, "\treturn e.db.QueryRow(ctx, sql, args...)\n")
	fmt.Fprintf(file, "}\n\n")

	fmt.Fprintf(file, "// Exec executes a raw SQL command (INSERT, UPDATE, DELETE)\n")
	fmt.Fprintf(file, "//\n")
	fmt.Fprintf(file, "// Example:\n")
	fmt.Fprintf(file, "//\n")
	fmt.Fprintf(file, "//\tresult, err := executor.Exec(ctx, `\n")
	fmt.Fprintf(file, "//\t    UPDATE users\n")
	fmt.Fprintf(file, "//\t    SET last_login_at = NOW()\n")
	fmt.Fprintf(file, "//\t    WHERE id_user = $1\n")
	fmt.Fprintf(file, "//\t`, userId)\n")
	fmt.Fprintf(file, "func (e *Executor) Exec(ctx context.Context, sql string, args ...interface{}) (Result, error) {\n")
	fmt.Fprintf(file, "\treturn e.db.Exec(ctx, sql, args...)\n")
	fmt.Fprintf(file, "}\n")

	return nil
}
