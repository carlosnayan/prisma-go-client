package generator

import (
	"fmt"
	"os"
	"path/filepath"
)

// generateBuilderFluent generates fluent.go with Query struct
// This is a large file (1420+ lines), so we inline the entire builder/fluent.go
func generateBuilderFluent(builderDir string, provider string, utilsPath string) error {
	file, err := createGeneratedFile(filepath.Join(builderDir, "fluent.go"), "builder")
	if err != nil {
		return err
	}
	defer file.Close()
	fmt.Fprintf(file, "import (\n")
	fmt.Fprintf(file, "\t\"context\"\n")
	fmt.Fprintf(file, "\t\"encoding/json\"\n")
	fmt.Fprintf(file, "\t\"fmt\"\n")
	fmt.Fprintf(file, "\t\"reflect\"\n")
	fmt.Fprintf(file, "\t\"strings\"\n")
	fmt.Fprintf(file, "\t\"time\"\n")
	fmt.Fprintf(file, "\t%q\n", utilsPath)
	fmt.Fprintf(file, ")\n\n")

	// Generate logger inline (simplified version)
	generateLoggerInline(file)

	// Generate Query struct and types
	generateQueryStruct(file)

	// Generate NewQuery and setters
	generateQueryConstructors(file, provider)

	// Generate Where methods
	generateQueryWhereMethods(file)

	// Generate query building methods (Select, Order, Limit, etc.)
	generateQueryBuilderMethods(file)

	// Generate execution methods (First, Find, Count, Create, Update, Delete)
	generateQueryExecutionMethods(file)

	// Generate query building helpers
	generateQueryBuildHelpers(file)

	// Generate scanning helpers
	generateQueryScanHelpers(file)

	// Generate fulltext search helpers
	generateFulltextHelpers(file)

	// Generate logging helpers
	generateLoggingHelpers(file)

	// Generate transaction helpers
	generateTransactionHelpers(file)

	return nil
}

// generateTransactionHelpers generates Transaction struct and methods
func generateTransactionHelpers(file *os.File) {
	fmt.Fprintf(file, "// Transaction represents a database transaction\n")
	fmt.Fprintf(file, "type Transaction struct {\n")
	fmt.Fprintf(file, "\ttx Tx\n")
	fmt.Fprintf(file, "}\n\n")

	fmt.Fprintf(file, "// TransactionFunc is a function that executes within a transaction\n")
	fmt.Fprintf(file, "type TransactionFunc func(*Transaction) error\n\n")

	fmt.Fprintf(file, "// BeginTransaction starts a new database transaction\n")
	fmt.Fprintf(file, "func BeginTransaction(ctx context.Context, db DBTX) (*Transaction, error) {\n")
	fmt.Fprintf(file, "\ttx, err := db.Begin(ctx)\n")
	fmt.Fprintf(file, "\tif err != nil {\n")
	fmt.Fprintf(file, "\t\treturn nil, WrapError(err, \"failed to begin transaction\")\n")
	fmt.Fprintf(file, "\t}\n")
	fmt.Fprintf(file, "\treturn &Transaction{tx: tx}, nil\n")
	fmt.Fprintf(file, "}\n\n")

	fmt.Fprintf(file, "// Commit commits the transaction\n")
	fmt.Fprintf(file, "func (t *Transaction) Commit(ctx context.Context) error {\n")
	fmt.Fprintf(file, "\treturn t.tx.Commit(ctx)\n")
	fmt.Fprintf(file, "}\n\n")

	fmt.Fprintf(file, "// Rollback rolls back the transaction\n")
	fmt.Fprintf(file, "func (t *Transaction) Rollback(ctx context.Context) error {\n")
	fmt.Fprintf(file, "\treturn t.tx.Rollback(ctx)\n")
	fmt.Fprintf(file, "}\n\n")

	fmt.Fprintf(file, "// Query creates a new Query using the transaction\n")
	fmt.Fprintf(file, "func (t *Transaction) Query(table string, columns []string) *Query {\n")
	fmt.Fprintf(file, "\ttxAdapter := &txDBAdapter{tx: t.tx}\n")
	fmt.Fprintf(file, "\treturn NewQuery(txAdapter, table, columns)\n")
	fmt.Fprintf(file, "}\n\n")

	fmt.Fprintf(file, "// DB returns a DB adapter from the transaction\n")
	fmt.Fprintf(file, "func (t *Transaction) DB() DB {\n")
	fmt.Fprintf(file, "\treturn &txDBAdapter{tx: t.tx}\n")
	fmt.Fprintf(file, "}\n\n")

	fmt.Fprintf(file, "// txDBAdapter adapts Tx to DB\n")
	fmt.Fprintf(file, "type txDBAdapter struct {\n")
	fmt.Fprintf(file, "\ttx Tx\n")
	fmt.Fprintf(file, "}\n\n")

	fmt.Fprintf(file, "func (a *txDBAdapter) Exec(ctx context.Context, sql string, args ...interface{}) (Result, error) {\n")
	fmt.Fprintf(file, "\treturn a.tx.Exec(ctx, sql, args...)\n")
	fmt.Fprintf(file, "}\n\n")

	fmt.Fprintf(file, "func (a *txDBAdapter) Query(ctx context.Context, sql string, args ...interface{}) (Rows, error) {\n")
	fmt.Fprintf(file, "\treturn a.tx.Query(ctx, sql, args...)\n")
	fmt.Fprintf(file, "}\n\n")

	fmt.Fprintf(file, "func (a *txDBAdapter) QueryRow(ctx context.Context, sql string, args ...interface{}) Row {\n")
	fmt.Fprintf(file, "\treturn a.tx.QueryRow(ctx, sql, args...)\n")
	fmt.Fprintf(file, "}\n\n")

	fmt.Fprintf(file, "func (a *txDBAdapter) Begin(ctx context.Context) (Tx, error) {\n")
	fmt.Fprintf(file, "\treturn nil, fmt.Errorf(\"cannot begin a transaction within a transaction\")\n")
	fmt.Fprintf(file, "}\n\n")

	fmt.Fprintf(file, "// ExecuteTransaction executes a function within a transaction\n")
	fmt.Fprintf(file, "func ExecuteTransaction(ctx context.Context, db DBTX, fn TransactionFunc) error {\n")
	fmt.Fprintf(file, "\ttx, err := BeginTransaction(ctx, db)\n")
	fmt.Fprintf(file, "\tif err != nil {\n")
	fmt.Fprintf(file, "\t\treturn err\n")
	fmt.Fprintf(file, "\t}\n\n")
	fmt.Fprintf(file, "\tdefer func() {\n")
	fmt.Fprintf(file, "\t\tif r := recover(); r != nil {\n")
	fmt.Fprintf(file, "\t\t\t_ = tx.Rollback(ctx)\n")
	fmt.Fprintf(file, "\t\t\tpanic(r)\n")
	fmt.Fprintf(file, "\t\t}\n")
	fmt.Fprintf(file, "\t}()\n\n")
	fmt.Fprintf(file, "\tif err := fn(tx); err != nil {\n")
	fmt.Fprintf(file, "\t\t_ = tx.Rollback(ctx)\n")
	fmt.Fprintf(file, "\t\treturn err\n")
	fmt.Fprintf(file, "\t}\n\n")
	fmt.Fprintf(file, "\treturn tx.Commit(ctx)\n")
	fmt.Fprintf(file, "}\n\n")
}

// generateLoggerInline generates a simplified logger inline
func generateLoggerInline(file *os.File) {
	fmt.Fprintf(file, "// Logger is a simplified logger for standalone builder\n")
	fmt.Fprintf(file, "type Logger struct {\n")
	fmt.Fprintf(file, "\tlevels   map[string]bool\n")
	fmt.Fprintf(file, "\tqueryLog bool\n")
	fmt.Fprintf(file, "}\n\n")

	fmt.Fprintf(file, "var defaultLogger = &Logger{\n")
	fmt.Fprintf(file, "\tlevels:   make(map[string]bool),\n")
	fmt.Fprintf(file, "\tqueryLog: false,\n")
	fmt.Fprintf(file, "}\n\n")

	fmt.Fprintf(file, "// GetDefaultLogger returns the default logger\n")
	fmt.Fprintf(file, "func GetDefaultLogger() *Logger {\n")
	fmt.Fprintf(file, "\treturn defaultLogger\n")
	fmt.Fprintf(file, "}\n\n")

	fmt.Fprintf(file, "// Query logs a query SQL\n")
	fmt.Fprintf(file, "func (l *Logger) Query(query string, args []interface{}, duration time.Duration) {\n")
	fmt.Fprintf(file, "\tif !l.queryLog || !l.levels[\"query\"] {\n")
	fmt.Fprintf(file, "\t\treturn\n")
	fmt.Fprintf(file, "\t}\n")
	fmt.Fprintf(file, "\ttimestamp := time.Now().Format(\"2006-01-02 15:04:05\")\n")
	fmt.Fprintf(file, "\tfmt.Printf(\"[%%s] [QUERY] %%s (took %%v)\\n\", timestamp, query, duration)\n")
	fmt.Fprintf(file, "}\n\n")

	fmt.Fprintf(file, "// Info logs an info message\n")
	fmt.Fprintf(file, "func (l *Logger) Info(format string, args ...interface{}) {\n")
	fmt.Fprintf(file, "\tif !l.levels[\"info\"] {\n")
	fmt.Fprintf(file, "\t\treturn\n")
	fmt.Fprintf(file, "\t}\n")
	fmt.Fprintf(file, "\ttimestamp := time.Now().Format(\"2006-01-02 15:04:05\")\n")
	fmt.Fprintf(file, "\tfmt.Printf(\"[%%s] [INFO] %%s\\n\", timestamp, fmt.Sprintf(format, args...))\n")
	fmt.Fprintf(file, "}\n\n")

	fmt.Fprintf(file, "// Warn logs a warning\n")
	fmt.Fprintf(file, "func (l *Logger) Warn(format string, args ...interface{}) {\n")
	fmt.Fprintf(file, "\tif !l.levels[\"warn\"] {\n")
	fmt.Fprintf(file, "\t\treturn\n")
	fmt.Fprintf(file, "\t}\n")
	fmt.Fprintf(file, "\ttimestamp := time.Now().Format(\"2006-01-02 15:04:05\")\n")
	fmt.Fprintf(file, "\tfmt.Printf(\"[%%s] [WARN] %%s\\n\", timestamp, fmt.Sprintf(format, args...))\n")
	fmt.Fprintf(file, "}\n\n")

	fmt.Fprintf(file, "// Error logs an error\n")
	fmt.Fprintf(file, "func (l *Logger) Error(format string, args ...interface{}) {\n")
	fmt.Fprintf(file, "\tif !l.levels[\"error\"] {\n")
	fmt.Fprintf(file, "\t\treturn\n")
	fmt.Fprintf(file, "\t}\n")
	fmt.Fprintf(file, "\ttimestamp := time.Now().Format(\"2006-01-02 15:04:05\")\n")
	fmt.Fprintf(file, "\tfmt.Printf(\"[%%s] [ERROR] %%s\\n\", timestamp, fmt.Sprintf(format, args...))\n")
	fmt.Fprintf(file, "}\n\n")

	fmt.Fprintf(file, "// SetLogLevels configures log levels\n")
	fmt.Fprintf(file, "func SetLogLevels(levels []string) {\n")
	fmt.Fprintf(file, "\tdefaultLogger.levels = make(map[string]bool)\n")
	fmt.Fprintf(file, "\tdefaultLogger.queryLog = false\n")
	fmt.Fprintf(file, "\tfor _, level := range levels {\n")
	fmt.Fprintf(file, "\t\tlevelLower := strings.ToLower(strings.TrimSpace(level))\n")
	fmt.Fprintf(file, "\t\tdefaultLogger.levels[levelLower] = true\n")
	fmt.Fprintf(file, "\t\tif levelLower == \"query\" {\n")
	fmt.Fprintf(file, "\t\t\tdefaultLogger.queryLog = true\n")
	fmt.Fprintf(file, "\t\t}\n")
	fmt.Fprintf(file, "\t}\n")
	fmt.Fprintf(file, "}\n\n")
}

// generateQueryStruct generates the Query struct and related types
func generateQueryStruct(file *os.File) {
	fmt.Fprintf(file, "// Query represents a query builder with fluent (chainable) API\n")
	fmt.Fprintf(file, "type Query struct {\n")
	fmt.Fprintf(file, "\tdb             DB\n")
	fmt.Fprintf(file, "\ttable          string\n")
	fmt.Fprintf(file, "\tcolumns        []string\n")
	fmt.Fprintf(file, "\tprimaryKey     string\n")
	fmt.Fprintf(file, "\tmodelType      reflect.Type\n")
	fmt.Fprintf(file, "\tlogger         *Logger\n")
	fmt.Fprintf(file, "\tdialect        Dialect\n\n")
	fmt.Fprintf(file, "\t// Query state\n")
	fmt.Fprintf(file, "\twhereConditions []whereCondition\n")
	fmt.Fprintf(file, "\torderBy         []OrderBy\n")
	fmt.Fprintf(file, "\ttake            *int\n")
	fmt.Fprintf(file, "\tskip            *int\n")
	fmt.Fprintf(file, "\tselectFields    []string\n")
	fmt.Fprintf(file, "\tgroupBy         []string\n")
	fmt.Fprintf(file, "\thaving          []whereCondition\n")
	fmt.Fprintf(file, "\tjoins           []join\n")
	fmt.Fprintf(file, "}\n\n")

	fmt.Fprintf(file, "// whereCondition represents a WHERE condition\n")
	fmt.Fprintf(file, "type whereCondition struct {\n")
	fmt.Fprintf(file, "\tquery string\n")
	fmt.Fprintf(file, "\targs  []interface{}\n")
	fmt.Fprintf(file, "\tor    bool\n")
	fmt.Fprintf(file, "}\n\n")

	fmt.Fprintf(file, "// join represents a JOIN\n")
	fmt.Fprintf(file, "type join struct {\n")
	fmt.Fprintf(file, "\tjoinType string\n")
	fmt.Fprintf(file, "\ttable    string\n")
	fmt.Fprintf(file, "\ton       string\n")
	fmt.Fprintf(file, "\targs     []interface{}\n")
	fmt.Fprintf(file, "}\n\n")
}

// generateQueryConstructors generates NewQuery and setter methods
func generateQueryConstructors(file *os.File, provider string) {
	fmt.Fprintf(file, "// NewQuery creates a new query builder with fluent API\n")
	fmt.Fprintf(file, "func NewQuery(db DBTX, table string, columns []string) *Query {\n")
	fmt.Fprintf(file, "\treturn &Query{\n")
	fmt.Fprintf(file, "\t\tdb:              db,\n")
	fmt.Fprintf(file, "\t\ttable:           table,\n")
	fmt.Fprintf(file, "\t\tcolumns:         columns,\n")
	fmt.Fprintf(file, "\t\tdialect:         GetDialect(%q),\n", provider)
	fmt.Fprintf(file, "\t\tlogger:          GetDefaultLogger(),\n")
	fmt.Fprintf(file, "\t\twhereConditions: []whereCondition{},\n")
	fmt.Fprintf(file, "\t\torderBy:         []OrderBy{},\n")
	fmt.Fprintf(file, "\t\tjoins:           []join{},\n")
	fmt.Fprintf(file, "\t\tselectFields:    []string{},\n")
	fmt.Fprintf(file, "\t\tgroupBy:         []string{},\n")
	fmt.Fprintf(file, "\t\thaving:          []whereCondition{},\n")
	fmt.Fprintf(file, "\t}\n")
	fmt.Fprintf(file, "}\n\n")

	fmt.Fprintf(file, "// SetDialect sets the database dialect\n")
	fmt.Fprintf(file, "func (q *Query) SetDialect(d Dialect) *Query {\n")
	fmt.Fprintf(file, "\tq.dialect = d\n")
	fmt.Fprintf(file, "\treturn q\n")
	fmt.Fprintf(file, "}\n\n")

	fmt.Fprintf(file, "// SetDialectFromProvider sets the dialect from provider name\n")
	fmt.Fprintf(file, "func (q *Query) SetDialectFromProvider(provider string) *Query {\n")
	fmt.Fprintf(file, "\tq.dialect = GetDialect(provider)\n")
	fmt.Fprintf(file, "\treturn q\n")
	fmt.Fprintf(file, "}\n\n")

	fmt.Fprintf(file, "// SetPrimaryKey sets the primary key\n")
	fmt.Fprintf(file, "func (q *Query) SetPrimaryKey(pk string) *Query {\n")
	fmt.Fprintf(file, "\tq.primaryKey = pk\n")
	fmt.Fprintf(file, "\treturn q\n")
	fmt.Fprintf(file, "}\n\n")

	fmt.Fprintf(file, "// SetModelType sets the model type for automatic scanning\n")
	fmt.Fprintf(file, "func (q *Query) SetModelType(modelType reflect.Type) *Query {\n")
	fmt.Fprintf(file, "\tq.modelType = modelType\n")
	fmt.Fprintf(file, "\treturn q\n")
	fmt.Fprintf(file, "}\n\n")

	fmt.Fprintf(file, "// GetDB returns the database connection\n")
	fmt.Fprintf(file, "func (q *Query) GetDB() DBTX {\n")
	fmt.Fprintf(file, "\treturn q.db\n")
	fmt.Fprintf(file, "}\n\n")

	fmt.Fprintf(file, "// GetDialect returns the database dialect\n")
	fmt.Fprintf(file, "func (q *Query) GetDialect() Dialect {\n")
	fmt.Fprintf(file, "\treturn q.dialect\n")
	fmt.Fprintf(file, "}\n\n")

	fmt.Fprintf(file, "// GetTable returns the table name\n")
	fmt.Fprintf(file, "func (q *Query) GetTable() string {\n")
	fmt.Fprintf(file, "\treturn q.table\n")
	fmt.Fprintf(file, "}\n\n")

	fmt.Fprintf(file, "// GetColumns returns the column names\n")
	fmt.Fprintf(file, "func (q *Query) GetColumns() []string {\n")
	fmt.Fprintf(file, "\treturn q.columns\n")
	fmt.Fprintf(file, "}\n\n")

	fmt.Fprintf(file, "// GetPrimaryKey returns the primary key column name\n")
	fmt.Fprintf(file, "func (q *Query) GetPrimaryKey() string {\n")
	fmt.Fprintf(file, "\treturn q.primaryKey\n")
	fmt.Fprintf(file, "}\n\n")

	fmt.Fprintf(file, "// getLogger returns the logger, always getting the current default logger\n")
	fmt.Fprintf(file, "// This ensures that if the logger is configured after Query creation, it will use the updated logger\n")
	fmt.Fprintf(file, "func (q *Query) getLogger() *Logger {\n")
	fmt.Fprintf(file, "\t// Always get the current default logger to ensure it's up to date\n")
	fmt.Fprintf(file, "\tcurrentLogger := GetDefaultLogger()\n")
	fmt.Fprintf(file, "\t// Update q.logger if it's different (for efficiency, but always use current)\n")
	fmt.Fprintf(file, "\tif currentLogger != q.logger {\n")
	fmt.Fprintf(file, "\t\tq.logger = currentLogger\n")
	fmt.Fprintf(file, "\t}\n")
	fmt.Fprintf(file, "\treturn q.logger\n")
	fmt.Fprintf(file, "}\n\n")
}

// generateQueryWhereMethods generates Where, Or, Not methods
func generateQueryWhereMethods(file *os.File) {
	fmt.Fprintf(file, "// Where adds a WHERE condition\n")
	fmt.Fprintf(file, "// Supports two syntaxes:\n")
	fmt.Fprintf(file, "//  1. Direct SQL: q.Where(\"name = ?\", \"jinzhu\")\n")
	fmt.Fprintf(file, "//  2. Prisma map: q.Where(builder.Where{\"name\": \"jinzhu\", \"age\": builder.Gt(18)})\n")
	fmt.Fprintf(file, "func (q *Query) Where(condition interface{}, args ...interface{}) *Query {\n")
	fmt.Fprintf(file, "\tif queryStr, ok := condition.(string); ok {\n")
	fmt.Fprintf(file, "\t\tq.whereConditions = append(q.whereConditions, whereCondition{\n")
	fmt.Fprintf(file, "\t\t\tquery: queryStr,\n")
	fmt.Fprintf(file, "\t\t\targs:  args,\n")
	fmt.Fprintf(file, "\t\t\tor:    false,\n")
	fmt.Fprintf(file, "\t\t})\n")
	fmt.Fprintf(file, "\t\treturn q\n")
	fmt.Fprintf(file, "\t}\n\n")
	fmt.Fprintf(file, "\tif whereMap, ok := condition.(Where); ok {\n")
	fmt.Fprintf(file, "\t\tfor field, value := range whereMap {\n")
	fmt.Fprintf(file, "\t\t\tif op, ok := value.(WhereOperator); ok {\n")
	fmt.Fprintf(file, "\t\t\t\tq.addPrismaWhereCondition(field, op)\n")
	fmt.Fprintf(file, "\t\t\t} else if value == nil {\n")
	fmt.Fprintf(file, "\t\t\t\tquotedField := q.dialect.QuoteIdentifier(field)\n")
	fmt.Fprintf(file, "\t\t\t\tq.whereConditions = append(q.whereConditions, whereCondition{\n")
	fmt.Fprintf(file, "\t\t\t\t\tquery: fmt.Sprintf(\"%%s IS NULL\", quotedField),\n")
	fmt.Fprintf(file, "\t\t\t\t\targs:  []interface{}{},\n")
	fmt.Fprintf(file, "\t\t\t\t\tor:    false,\n")
	fmt.Fprintf(file, "\t\t\t\t})\n")
	fmt.Fprintf(file, "\t\t\t} else {\n")
	fmt.Fprintf(file, "\t\t\t\tquotedField := q.dialect.QuoteIdentifier(field)\n")
	fmt.Fprintf(file, "\t\t\t\tq.whereConditions = append(q.whereConditions, whereCondition{\n")
	fmt.Fprintf(file, "\t\t\t\t\tquery: fmt.Sprintf(\"%%s = ?\", quotedField),\n")
	fmt.Fprintf(file, "\t\t\t\t\targs:  []interface{}{value},\n")
	fmt.Fprintf(file, "\t\t\t\t\tor:    false,\n")
	fmt.Fprintf(file, "\t\t\t\t})\n")
	fmt.Fprintf(file, "\t\t\t}\n")
	fmt.Fprintf(file, "\t\t}\n")
	fmt.Fprintf(file, "\t\treturn q\n")
	fmt.Fprintf(file, "\t}\n\n")
	fmt.Fprintf(file, "\treturn q\n")
	fmt.Fprintf(file, "}\n\n")

	// Generate addPrismaWhereCondition - this is a large function, so we'll generate it separately
	generateAddPrismaWhereCondition(file)

	fmt.Fprintf(file, "// Or adds an OR condition\n")
	fmt.Fprintf(file, "func (q *Query) Or(query string, args ...interface{}) *Query {\n")
	fmt.Fprintf(file, "\tq.whereConditions = append(q.whereConditions, whereCondition{\n")
	fmt.Fprintf(file, "\t\tquery: query,\n")
	fmt.Fprintf(file, "\t\targs:  args,\n")
	fmt.Fprintf(file, "\t\tor:    true,\n")
	fmt.Fprintf(file, "\t})\n")
	fmt.Fprintf(file, "\treturn q\n")
	fmt.Fprintf(file, "}\n\n")

	fmt.Fprintf(file, "// Not adds a NOT condition\n")
	fmt.Fprintf(file, "func (q *Query) Not(query string, args ...interface{}) *Query {\n")
	fmt.Fprintf(file, "\tq.whereConditions = append(q.whereConditions, whereCondition{\n")
	fmt.Fprintf(file, "\t\tquery: fmt.Sprintf(\"NOT (%%s)\", query),\n")
	fmt.Fprintf(file, "\t\targs:  args,\n")
	fmt.Fprintf(file, "\t\tor:    false,\n")
	fmt.Fprintf(file, "\t})\n")
	fmt.Fprintf(file, "\treturn q\n")
	fmt.Fprintf(file, "}\n\n")
}

// generateAddPrismaWhereCondition generates the large addPrismaWhereCondition method
func generateAddPrismaWhereCondition(file *os.File) {
	fmt.Fprintf(file, "// addPrismaWhereCondition adds a WHERE condition using Prisma operator\n")
	fmt.Fprintf(file, "func (q *Query) addPrismaWhereCondition(field string, op WhereOperator) {\n")
	fmt.Fprintf(file, "\tquotedField := q.dialect.QuoteIdentifier(field)\n")
	fmt.Fprintf(file, "\tswitch op.GetOp() {\n")
	fmt.Fprintf(file, "\tcase \">\":\n")
	fmt.Fprintf(file, "\t\tq.whereConditions = append(q.whereConditions, whereCondition{\n")
	fmt.Fprintf(file, "\t\t\tquery: fmt.Sprintf(\"%%s > ?\", quotedField),\n")
	fmt.Fprintf(file, "\t\t\targs:  []interface{}{op.GetValue()},\n")
	fmt.Fprintf(file, "\t\t\tor:    false,\n")
	fmt.Fprintf(file, "\t\t})\n")
	fmt.Fprintf(file, "\tcase \">=\":\n")
	fmt.Fprintf(file, "\t\tq.whereConditions = append(q.whereConditions, whereCondition{\n")
	fmt.Fprintf(file, "\t\t\tquery: fmt.Sprintf(\"%%s >= ?\", quotedField),\n")
	fmt.Fprintf(file, "\t\t\targs:  []interface{}{op.GetValue()},\n")
	fmt.Fprintf(file, "\t\t\tor:    false,\n")
	fmt.Fprintf(file, "\t\t})\n")
	fmt.Fprintf(file, "\tcase \"<\":\n")
	fmt.Fprintf(file, "\t\tq.whereConditions = append(q.whereConditions, whereCondition{\n")
	fmt.Fprintf(file, "\t\t\tquery: fmt.Sprintf(\"%%s < ?\", quotedField),\n")
	fmt.Fprintf(file, "\t\t\targs:  []interface{}{op.GetValue()},\n")
	fmt.Fprintf(file, "\t\t\tor:    false,\n")
	fmt.Fprintf(file, "\t\t})\n")
	fmt.Fprintf(file, "\tcase \"<=\":\n")
	fmt.Fprintf(file, "\t\tq.whereConditions = append(q.whereConditions, whereCondition{\n")
	fmt.Fprintf(file, "\t\t\tquery: fmt.Sprintf(\"%%s <= ?\", quotedField),\n")
	fmt.Fprintf(file, "\t\t\targs:  []interface{}{op.GetValue()},\n")
	fmt.Fprintf(file, "\t\t\tor:    false,\n")
	fmt.Fprintf(file, "\t\t})\n")
	fmt.Fprintf(file, "\tcase \"IN\":\n")
	fmt.Fprintf(file, "\t\tif values, ok := op.GetValue().([]interface{}); ok {\n")
	fmt.Fprintf(file, "\t\t\tplaceholders := make([]string, len(values))\n")
	fmt.Fprintf(file, "\t\t\tfor i := range values {\n")
	fmt.Fprintf(file, "\t\t\t\tplaceholders[i] = \"?\"\n")
	fmt.Fprintf(file, "\t\t\t}\n")
	fmt.Fprintf(file, "\t\t\tq.whereConditions = append(q.whereConditions, whereCondition{\n")
	fmt.Fprintf(file, "\t\t\t\tquery: fmt.Sprintf(\"%%s IN (%%s)\", quotedField, strings.Join(placeholders, \", \")),\n")
	fmt.Fprintf(file, "\t\t\t\targs:  values,\n")
	fmt.Fprintf(file, "\t\t\t\tor:    false,\n")
	fmt.Fprintf(file, "\t\t\t})\n")
	fmt.Fprintf(file, "\t\t}\n")
	fmt.Fprintf(file, "\tcase \"NOT IN\":\n")
	fmt.Fprintf(file, "\t\tif values, ok := op.GetValue().([]interface{}); ok {\n")
	fmt.Fprintf(file, "\t\t\tplaceholders := make([]string, len(values))\n")
	fmt.Fprintf(file, "\t\t\tfor i := range values {\n")
	fmt.Fprintf(file, "\t\t\t\tplaceholders[i] = \"?\"\n")
	fmt.Fprintf(file, "\t\t\t}\n")
	fmt.Fprintf(file, "\t\t\tq.whereConditions = append(q.whereConditions, whereCondition{\n")
	fmt.Fprintf(file, "\t\t\t\tquery: fmt.Sprintf(\"%%s NOT IN (%%s)\", quotedField, strings.Join(placeholders, \", \")),\n")
	fmt.Fprintf(file, "\t\t\t\targs:  values,\n")
	fmt.Fprintf(file, "\t\t\t\tor:    false,\n")
	fmt.Fprintf(file, "\t\t\t})\n")
	fmt.Fprintf(file, "\t\t}\n")
	fmt.Fprintf(file, "\tcase \"LIKE\":\n")
	fmt.Fprintf(file, "\t\tq.whereConditions = append(q.whereConditions, whereCondition{\n")
	fmt.Fprintf(file, "\t\t\tquery: fmt.Sprintf(\"%%s LIKE ?\", quotedField),\n")
	fmt.Fprintf(file, "\t\t\targs:  []interface{}{op.GetValue()},\n")
	fmt.Fprintf(file, "\t\t\tor:    false,\n")
	fmt.Fprintf(file, "\t\t})\n")
	fmt.Fprintf(file, "\tcase \"ILIKE\":\n")
	fmt.Fprintf(file, "\t\tq.whereConditions = append(q.whereConditions, whereCondition{\n")
	fmt.Fprintf(file, "\t\t\tquery: fmt.Sprintf(\"%%s ILIKE ?\", quotedField),\n")
	fmt.Fprintf(file, "\t\t\targs:  []interface{}{op.GetValue()},\n")
	fmt.Fprintf(file, "\t\t\tor:    false,\n")
	fmt.Fprintf(file, "\t\t})\n")
	fmt.Fprintf(file, "\tcase \"IS NULL\":\n")
	fmt.Fprintf(file, "\t\tq.whereConditions = append(q.whereConditions, whereCondition{\n")
	fmt.Fprintf(file, "\t\t\tquery: fmt.Sprintf(\"%%s IS NULL\", quotedField),\n")
	fmt.Fprintf(file, "\t\t\targs:  []interface{}{},\n")
	fmt.Fprintf(file, "\t\t\tor:    false,\n")
	fmt.Fprintf(file, "\t\t})\n")
	fmt.Fprintf(file, "\tcase \"IS NOT NULL\":\n")
	fmt.Fprintf(file, "\t\tq.whereConditions = append(q.whereConditions, whereCondition{\n")
	fmt.Fprintf(file, "\t\t\tquery: fmt.Sprintf(\"%%s IS NOT NULL\", quotedField),\n")
	fmt.Fprintf(file, "\t\t\targs:  []interface{}{},\n")
	fmt.Fprintf(file, "\t\t\tor:    false,\n")
	fmt.Fprintf(file, "\t\t})\n")
	fmt.Fprintf(file, "\tcase \"HAS\":\n")
	fmt.Fprintf(file, "\t\tif q.dialect.SupportsJSON() {\n")
	fmt.Fprintf(file, "\t\t\tjsonValue := fmt.Sprintf(`[\"%%v\"]`, op.GetValue())\n")
	fmt.Fprintf(file, "\t\t\tquery := q.dialect.GetJSONContainsQuery(field, jsonValue)\n")
	fmt.Fprintf(file, "\t\t\tq.whereConditions = append(q.whereConditions, whereCondition{\n")
	fmt.Fprintf(file, "\t\t\t\tquery: query,\n")
	fmt.Fprintf(file, "\t\t\t\targs:  []interface{}{},\n")
	fmt.Fprintf(file, "\t\t\t\tor:    false,\n")
	fmt.Fprintf(file, "\t\t\t})\n")
	fmt.Fprintf(file, "\t\t} else {\n")
	fmt.Fprintf(file, "\t\t\tq.whereConditions = append(q.whereConditions, whereCondition{\n")
	fmt.Fprintf(file, "\t\t\t\tquery: fmt.Sprintf(\"%%s LIKE ?\", q.dialect.QuoteIdentifier(field)),\n")
	fmt.Fprintf(file, "\t\t\t\targs:  []interface{}{fmt.Sprintf(\"%%%%%%v%%%%\", op.GetValue())},\n")
	fmt.Fprintf(file, "\t\t\t\tor:    false,\n")
	fmt.Fprintf(file, "\t\t\t})\n")
	fmt.Fprintf(file, "\t\t}\n")
	fmt.Fprintf(file, "\tcase \"HAS_EVERY\":\n")
	fmt.Fprintf(file, "\t\tif q.dialect.SupportsJSON() {\n")
	fmt.Fprintf(file, "\t\t\tif values, ok := op.GetValue().([]interface{}); ok {\n")
	fmt.Fprintf(file, "\t\t\t\tjsonValue := fmt.Sprintf(`[%%s]`, strings.Join(func() []string {\n")
	fmt.Fprintf(file, "\t\t\t\t\tresult := make([]string, len(values))\n")
	fmt.Fprintf(file, "\t\t\t\t\tfor i, v := range values {\n")
	fmt.Fprintf(file, "\t\t\t\t\t\tresult[i] = fmt.Sprintf(`\"%%v\"`, v)\n")
	fmt.Fprintf(file, "\t\t\t\t\t}\n")
	fmt.Fprintf(file, "\t\t\t\t\treturn result\n")
	fmt.Fprintf(file, "\t\t\t\t}(), \", \"))\n")
	fmt.Fprintf(file, "\t\t\t\tquery := q.dialect.GetJSONContainsQuery(field, jsonValue)\n")
	fmt.Fprintf(file, "\t\t\t\tq.whereConditions = append(q.whereConditions, whereCondition{\n")
	fmt.Fprintf(file, "\t\t\t\t\tquery: query,\n")
	fmt.Fprintf(file, "\t\t\t\t\targs:  []interface{}{},\n")
	fmt.Fprintf(file, "\t\t\t\t\tor:    false,\n")
	fmt.Fprintf(file, "\t\t\t\t})\n")
	fmt.Fprintf(file, "\t\t\t}\n")
	fmt.Fprintf(file, "\t\t} else {\n")
	fmt.Fprintf(file, "\t\t\tif values, ok := op.GetValue().([]interface{}); ok {\n")
	fmt.Fprintf(file, "\t\t\t\tconditions := make([]string, len(values))\n")
	fmt.Fprintf(file, "\t\t\t\tfor i := range values {\n")
	fmt.Fprintf(file, "\t\t\t\t\tconditions[i] = fmt.Sprintf(\"%%s LIKE ?\", q.dialect.QuoteIdentifier(field))\n")
	fmt.Fprintf(file, "\t\t\t\t}\n")
	fmt.Fprintf(file, "\t\t\t\tq.whereConditions = append(q.whereConditions, whereCondition{\n")
	fmt.Fprintf(file, "\t\t\t\t\tquery: fmt.Sprintf(\"(%%s)\", strings.Join(conditions, \" AND \")),\n")
	fmt.Fprintf(file, "\t\t\t\t\targs: func() []interface{} {\n")
	fmt.Fprintf(file, "\t\t\t\t\tresult := make([]interface{}, len(values))\n")
	fmt.Fprintf(file, "\t\t\t\t\tfor i, v := range values {\n")
	fmt.Fprintf(file, "\t\t\t\t\t\tresult[i] = fmt.Sprintf(\"%%%%%%v%%%%\", v)\n")
	fmt.Fprintf(file, "\t\t\t\t\t}\n")
	fmt.Fprintf(file, "\t\t\t\t\treturn result\n")
	fmt.Fprintf(file, "\t\t\t\t}(),\n")
	fmt.Fprintf(file, "\t\t\t\t\tor: false,\n")
	fmt.Fprintf(file, "\t\t\t\t})\n")
	fmt.Fprintf(file, "\t\t\t}\n")
	fmt.Fprintf(file, "\t\t}\n")
	fmt.Fprintf(file, "\tcase \"HAS_SOME\":\n")
	fmt.Fprintf(file, "\t\tif q.dialect.SupportsJSON() {\n")
	fmt.Fprintf(file, "\t\t\tif values, ok := op.GetValue().([]interface{}); ok {\n")
	fmt.Fprintf(file, "\t\t\t\tif q.dialect.Name() == \"postgresql\" {\n")
	fmt.Fprintf(file, "\t\t\t\t\tplaceholders := make([]string, len(values))\n")
	fmt.Fprintf(file, "\t\t\t\t\tfor i := range values {\n")
	fmt.Fprintf(file, "\t\t\t\t\t\tplaceholders[i] = \"?\"\n")
	fmt.Fprintf(file, "\t\t\t\t\t}\n")
	fmt.Fprintf(file, "\t\t\t\t\tquotedField := q.dialect.QuoteIdentifier(field)\n")
	fmt.Fprintf(file, "\t\t\t\t\tq.whereConditions = append(q.whereConditions, whereCondition{\n")
	fmt.Fprintf(file, "\t\t\t\t\t\tquery: fmt.Sprintf(\"%%s ?| array[%%s]\", quotedField, strings.Join(placeholders, \", \")),\n")
	fmt.Fprintf(file, "\t\t\t\t\t\targs:  values,\n")
	fmt.Fprintf(file, "\t\t\t\t\t\tor:    false,\n")
	fmt.Fprintf(file, "\t\t\t\t\t})\n")
	fmt.Fprintf(file, "\t\t\t\t} else {\n")
	fmt.Fprintf(file, "\t\t\t\t\tconditions := make([]string, len(values))\n")
	fmt.Fprintf(file, "\t\t\t\t\tfor i, v := range values {\n")
	fmt.Fprintf(file, "\t\t\t\t\t\tjsonValue := fmt.Sprintf(`\"%%v\"`, v)\n")
	fmt.Fprintf(file, "\t\t\t\t\t\tconditions[i] = q.dialect.GetJSONContainsQuery(field, jsonValue)\n")
	fmt.Fprintf(file, "\t\t\t\t\t}\n")
	fmt.Fprintf(file, "\t\t\t\t\tq.whereConditions = append(q.whereConditions, whereCondition{\n")
	fmt.Fprintf(file, "\t\t\t\t\t\tquery: fmt.Sprintf(\"(%%s)\", strings.Join(conditions, \" OR \")),\n")
	fmt.Fprintf(file, "\t\t\t\t\t\targs:  []interface{}{},\n")
	fmt.Fprintf(file, "\t\t\t\t\t\tor:    false,\n")
	fmt.Fprintf(file, "\t\t\t\t\t})\n")
	fmt.Fprintf(file, "\t\t\t\t}\n")
	fmt.Fprintf(file, "\t\t\t}\n")
	fmt.Fprintf(file, "\t\t} else {\n")
	fmt.Fprintf(file, "\t\t\tif values, ok := op.GetValue().([]interface{}); ok {\n")
	fmt.Fprintf(file, "\t\t\t\tconditions := make([]string, len(values))\n")
	fmt.Fprintf(file, "\t\t\t\tallArgs := make([]interface{}, len(values))\n")
	fmt.Fprintf(file, "\t\t\t\tfor i, v := range values {\n")
	fmt.Fprintf(file, "\t\t\t\t\tconditions[i] = fmt.Sprintf(\"%%s LIKE ?\", q.dialect.QuoteIdentifier(field))\n")
	fmt.Fprintf(file, "\t\t\t\t\tallArgs[i] = fmt.Sprintf(\"%%%%%%v%%%%\", v)\n")
	fmt.Fprintf(file, "\t\t\t\t}\n")
	fmt.Fprintf(file, "\t\t\t\tq.whereConditions = append(q.whereConditions, whereCondition{\n")
	fmt.Fprintf(file, "\t\t\t\t\tquery: fmt.Sprintf(\"(%%s)\", strings.Join(conditions, \" OR \")),\n")
	fmt.Fprintf(file, "\t\t\t\t\targs:  allArgs,\n")
	fmt.Fprintf(file, "\t\t\t\t\tor:    false,\n")
	fmt.Fprintf(file, "\t\t\t\t})\n")
	fmt.Fprintf(file, "\t\t\t}\n")
	fmt.Fprintf(file, "\t\t}\n")
	fmt.Fprintf(file, "\tcase \"IS_EMPTY\":\n")
	fmt.Fprintf(file, "\t\tif q.dialect.SupportsJSON() {\n")
	fmt.Fprintf(file, "\t\t\tquotedField := q.dialect.QuoteIdentifier(field)\n")
	fmt.Fprintf(file, "\t\t\tif q.dialect.Name() == \"postgresql\" {\n")
	fmt.Fprintf(file, "\t\t\t\tq.whereConditions = append(q.whereConditions, whereCondition{\n")
	fmt.Fprintf(file, "\t\t\t\t\tquery: fmt.Sprintf(\"(jsonb_typeof(%%s) = 'array' AND jsonb_array_length(%%s) = 0) OR %%s = '[]'::jsonb\", quotedField, quotedField, quotedField),\n")
	fmt.Fprintf(file, "\t\t\t\t\targs:  []interface{}{},\n")
	fmt.Fprintf(file, "\t\t\t\t\tor:    false,\n")
	fmt.Fprintf(file, "\t\t\t\t})\n")
	fmt.Fprintf(file, "\t\t\t} else if q.dialect.Name() == \"mysql\" {\n")
	fmt.Fprintf(file, "\t\t\t\tq.whereConditions = append(q.whereConditions, whereCondition{\n")
	fmt.Fprintf(file, "\t\t\t\t\tquery: fmt.Sprintf(\"(JSON_TYPE(%%s) = 'ARRAY' AND JSON_LENGTH(%%s) = 0) OR %%s = '[]'\", quotedField, quotedField, quotedField),\n")
	fmt.Fprintf(file, "\t\t\t\t\targs:  []interface{}{},\n")
	fmt.Fprintf(file, "\t\t\t\t\tor:    false,\n")
	fmt.Fprintf(file, "\t\t\t\t})\n")
	fmt.Fprintf(file, "\t\t\t} else {\n")
	fmt.Fprintf(file, "\t\t\t\tq.whereConditions = append(q.whereConditions, whereCondition{\n")
	fmt.Fprintf(file, "\t\t\t\t\tquery: fmt.Sprintf(\"(json_array_length(%%s) = 0 OR %%s IS NULL)\", quotedField, quotedField),\n")
	fmt.Fprintf(file, "\t\t\t\t\targs:  []interface{}{},\n")
	fmt.Fprintf(file, "\t\t\t\t\tor:    false,\n")
	fmt.Fprintf(file, "\t\t\t\t})\n")
	fmt.Fprintf(file, "\t\t\t}\n")
	fmt.Fprintf(file, "\t\t} else {\n")
	fmt.Fprintf(file, "\t\t\tquotedField := q.dialect.QuoteIdentifier(field)\n")
	fmt.Fprintf(file, "\t\t\tq.whereConditions = append(q.whereConditions, whereCondition{\n")
	fmt.Fprintf(file, "\t\t\t\tquery: fmt.Sprintf(\"(%%s IS NULL OR %%s = '')\", quotedField, quotedField),\n")
	fmt.Fprintf(file, "\t\t\t\targs:  []interface{}{},\n")
	fmt.Fprintf(file, "\t\t\t\tor:    false,\n")
	fmt.Fprintf(file, "\t\t\t})\n")
	fmt.Fprintf(file, "\t\t}\n")
	fmt.Fprintf(file, "\tcase \"FULLTEXT_SEARCH\":\n")
	fmt.Fprintf(file, "\t\tif q.dialect.SupportsFullTextSearch() {\n")
	fmt.Fprintf(file, "\t\t\tif queryStr, ok := op.GetValue().(string); ok {\n")
	fmt.Fprintf(file, "\t\t\t\tif q.dialect.Name() == \"postgresql\" {\n")
	fmt.Fprintf(file, "\t\t\t\t\tqueryStr = NormalizeTSQuery(queryStr)\n")
	fmt.Fprintf(file, "\t\t\t\t}\n")
	fmt.Fprintf(file, "\t\t\t\tquery := q.dialect.GetFullTextSearchQuery(field, queryStr)\n")
	fmt.Fprintf(file, "\t\t\t\targs := []interface{}{}\n")
	fmt.Fprintf(file, "\t\t\t\tif strings.Contains(query, \"?\") || strings.Contains(query, \"$\") {\n")
	fmt.Fprintf(file, "\t\t\t\t\targs = []interface{}{queryStr}\n")
	fmt.Fprintf(file, "\t\t\t\t}\n")
	fmt.Fprintf(file, "\t\t\t\tq.whereConditions = append(q.whereConditions, whereCondition{\n")
	fmt.Fprintf(file, "\t\t\t\t\tquery: query,\n")
	fmt.Fprintf(file, "\t\t\t\t\targs:  args,\n")
	fmt.Fprintf(file, "\t\t\t\t\tor:    false,\n")
	fmt.Fprintf(file, "\t\t\t\t})\n")
	fmt.Fprintf(file, "\t\t\t}\n")
	fmt.Fprintf(file, "\t\t} else {\n")
	fmt.Fprintf(file, "\t\t\tif queryStr, ok := op.GetValue().(string); ok {\n")
	fmt.Fprintf(file, "\t\t\t\tq.whereConditions = append(q.whereConditions, whereCondition{\n")
	fmt.Fprintf(file, "\t\t\t\t\tquery: fmt.Sprintf(\"%%s LIKE ?\", quotedField),\n")
	fmt.Fprintf(file, "\t\t\t\t\targs:  []interface{}{fmt.Sprintf(\"%%%%%%s%%%%\", queryStr)},\n")
	fmt.Fprintf(file, "\t\t\t\t\tor:    false,\n")
	fmt.Fprintf(file, "\t\t\t\t})\n")
	fmt.Fprintf(file, "\t\t\t}\n")
	fmt.Fprintf(file, "\t\t}\n")
	fmt.Fprintf(file, "\tdefault:\n")
	fmt.Fprintf(file, "\t\tq.whereConditions = append(q.whereConditions, whereCondition{\n")
	fmt.Fprintf(file, "\t\t\tquery: fmt.Sprintf(\"%%s = ?\", quotedField),\n")
	fmt.Fprintf(file, "\t\t\targs:  []interface{}{op.GetValue()},\n")
	fmt.Fprintf(file, "\t\t\tor:    false,\n")
	fmt.Fprintf(file, "\t\t})\n")
	fmt.Fprintf(file, "\t}\n")
	fmt.Fprintf(file, "}\n\n")
}

// generateQueryBuilderMethods generates Select, Order, Limit, Offset, Group, Having, Join methods
func generateQueryBuilderMethods(file *os.File) {
	fmt.Fprintf(file, "// Select specifies which columns to select\n")
	fmt.Fprintf(file, "func (q *Query) Select(fields ...string) *Query {\n")
	fmt.Fprintf(file, "\tremaining := MaxSelectFields - len(q.selectFields)\n")
	fmt.Fprintf(file, "\tif remaining <= 0 {\n")
	fmt.Fprintf(file, "\t\treturn q\n")
	fmt.Fprintf(file, "\t}\n")
	fmt.Fprintf(file, "\tif len(fields) > remaining {\n")
	fmt.Fprintf(file, "\t\tfields = fields[:remaining]\n")
	fmt.Fprintf(file, "\t}\n")
	fmt.Fprintf(file, "\tq.selectFields = append(q.selectFields, fields...)\n")
	fmt.Fprintf(file, "\treturn q\n")
	fmt.Fprintf(file, "}\n\n")

	fmt.Fprintf(file, "// SelectAll clears Select and returns all fields\n")
	fmt.Fprintf(file, "func (q *Query) SelectAll() *Query {\n")
	fmt.Fprintf(file, "\tq.selectFields = []string{}\n")
	fmt.Fprintf(file, "\treturn q\n")
	fmt.Fprintf(file, "}\n\n")

	fmt.Fprintf(file, "// Order adds ORDER BY\n")
	fmt.Fprintf(file, "func (q *Query) Order(order string) *Query {\n")
	fmt.Fprintf(file, "\tif len(q.orderBy) >= MaxOrderByFields {\n")
	fmt.Fprintf(file, "\t\treturn q\n")
	fmt.Fprintf(file, "\t}\n\n")
	fmt.Fprintf(file, "\tparts := strings.Fields(order)\n")
	fmt.Fprintf(file, "\tif len(parts) == 2 {\n")
	fmt.Fprintf(file, "\t\tq.orderBy = append(q.orderBy, OrderBy{\n")
	fmt.Fprintf(file, "\t\t\tField: parts[0],\n")
	fmt.Fprintf(file, "\t\t\tOrder: strings.ToUpper(parts[1]),\n")
	fmt.Fprintf(file, "\t\t})\n")
	fmt.Fprintf(file, "\t} else if len(parts) == 1 {\n")
	fmt.Fprintf(file, "\t\tq.orderBy = append(q.orderBy, OrderBy{\n")
	fmt.Fprintf(file, "\t\t\tField: parts[0],\n")
	fmt.Fprintf(file, "\t\t\tOrder: \"ASC\",\n")
	fmt.Fprintf(file, "\t\t})\n")
	fmt.Fprintf(file, "\t}\n")
	fmt.Fprintf(file, "\treturn q\n")
	fmt.Fprintf(file, "}\n\n")

	fmt.Fprintf(file, "// Take sets the LIMIT\n")
	fmt.Fprintf(file, "func (q *Query) Take(take int) *Query {\n")
	fmt.Fprintf(file, "\tq.take = &take\n")
	fmt.Fprintf(file, "\treturn q\n")
	fmt.Fprintf(file, "}\n\n")

	fmt.Fprintf(file, "// Skip sets the OFFSET\n")
	fmt.Fprintf(file, "func (q *Query) Skip(skip int) *Query {\n")
	fmt.Fprintf(file, "\tq.skip = &skip\n")
	fmt.Fprintf(file, "\treturn q\n")
	fmt.Fprintf(file, "}\n\n")

	fmt.Fprintf(file, "// Group adds GROUP BY\n")
	fmt.Fprintf(file, "func (q *Query) Group(fields ...string) *Query {\n")
	fmt.Fprintf(file, "\tremaining := MaxGroupByFields - len(q.groupBy)\n")
	fmt.Fprintf(file, "\tif remaining <= 0 {\n")
	fmt.Fprintf(file, "\t\treturn q\n")
	fmt.Fprintf(file, "\t}\n")
	fmt.Fprintf(file, "\tif len(fields) > remaining {\n")
	fmt.Fprintf(file, "\t\tfields = fields[:remaining]\n")
	fmt.Fprintf(file, "\t}\n")
	fmt.Fprintf(file, "\tq.groupBy = append(q.groupBy, fields...)\n")
	fmt.Fprintf(file, "\treturn q\n")
	fmt.Fprintf(file, "}\n\n")

	fmt.Fprintf(file, "// Having adds HAVING\n")
	fmt.Fprintf(file, "func (q *Query) Having(query string, args ...interface{}) *Query {\n")
	fmt.Fprintf(file, "\tq.having = append(q.having, whereCondition{\n")
	fmt.Fprintf(file, "\t\tquery: query,\n")
	fmt.Fprintf(file, "\t\targs:  args,\n")
	fmt.Fprintf(file, "\t\tor:    false,\n")
	fmt.Fprintf(file, "\t})\n")
	fmt.Fprintf(file, "\treturn q\n")
	fmt.Fprintf(file, "}\n\n")

	fmt.Fprintf(file, "// Join adds a JOIN\n")
	fmt.Fprintf(file, "func (q *Query) Join(joinType, table, on string, args ...interface{}) *Query {\n")
	fmt.Fprintf(file, "\tif len(q.joins) >= MaxJoins {\n")
	fmt.Fprintf(file, "\t\treturn q\n")
	fmt.Fprintf(file, "\t}\n")
	fmt.Fprintf(file, "\tq.joins = append(q.joins, join{\n")
	fmt.Fprintf(file, "\t\tjoinType: joinType,\n")
	fmt.Fprintf(file, "\t\ttable:    table,\n")
	fmt.Fprintf(file, "\t\ton:       on,\n")
	fmt.Fprintf(file, "\t\targs:     args,\n")
	fmt.Fprintf(file, "\t})\n")
	fmt.Fprintf(file, "\treturn q\n")
	fmt.Fprintf(file, "}\n\n")

	fmt.Fprintf(file, "// InnerJoin adds an INNER JOIN\n")
	fmt.Fprintf(file, "func (q *Query) InnerJoin(table, on string, args ...interface{}) *Query {\n")
	fmt.Fprintf(file, "\treturn q.Join(\"INNER\", table, on, args...)\n")
	fmt.Fprintf(file, "}\n\n")

	fmt.Fprintf(file, "// LeftJoin adds a LEFT JOIN\n")
	fmt.Fprintf(file, "func (q *Query) LeftJoin(table, on string, args ...interface{}) *Query {\n")
	fmt.Fprintf(file, "\treturn q.Join(\"LEFT\", table, on, args...)\n")
	fmt.Fprintf(file, "}\n\n")

	fmt.Fprintf(file, "// RightJoin adds a RIGHT JOIN\n")
	fmt.Fprintf(file, "func (q *Query) RightJoin(table, on string, args ...interface{}) *Query {\n")
	fmt.Fprintf(file, "\treturn q.Join(\"RIGHT\", table, on, args...)\n")
	fmt.Fprintf(file, "}\n\n")
}

// generateQueryExecutionMethods generates First, Find, Count, Create, Update, Delete methods
func generateQueryExecutionMethods(file *os.File) {
	fmt.Fprintf(file, "// First executes the query and returns the first result\n")
	fmt.Fprintf(file, "func (q *Query) First(ctx context.Context, dest interface{}) error {\n")
	fmt.Fprintf(file, "\tctx, cancel := WithQueryTimeout(ctx)\n")
	fmt.Fprintf(file, "\tdefer cancel()\n\n")
	fmt.Fprintf(file, "\tprocessStart := time.Now()\n")
	fmt.Fprintf(file, "\tquery, args := q.buildSelectQuery(true)\n\n")
	fmt.Fprintf(file, "\tqueryStart := time.Now()\n")
	fmt.Fprintf(file, "\trow := q.db.QueryRow(ctx, query, args...)\n\n")
	fmt.Fprintf(file, "\tvar err error\n")
	fmt.Fprintf(file, "\tif q.modelType != nil {\n")
	fmt.Fprintf(file, "\t\terr = q.scanRowIntoModel(row, dest)\n")
	fmt.Fprintf(file, "\t} else {\n")
	fmt.Fprintf(file, "\t\terr = row.Scan(dest)\n")
	fmt.Fprintf(file, "\t}\n")
	fmt.Fprintf(file, "\tqueryEnd := time.Now()\n")
	fmt.Fprintf(file, "\tqueryDuration := queryEnd.Sub(queryStart)\n\n")
	fmt.Fprintf(file, "\tq.logQueryWithTiming(ctx, query, args, queryStart, processStart, queryDuration)\n\n")
	fmt.Fprintf(file, "\tif err != nil {\n")
	fmt.Fprintf(file, "\t\tif logger := q.getLogger(); logger != nil {\n")
	fmt.Fprintf(file, "\t\t\tlogger.Error(\"SELECT query failed: %%v\", err)\n")
	fmt.Fprintf(file, "\t\t}\n")
	fmt.Fprintf(file, "\t}\n\n")
	fmt.Fprintf(file, "\treturn err\n")
	fmt.Fprintf(file, "}\n\n")

	fmt.Fprintf(file, "// Find executes the query and returns all results\n")
	fmt.Fprintf(file, "func (q *Query) Find(ctx context.Context, dest interface{}) error {\n")
	fmt.Fprintf(file, "\tctx, cancel := WithQueryTimeout(ctx)\n")
	fmt.Fprintf(file, "\tdefer cancel()\n\n")
	fmt.Fprintf(file, "\tprocessStart := time.Now()\n")
	fmt.Fprintf(file, "\tquery, args := q.buildSelectQuery(false)\n\n")
	fmt.Fprintf(file, "\tqueryStart := time.Now()\n")
	fmt.Fprintf(file, "\trows, err := q.db.Query(ctx, query, args...)\n")
	fmt.Fprintf(file, "\tqueryEnd := time.Now()\n")
	fmt.Fprintf(file, "\tqueryDuration := queryEnd.Sub(queryStart)\n\n")
	fmt.Fprintf(file, "\tif err != nil {\n")
	fmt.Fprintf(file, "\t\tif logger := q.getLogger(); logger != nil {\n")
	fmt.Fprintf(file, "\t\t\tlogger.Error(\"SELECT query failed: %%v\", err)\n")
	fmt.Fprintf(file, "\t\t}\n")
	fmt.Fprintf(file, "\t\treturn err\n")
	fmt.Fprintf(file, "\t}\n")
	fmt.Fprintf(file, "\tdefer rows.Close()\n\n")
	fmt.Fprintf(file, "\tif q.modelType != nil {\n")
	fmt.Fprintf(file, "\t\terr = q.scanRowsIntoModel(rows, dest)\n")
	fmt.Fprintf(file, "\t} else {\n")
	fmt.Fprintf(file, "\t\terr = q.scanRowsDirect(rows, dest)\n")
	fmt.Fprintf(file, "\t}\n\n")
	fmt.Fprintf(file, "\tq.logQueryWithTiming(ctx, query, args, queryStart, processStart, queryDuration)\n\n")
	fmt.Fprintf(file, "\tif err != nil {\n")
	fmt.Fprintf(file, "\t\tif logger := q.getLogger(); logger != nil {\n")
	fmt.Fprintf(file, "\t\t\tlogger.Error(\"SELECT query failed during scan: %%v\", err)\n")
	fmt.Fprintf(file, "\t\t}\n")
	fmt.Fprintf(file, "\t}\n\n")
	fmt.Fprintf(file, "\treturn err\n")
	fmt.Fprintf(file, "}\n\n")

	fmt.Fprintf(file, "// FindFirst is an alias for First\n")
	fmt.Fprintf(file, "func (q *Query) FindFirst(ctx context.Context, dest interface{}) error {\n")
	fmt.Fprintf(file, "\treturn q.First(ctx, dest)\n")
	fmt.Fprintf(file, "}\n\n")

	fmt.Fprintf(file, "// FindMany is an alias for Find\n")
	fmt.Fprintf(file, "func (q *Query) FindMany(ctx context.Context, dest interface{}) error {\n")
	fmt.Fprintf(file, "\treturn q.Find(ctx, dest)\n")
	fmt.Fprintf(file, "}\n\n")

	fmt.Fprintf(file, "// Count executes COUNT(*)\n")
	fmt.Fprintf(file, "func (q *Query) Count(ctx context.Context) (int64, error) {\n")
	fmt.Fprintf(file, "\tprocessStart := time.Now()\n")
	fmt.Fprintf(file, "\tquery, args := q.buildCountQuery()\n\n")
	fmt.Fprintf(file, "\tqueryStart := time.Now()\n")
	fmt.Fprintf(file, "\trow := q.db.QueryRow(ctx, query, args...)\n")
	fmt.Fprintf(file, "\tvar count int64\n")
	fmt.Fprintf(file, "\terr := row.Scan(&count)\n")
	fmt.Fprintf(file, "\tqueryEnd := time.Now()\n")
	fmt.Fprintf(file, "\tqueryDuration := queryEnd.Sub(queryStart)\n\n")
	fmt.Fprintf(file, "\tq.logQueryWithTiming(ctx, query, args, queryStart, processStart, queryDuration)\n\n")
	fmt.Fprintf(file, "\tif err != nil {\n")
	fmt.Fprintf(file, "\t\tif logger := q.getLogger(); logger != nil {\n")
	fmt.Fprintf(file, "\t\t\tlogger.Error(\"COUNT query failed: %%v\", err)\n")
	fmt.Fprintf(file, "\t\t}\n")
	fmt.Fprintf(file, "\t}\n")
	fmt.Fprintf(file, "\treturn count, err\n")
	fmt.Fprintf(file, "}\n\n")

	fmt.Fprintf(file, "// Create inserts a new record\n")
	fmt.Fprintf(file, "func (q *Query) Create(ctx context.Context, value interface{}) error {\n")
	fmt.Fprintf(file, "\tctx, cancel := WithQueryTimeout(ctx)\n")
	fmt.Fprintf(file, "\tdefer cancel()\n\n")
	fmt.Fprintf(file, "\tprocessStart := time.Now()\n")
	fmt.Fprintf(file, "\tquery, args := q.buildInsertQuery(value)\n\n")
	fmt.Fprintf(file, "\tqueryStart := time.Now()\n")
	fmt.Fprintf(file, "\t_, err := q.db.Exec(ctx, query, args...)\n")
	fmt.Fprintf(file, "\tqueryEnd := time.Now()\n")
	fmt.Fprintf(file, "\tqueryDuration := queryEnd.Sub(queryStart)\n\n")
	fmt.Fprintf(file, "\tq.logQueryWithTiming(ctx, query, args, queryStart, processStart, queryDuration)\n\n")
	fmt.Fprintf(file, "\tif err != nil {\n")
	fmt.Fprintf(file, "\t\tif logger := q.getLogger(); logger != nil {\n")
	fmt.Fprintf(file, "\t\t\tlogger.Error(\"INSERT query failed: %%v\", err)\n")
	fmt.Fprintf(file, "\t\t}\n")
	fmt.Fprintf(file, "\t}\n")
	fmt.Fprintf(file, "\treturn SanitizeError(err)\n")
	fmt.Fprintf(file, "}\n\n")

	fmt.Fprintf(file, "// Save updates or creates a record (upsert)\n")
	fmt.Fprintf(file, "func (q *Query) Save(ctx context.Context, value interface{}) error {\n")
	fmt.Fprintf(file, "\tctx, cancel := WithQueryTimeout(ctx)\n")
	fmt.Fprintf(file, "\tdefer cancel()\n\n")
	fmt.Fprintf(file, "\tif q.primaryKey == \"\" {\n")
	fmt.Fprintf(file, "\t\treturn q.Create(ctx, value)\n")
	fmt.Fprintf(file, "\t}\n\n")
	fmt.Fprintf(file, "\tprocessStart := time.Now()\n")
	fmt.Fprintf(file, "\tquery, args := q.buildUpsertQuery(value)\n\n")
	fmt.Fprintf(file, "\tqueryStart := time.Now()\n")
	fmt.Fprintf(file, "\t_, err := q.db.Exec(ctx, query, args...)\n")
	fmt.Fprintf(file, "\tqueryEnd := time.Now()\n")
	fmt.Fprintf(file, "\tqueryDuration := queryEnd.Sub(queryStart)\n\n")
	fmt.Fprintf(file, "\tq.logQueryWithTiming(ctx, query, args, queryStart, processStart, queryDuration)\n\n")
	fmt.Fprintf(file, "\tif err != nil {\n")
	fmt.Fprintf(file, "\t\tif logger := q.getLogger(); logger != nil {\n")
	fmt.Fprintf(file, "\t\t\tlogger.Error(\"UPSERT query failed: %%v\", err)\n")
	fmt.Fprintf(file, "\t\t}\n")
	fmt.Fprintf(file, "\t}\n")
	fmt.Fprintf(file, "\treturn SanitizeError(err)\n")
	fmt.Fprintf(file, "}\n\n")

	fmt.Fprintf(file, "// Update updates records\n")
	fmt.Fprintf(file, "func (q *Query) Update(ctx context.Context, column string, value interface{}) error {\n")
	fmt.Fprintf(file, "\tctx, cancel := WithQueryTimeout(ctx)\n")
	fmt.Fprintf(file, "\tdefer cancel()\n\n")
	fmt.Fprintf(file, "\tprocessStart := time.Now()\n")
	fmt.Fprintf(file, "\tquery, args := q.buildUpdateQuery(column, value)\n\n")
	fmt.Fprintf(file, "\tqueryStart := time.Now()\n")
	fmt.Fprintf(file, "\t_, err := q.db.Exec(ctx, query, args...)\n")
	fmt.Fprintf(file, "\tqueryEnd := time.Now()\n")
	fmt.Fprintf(file, "\tqueryDuration := queryEnd.Sub(queryStart)\n\n")
	fmt.Fprintf(file, "\tq.logQueryWithTiming(ctx, query, args, queryStart, processStart, queryDuration)\n\n")
	fmt.Fprintf(file, "\tif err != nil {\n")
	fmt.Fprintf(file, "\t\tif logger := q.getLogger(); logger != nil {\n")
	fmt.Fprintf(file, "\t\t\tlogger.Error(\"UPDATE query failed: %%v\", err)\n")
	fmt.Fprintf(file, "\t\t}\n")
	fmt.Fprintf(file, "\t}\n")
	fmt.Fprintf(file, "\treturn SanitizeError(err)\n")
	fmt.Fprintf(file, "}\n\n")

	fmt.Fprintf(file, "// Updates updates multiple columns\n")
	fmt.Fprintf(file, "func (q *Query) Updates(ctx context.Context, values map[string]interface{}) error {\n")
	fmt.Fprintf(file, "\tctx, cancel := WithQueryTimeout(ctx)\n")
	fmt.Fprintf(file, "\tdefer cancel()\n\n")
	fmt.Fprintf(file, "\tprocessStart := time.Now()\n")
	fmt.Fprintf(file, "\tquery, args := q.buildUpdatesQuery(values)\n\n")
	fmt.Fprintf(file, "\tqueryStart := time.Now()\n")
	fmt.Fprintf(file, "\t_, err := q.db.Exec(ctx, query, args...)\n")
	fmt.Fprintf(file, "\tqueryEnd := time.Now()\n")
	fmt.Fprintf(file, "\tqueryDuration := queryEnd.Sub(queryStart)\n\n")
	fmt.Fprintf(file, "\tq.logQueryWithTiming(ctx, query, args, queryStart, processStart, queryDuration)\n\n")
	fmt.Fprintf(file, "\tif err != nil {\n")
	fmt.Fprintf(file, "\t\tif logger := q.getLogger(); logger != nil {\n")
	fmt.Fprintf(file, "\t\t\tlogger.Error(\"UPDATE query failed: %%v\", err)\n")
	fmt.Fprintf(file, "\t\t}\n")
	fmt.Fprintf(file, "\t}\n")
	fmt.Fprintf(file, "\treturn SanitizeError(err)\n")
	fmt.Fprintf(file, "}\n\n")

	fmt.Fprintf(file, "// Delete removes records\n")
	fmt.Fprintf(file, "func (q *Query) Delete(ctx context.Context, value interface{}) error {\n")
	fmt.Fprintf(file, "\tctx, cancel := WithQueryTimeout(ctx)\n")
	fmt.Fprintf(file, "\tdefer cancel()\n\n")
	fmt.Fprintf(file, "\tprocessStart := time.Now()\n")
	fmt.Fprintf(file, "\tquery, args := q.buildDeleteQuery()\n\n")
	fmt.Fprintf(file, "\tqueryStart := time.Now()\n")
	fmt.Fprintf(file, "\t_, err := q.db.Exec(ctx, query, args...)\n")
	fmt.Fprintf(file, "\tqueryEnd := time.Now()\n")
	fmt.Fprintf(file, "\tqueryDuration := queryEnd.Sub(queryStart)\n\n")
	fmt.Fprintf(file, "\tq.logQueryWithTiming(ctx, query, args, queryStart, processStart, queryDuration)\n\n")
	fmt.Fprintf(file, "\tif err != nil {\n")
	fmt.Fprintf(file, "\t\tif logger := q.getLogger(); logger != nil {\n")
	fmt.Fprintf(file, "\t\t\tlogger.Error(\"DELETE query failed: %%v\", err)\n")
	fmt.Fprintf(file, "\t\t}\n")
	fmt.Fprintf(file, "\t}\n")
	fmt.Fprintf(file, "\treturn SanitizeError(err)\n")
	fmt.Fprintf(file, "}\n\n")
}

// generateQueryBuildHelpers generates buildSelectQuery, buildWhereClause, etc.
func generateQueryBuildHelpers(file *os.File) {
	fmt.Fprintf(file, "// buildSelectQuery builds the SELECT query\n")
	fmt.Fprintf(file, "func (q *Query) buildSelectQuery(single bool) (string, []interface{}) {\n")
	fmt.Fprintf(file, "\tvar parts []string\n")
	fmt.Fprintf(file, "\tvar args []interface{}\n")
	fmt.Fprintf(file, "\targIndex := 1\n\n")
	fmt.Fprintf(file, "\t// SELECT\n")
	fmt.Fprintf(file, "\tparts = append(parts, \"SELECT\")\n")
	fmt.Fprintf(file, "\tif len(q.selectFields) > 0 {\n")
	fmt.Fprintf(file, "\t\tquotedFields := make([]string, len(q.selectFields))\n")
	fmt.Fprintf(file, "\t\tfor i, field := range q.selectFields {\n")
	fmt.Fprintf(file, "\t\t\tquotedFields[i] = q.dialect.QuoteIdentifier(field)\n")
	fmt.Fprintf(file, "\t\t}\n")
	fmt.Fprintf(file, "\t\tparts = append(parts, strings.Join(quotedFields, \", \"))\n")
	fmt.Fprintf(file, "\t} else {\n")
	fmt.Fprintf(file, "\t\tquotedColumns := make([]string, len(q.columns))\n")
	fmt.Fprintf(file, "\t\tfor i, col := range q.columns {\n")
	fmt.Fprintf(file, "\t\t\tquotedColumns[i] = q.dialect.QuoteIdentifier(col)\n")
	fmt.Fprintf(file, "\t\t}\n")
	fmt.Fprintf(file, "\t\tparts = append(parts, strings.Join(quotedColumns, \", \"))\n")
	fmt.Fprintf(file, "\t}\n\n")
	fmt.Fprintf(file, "\t// FROM\n")
	fmt.Fprintf(file, "\tparts = append(parts, \"FROM\", q.dialect.QuoteIdentifier(q.table))\n\n")
	fmt.Fprintf(file, "\t// JOINs\n")
	fmt.Fprintf(file, "\tfor _, join := range q.joins {\n")
	fmt.Fprintf(file, "\t\tparts = append(parts, fmt.Sprintf(\"%%s JOIN %%s ON %%s\", join.joinType, q.dialect.QuoteIdentifier(join.table), join.on))\n")
	fmt.Fprintf(file, "\t\targs = append(args, join.args...)\n")
	fmt.Fprintf(file, "\t\targIndex += len(join.args)\n")
	fmt.Fprintf(file, "\t}\n\n")
	fmt.Fprintf(file, "\t// WHERE\n")
	fmt.Fprintf(file, "\tif len(q.whereConditions) > 0 {\n")
	fmt.Fprintf(file, "\t\twhereClause, whereArgs := q.buildWhereClause(&argIndex)\n")
	fmt.Fprintf(file, "\t\tparts = append(parts, \"WHERE\", whereClause)\n")
	fmt.Fprintf(file, "\t\targs = append(args, whereArgs...)\n")
	fmt.Fprintf(file, "\t}\n\n")
	fmt.Fprintf(file, "\t// GROUP BY\n")
	fmt.Fprintf(file, "\tif len(q.groupBy) > 0 {\n")
	fmt.Fprintf(file, "\t\tquotedGroupBy := make([]string, len(q.groupBy))\n")
	fmt.Fprintf(file, "\t\tfor i, field := range q.groupBy {\n")
	fmt.Fprintf(file, "\t\t\tquotedGroupBy[i] = q.dialect.QuoteIdentifier(field)\n")
	fmt.Fprintf(file, "\t\t}\n")
	fmt.Fprintf(file, "\t\tparts = append(parts, \"GROUP BY\", strings.Join(quotedGroupBy, \", \"))\n")
	fmt.Fprintf(file, "\t}\n\n")
	fmt.Fprintf(file, "\t// HAVING\n")
	fmt.Fprintf(file, "\tif len(q.having) > 0 {\n")
	fmt.Fprintf(file, "\t\thavingClause, havingArgs := q.buildHavingClause(&argIndex)\n")
	fmt.Fprintf(file, "\t\tparts = append(parts, \"HAVING\", havingClause)\n")
	fmt.Fprintf(file, "\t\targs = append(args, havingArgs...)\n")
	fmt.Fprintf(file, "\t}\n\n")
	fmt.Fprintf(file, "\t// ORDER BY\n")
	fmt.Fprintf(file, "\tif len(q.orderBy) > 0 {\n")
	fmt.Fprintf(file, "\t\tvar orderParts []string\n")
	fmt.Fprintf(file, "\t\tfor _, order := range q.orderBy {\n")
	fmt.Fprintf(file, "\t\t\torderParts = append(orderParts, fmt.Sprintf(\"%%s %%s\", q.dialect.QuoteIdentifier(order.Field), order.Order))\n")
	fmt.Fprintf(file, "\t\t}\n")
	fmt.Fprintf(file, "\t\tparts = append(parts, \"ORDER BY\", strings.Join(orderParts, \", \"))\n")
	fmt.Fprintf(file, "\t}\n\n")
	fmt.Fprintf(file, "\tif single {\n")
	fmt.Fprintf(file, "\t\tparts = append(parts, \"LIMIT 1\")\n")
	fmt.Fprintf(file, "\t} else if q.take != nil || q.skip != nil {\n")
	fmt.Fprintf(file, "\t\tlimit := 0\n")
	fmt.Fprintf(file, "\t\toffset := 0\n")
	fmt.Fprintf(file, "\t\tif q.take != nil {\n")
	fmt.Fprintf(file, "\t\t\tlimit = *q.take\n")
	fmt.Fprintf(file, "\t\t}\n")
	fmt.Fprintf(file, "\t\tif q.skip != nil {\n")
	fmt.Fprintf(file, "\t\t\toffset = *q.skip\n")
	fmt.Fprintf(file, "\t\t}\n")
	fmt.Fprintf(file, "\t\tlimitOffset := q.dialect.GetLimitOffsetSyntax(limit, offset)\n")
	fmt.Fprintf(file, "\t\tif limitOffset != \"\" {\n")
	fmt.Fprintf(file, "\t\t\tparts = append(parts, limitOffset)\n")
	fmt.Fprintf(file, "\t\t}\n")
	fmt.Fprintf(file, "\t\t// Note: GetLimitOffsetSyntax already includes the values in the SQL string,\n")
	fmt.Fprintf(file, "\t\t// so we don't need to add them to args\n")
	fmt.Fprintf(file, "\t}\n\n")
	fmt.Fprintf(file, "\treturn strings.Join(parts, \" \"), args\n")
	fmt.Fprintf(file, "}\n\n")

	fmt.Fprintf(file, "// buildWhereClause builds the WHERE clause\n")
	fmt.Fprintf(file, "func (q *Query) buildWhereClause(argIndex *int) (string, []interface{}) {\n")
	fmt.Fprintf(file, "\tif len(q.whereConditions) == 0 {\n")
	fmt.Fprintf(file, "\t\treturn \"\", nil\n")
	fmt.Fprintf(file, "\t}\n\n")
	fmt.Fprintf(file, "\tvar parts []string\n")
	fmt.Fprintf(file, "\tvar args []interface{}\n\n")
	fmt.Fprintf(file, "\tfor i, cond := range q.whereConditions {\n")
	fmt.Fprintf(file, "\t\tif i > 0 {\n")
	fmt.Fprintf(file, "\t\t\tif cond.or {\n")
	fmt.Fprintf(file, "\t\t\t\tparts = append(parts, \"OR\")\n")
	fmt.Fprintf(file, "\t\t\t} else {\n")
	fmt.Fprintf(file, "\t\t\t\tparts = append(parts, \"AND\")\n")
	fmt.Fprintf(file, "\t\t\t}\n")
	fmt.Fprintf(file, "\t\t}\n\n")
	fmt.Fprintf(file, "\t\tquery := cond.query\n")
	fmt.Fprintf(file, "\t\tvar queryBuilder strings.Builder\n")
	fmt.Fprintf(file, "\t\tqueryBuilder.Grow(len(query) + 100)\n\n")
	fmt.Fprintf(file, "\t\targPos := 0\n")
	fmt.Fprintf(file, "\t\tfor i := 0; i < len(query); i++ {\n")
	fmt.Fprintf(file, "\t\t\tif query[i] == '?' && argPos < len(cond.args) {\n")
	fmt.Fprintf(file, "\t\t\t\targ := cond.args[argPos]\n")
	fmt.Fprintf(file, "\t\t\t\tif reflect.TypeOf(arg).Kind() == reflect.Slice {\n")
	fmt.Fprintf(file, "\t\t\t\t\tslice := reflect.ValueOf(arg)\n")
	fmt.Fprintf(file, "\t\t\t\t\tplaceholders := make([]string, slice.Len())\n")
	fmt.Fprintf(file, "\t\t\t\t\tfor j := 0; j < slice.Len(); j++ {\n")
	fmt.Fprintf(file, "\t\t\t\t\t\tplaceholders[j] = q.dialect.GetPlaceholder(*argIndex)\n")
	fmt.Fprintf(file, "\t\t\t\t\t\targs = append(args, slice.Index(j).Interface())\n")
	fmt.Fprintf(file, "\t\t\t\t\t\t(*argIndex)++\n")
	fmt.Fprintf(file, "\t\t\t\t\t}\n")
	fmt.Fprintf(file, "\t\t\t\t\tqueryBuilder.WriteString(fmt.Sprintf(\"(%%s)\", strings.Join(placeholders, \", \")))\n")
	fmt.Fprintf(file, "\t\t\t\t} else {\n")
	fmt.Fprintf(file, "\t\t\t\t\tqueryBuilder.WriteString(q.dialect.GetPlaceholder(*argIndex))\n")
	fmt.Fprintf(file, "\t\t\t\t\targs = append(args, arg)\n")
	fmt.Fprintf(file, "\t\t\t\t\t(*argIndex)++\n")
	fmt.Fprintf(file, "\t\t\t\t}\n")
	fmt.Fprintf(file, "\t\t\t\targPos++\n")
	fmt.Fprintf(file, "\t\t\t} else {\n")
	fmt.Fprintf(file, "\t\t\t\tqueryBuilder.WriteByte(query[i])\n")
	fmt.Fprintf(file, "\t\t\t}\n")
	fmt.Fprintf(file, "\t\t}\n")
	fmt.Fprintf(file, "\t\tquery = queryBuilder.String()\n\n")
	fmt.Fprintf(file, "\t\tparts = append(parts, query)\n")
	fmt.Fprintf(file, "\t}\n\n")
	fmt.Fprintf(file, "\treturn strings.Join(parts, \" \"), args\n")
	fmt.Fprintf(file, "}\n\n")

	fmt.Fprintf(file, "// buildHavingClause builds the HAVING clause\n")
	fmt.Fprintf(file, "func (q *Query) buildHavingClause(argIndex *int) (string, []interface{}) {\n")
	fmt.Fprintf(file, "\treturn q.buildWhereClause(argIndex)\n")
	fmt.Fprintf(file, "}\n\n")

	fmt.Fprintf(file, "// buildCountQuery builds the COUNT query\n")
	fmt.Fprintf(file, "func (q *Query) buildCountQuery() (string, []interface{}) {\n")
	fmt.Fprintf(file, "\tvar parts []string\n")
	fmt.Fprintf(file, "\tvar args []interface{}\n")
	fmt.Fprintf(file, "\targIndex := 1\n\n")
	fmt.Fprintf(file, "\tparts = append(parts, \"SELECT COUNT(*) FROM\", q.dialect.QuoteIdentifier(q.table))\n\n")
	fmt.Fprintf(file, "\t// JOINs\n")
	fmt.Fprintf(file, "\tfor _, join := range q.joins {\n")
	fmt.Fprintf(file, "\t\tparts = append(parts, fmt.Sprintf(\"%%s JOIN %%s ON %%s\", join.joinType, q.dialect.QuoteIdentifier(join.table), join.on))\n")
	fmt.Fprintf(file, "\t\targs = append(args, join.args...)\n")
	fmt.Fprintf(file, "\t\targIndex += len(join.args)\n")
	fmt.Fprintf(file, "\t}\n\n")
	fmt.Fprintf(file, "\t// WHERE\n")
	fmt.Fprintf(file, "\tif len(q.whereConditions) > 0 {\n")
	fmt.Fprintf(file, "\t\twhereClause, whereArgs := q.buildWhereClause(&argIndex)\n")
	fmt.Fprintf(file, "\t\tparts = append(parts, \"WHERE\", whereClause)\n")
	fmt.Fprintf(file, "\t\targs = append(args, whereArgs...)\n")
	fmt.Fprintf(file, "\t}\n\n")
	fmt.Fprintf(file, "\treturn strings.Join(parts, \" \"), args\n")
	fmt.Fprintf(file, "}\n\n")

	fmt.Fprintf(file, "// buildInsertQuery builds the INSERT query\n")
	fmt.Fprintf(file, "func (q *Query) buildInsertQuery(value interface{}) (string, []interface{}) {\n")
	fmt.Fprintf(file, "\tval := reflect.ValueOf(value)\n")
	fmt.Fprintf(file, "\tif val.Kind() == reflect.Ptr {\n")
	fmt.Fprintf(file, "\t\tval = val.Elem()\n")
	fmt.Fprintf(file, "\t}\n")
	fmt.Fprintf(file, "\tif val.Kind() != reflect.Struct {\n")
	fmt.Fprintf(file, "\t\treturn \"\", nil\n")
	fmt.Fprintf(file, "\t}\n\n")
	fmt.Fprintf(file, "\tvar columns []string\n")
	fmt.Fprintf(file, "\tvar values []string\n")
	fmt.Fprintf(file, "\tvar args []interface{}\n")
	fmt.Fprintf(file, "\targIndex := 1\n\n")
	fmt.Fprintf(file, "\ttyp := val.Type()\n")
	fmt.Fprintf(file, "\tvar primaryKeyValue interface{}\n")
	fmt.Fprintf(file, "\tvar primaryKeyCol string\n")
	fmt.Fprintf(file, "\tvar primaryKeyType reflect.Kind\n")
	fmt.Fprintf(file, "\tvar primaryKeyIsZero bool\n\n")
	fmt.Fprintf(file, "\tfor i := 0; i < val.NumField(); i++ {\n")
	fmt.Fprintf(file, "\t\tfield := typ.Field(i)\n")
	fmt.Fprintf(file, "\t\tfieldVal := val.Field(i)\n")
	fmt.Fprintf(file, "\t\t// Use db tag if available, otherwise use snake_case of field name\n")
	fmt.Fprintf(file, "\t\tdbTag := field.Tag.Get(\"db\")\n")
	fmt.Fprintf(file, "\t\tfieldName := dbTag\n")
	fmt.Fprintf(file, "\t\tif fieldName == \"\" {\n")
	fmt.Fprintf(file, "\t\t\tfieldName = toSnakeCase(field.Name)\n")
	fmt.Fprintf(file, "\t\t}\n\n")
	fmt.Fprintf(file, "\t\tif fieldName == q.primaryKey {\n")
	fmt.Fprintf(file, "\t\t\tprimaryKeyCol = fieldName\n")
	fmt.Fprintf(file, "\t\t\tprimaryKeyValue = fieldVal.Interface()\n")
	fmt.Fprintf(file, "\t\t\tprimaryKeyType = fieldVal.Kind()\n")
	fmt.Fprintf(file, "\t\t\tprimaryKeyIsZero = fieldVal.IsZero()\n")
	fmt.Fprintf(file, "\t\t\tcontinue\n")
	fmt.Fprintf(file, "\t\t}\n\n")
	fmt.Fprintf(file, "\t\tif fieldVal.IsZero() {\n")
	fmt.Fprintf(file, "\t\t\tcontinue\n")
	fmt.Fprintf(file, "\t\t}\n\n")
	fmt.Fprintf(file, "\t\tcolumns = append(columns, fieldName)\n")
	fmt.Fprintf(file, "\t\tvalues = append(values, q.dialect.GetPlaceholder(argIndex))\n")
	fmt.Fprintf(file, "\t\targs = append(args, fieldVal.Interface())\n")
	fmt.Fprintf(file, "\t\targIndex++\n")
	fmt.Fprintf(file, "\t}\n\n")
	fmt.Fprintf(file, "\tif primaryKeyCol != \"\" {\n")
	fmt.Fprintf(file, "\t\tif !primaryKeyIsZero {\n")
	fmt.Fprintf(file, "\t\t\tcolumns = append(columns, primaryKeyCol)\n")
	fmt.Fprintf(file, "\t\t\tvalues = append(values, q.dialect.GetPlaceholder(argIndex))\n")
	fmt.Fprintf(file, "\t\t\targs = append(args, primaryKeyValue)\n")
	fmt.Fprintf(file, "\t\t\targIndex++\n")
	fmt.Fprintf(file, "\t\t} else if primaryKeyType == reflect.String {\n")
	fmt.Fprintf(file, "\t\t\tgeneratedUUID := utils.GenerateUUID()\n")
	fmt.Fprintf(file, "\t\t\tcolumns = append(columns, primaryKeyCol)\n")
	fmt.Fprintf(file, "\t\t\tvalues = append(values, q.dialect.GetPlaceholder(argIndex))\n")
	fmt.Fprintf(file, "\t\t\targs = append(args, generatedUUID)\n")
	fmt.Fprintf(file, "\t\t\targIndex++\n")
	fmt.Fprintf(file, "\t\t}\n")
	fmt.Fprintf(file, "\t}\n\n")
	fmt.Fprintf(file, "\tquotedColumns := make([]string, len(columns))\n")
	fmt.Fprintf(file, "\tfor i, col := range columns {\n")
	fmt.Fprintf(file, "\t\tquotedColumns[i] = q.dialect.QuoteIdentifier(col)\n")
	fmt.Fprintf(file, "\t}\n\n")
	fmt.Fprintf(file, "\tquery := fmt.Sprintf(\n")
	fmt.Fprintf(file, "\t\t\"INSERT INTO %%s (%%s) VALUES (%%s)\",\n")
	fmt.Fprintf(file, "\t\tq.dialect.QuoteIdentifier(q.table),\n")
	fmt.Fprintf(file, "\t\tstrings.Join(quotedColumns, \", \"),\n")
	fmt.Fprintf(file, "\t\tstrings.Join(values, \", \"),\n")
	fmt.Fprintf(file, "\t)\n\n")
	fmt.Fprintf(file, "\treturn query, args\n")
	fmt.Fprintf(file, "}\n\n")

	fmt.Fprintf(file, "// buildUpsertQuery builds an INSERT ... ON CONFLICT (upsert) query\n")
	fmt.Fprintf(file, "func (q *Query) buildUpsertQuery(value interface{}) (string, []interface{}) {\n")
	fmt.Fprintf(file, "\tval := reflect.ValueOf(value)\n")
	fmt.Fprintf(file, "\tif val.Kind() == reflect.Ptr {\n")
	fmt.Fprintf(file, "\t\tval = val.Elem()\n")
	fmt.Fprintf(file, "\t}\n")
	fmt.Fprintf(file, "\tif val.Kind() != reflect.Struct {\n")
	fmt.Fprintf(file, "\t\treturn \"\", nil\n")
	fmt.Fprintf(file, "\t}\n\n")
	fmt.Fprintf(file, "\tvar columns []string\n")
	fmt.Fprintf(file, "\tvar values []string\n")
	fmt.Fprintf(file, "\tvar args []interface{}\n")
	fmt.Fprintf(file, "\targIndex := 1\n\n")
	fmt.Fprintf(file, "\ttyp := val.Type()\n")
	fmt.Fprintf(file, "\tvar primaryKeyValue interface{}\n")
	fmt.Fprintf(file, "\tvar primaryKeyCol string\n\n")
	fmt.Fprintf(file, "\tfor i := 0; i < val.NumField(); i++ {\n")
	fmt.Fprintf(file, "\t\tfield := typ.Field(i)\n")
	fmt.Fprintf(file, "\t\tfieldVal := val.Field(i)\n")
	fmt.Fprintf(file, "\t\t// Use db tag if available, otherwise use snake_case of field name\n")
	fmt.Fprintf(file, "\t\tdbTag := field.Tag.Get(\"db\")\n")
	fmt.Fprintf(file, "\t\tfieldName := dbTag\n")
	fmt.Fprintf(file, "\t\tif fieldName == \"\" {\n")
	fmt.Fprintf(file, "\t\t\tfieldName = toSnakeCase(field.Name)\n")
	fmt.Fprintf(file, "\t\t}\n\n")
	fmt.Fprintf(file, "\t\tif fieldName == q.primaryKey {\n")
	fmt.Fprintf(file, "\t\t\tprimaryKeyCol = fieldName\n")
	fmt.Fprintf(file, "\t\t\tprimaryKeyValue = fieldVal.Interface()\n")
	fmt.Fprintf(file, "\t\t\tcontinue\n")
	fmt.Fprintf(file, "\t\t}\n\n")
	fmt.Fprintf(file, "\t\tif fieldVal.IsZero() {\n")
	fmt.Fprintf(file, "\t\t\tcontinue\n")
	fmt.Fprintf(file, "\t\t}\n\n")
	fmt.Fprintf(file, "\t\tcolumns = append(columns, fieldName)\n")
	fmt.Fprintf(file, "\t\tvalues = append(values, q.dialect.GetPlaceholder(argIndex))\n")
	fmt.Fprintf(file, "\t\targs = append(args, fieldVal.Interface())\n")
	fmt.Fprintf(file, "\t\targIndex++\n")
	fmt.Fprintf(file, "\t}\n\n")
	fmt.Fprintf(file, "\tif primaryKeyCol != \"\" && primaryKeyValue != nil {\n")
	fmt.Fprintf(file, "\t\tcolumns = append(columns, primaryKeyCol)\n")
	fmt.Fprintf(file, "\t\tvalues = append(values, q.dialect.GetPlaceholder(argIndex))\n")
	fmt.Fprintf(file, "\t\targs = append(args, primaryKeyValue)\n")
	fmt.Fprintf(file, "\t\targIndex++\n")
	fmt.Fprintf(file, "\t}\n\n")
	fmt.Fprintf(file, "\tquotedColumns := make([]string, len(columns))\n")
	fmt.Fprintf(file, "\tfor i, col := range columns {\n")
	fmt.Fprintf(file, "\t\tquotedColumns[i] = q.dialect.QuoteIdentifier(col)\n")
	fmt.Fprintf(file, "\t}\n\n")
	fmt.Fprintf(file, "\tquotedTable := q.dialect.QuoteIdentifier(q.table)\n")
	fmt.Fprintf(file, "\tinsertPart := fmt.Sprintf(\n")
	fmt.Fprintf(file, "\t\t\"INSERT INTO %%s (%%s) VALUES (%%s)\",\n")
	fmt.Fprintf(file, "\t\tquotedTable,\n")
	fmt.Fprintf(file, "\t\tstrings.Join(quotedColumns, \", \"),\n")
	fmt.Fprintf(file, "\t\tstrings.Join(values, \", \"),\n")
	fmt.Fprintf(file, "\t)\n\n")
	fmt.Fprintf(file, "\tdialectName := q.dialect.Name()\n")
	fmt.Fprintf(file, "\tvar conflictPart string\n\n")
	fmt.Fprintf(file, "\tif dialectName == \"postgresql\" || dialectName == \"postgres\" || dialectName == \"sqlite\" {\n")
	fmt.Fprintf(file, "\t\tif primaryKeyCol != \"\" {\n")
	fmt.Fprintf(file, "\t\t\tquotedPK := q.dialect.QuoteIdentifier(primaryKeyCol)\n")
	fmt.Fprintf(file, "\t\t\tvar updateParts []string\n")
	fmt.Fprintf(file, "\t\t\tfor _, col := range columns {\n")
	fmt.Fprintf(file, "\t\t\t\tif col == primaryKeyCol {\n")
	fmt.Fprintf(file, "\t\t\t\t\tcontinue\n")
	fmt.Fprintf(file, "\t\t\t\t}\n")
	fmt.Fprintf(file, "\t\t\t\tquotedCol := q.dialect.QuoteIdentifier(col)\n")
	fmt.Fprintf(file, "\t\t\t\tupdateParts = append(updateParts, fmt.Sprintf(\"%%s = EXCLUDED.%%s\", quotedCol, quotedCol))\n")
	fmt.Fprintf(file, "\t\t\t}\n")
	fmt.Fprintf(file, "\t\t\tconflictPart = fmt.Sprintf(\"ON CONFLICT (%%s) DO UPDATE SET %%s\", quotedPK, strings.Join(updateParts, \", \"))\n")
	fmt.Fprintf(file, "\t\t} else {\n")
	fmt.Fprintf(file, "\t\t\treturn insertPart, args\n")
	fmt.Fprintf(file, "\t\t}\n")
	fmt.Fprintf(file, "\t} else if dialectName == \"mysql\" || dialectName == \"mariadb\" {\n")
	fmt.Fprintf(file, "\t\tif primaryKeyCol != \"\" {\n")
	fmt.Fprintf(file, "\t\t\tvar updateParts []string\n")
	fmt.Fprintf(file, "\t\t\tfor _, col := range columns {\n")
	fmt.Fprintf(file, "\t\t\t\tif col == primaryKeyCol {\n")
	fmt.Fprintf(file, "\t\t\t\t\tcontinue\n")
	fmt.Fprintf(file, "\t\t\t\t}\n")
	fmt.Fprintf(file, "\t\t\t\tquotedCol := q.dialect.QuoteIdentifier(col)\n")
	fmt.Fprintf(file, "\t\t\t\tupdateParts = append(updateParts, fmt.Sprintf(\"%%s = VALUES(%%s)\", quotedCol, quotedCol))\n")
	fmt.Fprintf(file, "\t\t\t}\n")
	fmt.Fprintf(file, "\t\t\tconflictPart = fmt.Sprintf(\"ON DUPLICATE KEY UPDATE %%s\", strings.Join(updateParts, \", \"))\n")
	fmt.Fprintf(file, "\t\t} else {\n")
	fmt.Fprintf(file, "\t\t\treturn insertPart, args\n")
	fmt.Fprintf(file, "\t\t}\n")
	fmt.Fprintf(file, "\t} else {\n")
	fmt.Fprintf(file, "\t\treturn insertPart, args\n")
	fmt.Fprintf(file, "\t}\n\n")
	fmt.Fprintf(file, "\tquery := fmt.Sprintf(\"%%s %%s\", insertPart, conflictPart)\n")
	fmt.Fprintf(file, "\treturn query, args\n")
	fmt.Fprintf(file, "}\n\n")

	fmt.Fprintf(file, "// buildUpdateQuery builds the UPDATE query\n")
	fmt.Fprintf(file, "func (q *Query) buildUpdateQuery(column string, value interface{}) (string, []interface{}) {\n")
	fmt.Fprintf(file, "\tvar parts []string\n")
	fmt.Fprintf(file, "\tvar args []interface{}\n")
	fmt.Fprintf(file, "\targIndex := 1\n\n")
	fmt.Fprintf(file, "\tparts = append(parts, fmt.Sprintf(\"UPDATE %%s SET %%s = %%s\",\n")
	fmt.Fprintf(file, "\t\tq.dialect.QuoteIdentifier(q.table),\n")
	fmt.Fprintf(file, "\t\tq.dialect.QuoteIdentifier(column),\n")
	fmt.Fprintf(file, "\t\tq.dialect.GetPlaceholder(argIndex)))\n")
	fmt.Fprintf(file, "\targs = append(args, value)\n")
	fmt.Fprintf(file, "\targIndex++\n\n")
	fmt.Fprintf(file, "\t// WHERE\n")
	fmt.Fprintf(file, "\tif len(q.whereConditions) > 0 {\n")
	fmt.Fprintf(file, "\t\twhereClause, whereArgs := q.buildWhereClause(&argIndex)\n")
	fmt.Fprintf(file, "\t\tparts = append(parts, \"WHERE\", whereClause)\n")
	fmt.Fprintf(file, "\t\targs = append(args, whereArgs...)\n")
	fmt.Fprintf(file, "\t}\n\n")
	fmt.Fprintf(file, "\treturn strings.Join(parts, \" \"), args\n")
	fmt.Fprintf(file, "}\n\n")

	fmt.Fprintf(file, "// buildUpdatesQuery builds the UPDATE query with multiple columns\n")
	fmt.Fprintf(file, "func (q *Query) buildUpdatesQuery(values map[string]interface{}) (string, []interface{}) {\n")
	fmt.Fprintf(file, "\tvar parts []string\n")
	fmt.Fprintf(file, "\tvar args []interface{}\n")
	fmt.Fprintf(file, "\targIndex := 1\n\n")
	fmt.Fprintf(file, "\tvar setParts []string\n")
	fmt.Fprintf(file, "\tfor col, val := range values {\n")
	fmt.Fprintf(file, "\t\tsetParts = append(setParts, fmt.Sprintf(\"%%s = %%s\",\n")
	fmt.Fprintf(file, "\t\t\tq.dialect.QuoteIdentifier(col),\n")
	fmt.Fprintf(file, "\t\t\tq.dialect.GetPlaceholder(argIndex)))\n")
	fmt.Fprintf(file, "\t\targs = append(args, val)\n")
	fmt.Fprintf(file, "\t\targIndex++\n")
	fmt.Fprintf(file, "\t}\n\n")
	fmt.Fprintf(file, "\tparts = append(parts, fmt.Sprintf(\"UPDATE %%s SET %%s\",\n")
	fmt.Fprintf(file, "\t\tq.dialect.QuoteIdentifier(q.table),\n")
	fmt.Fprintf(file, "\t\tstrings.Join(setParts, \", \")))\n\n")
	fmt.Fprintf(file, "\t// WHERE\n")
	fmt.Fprintf(file, "\tif len(q.whereConditions) > 0 {\n")
	fmt.Fprintf(file, "\t\twhereClause, whereArgs := q.buildWhereClause(&argIndex)\n")
	fmt.Fprintf(file, "\t\tparts = append(parts, \"WHERE\", whereClause)\n")
	fmt.Fprintf(file, "\t\targs = append(args, whereArgs...)\n")
	fmt.Fprintf(file, "\t}\n\n")
	fmt.Fprintf(file, "\treturn strings.Join(parts, \" \"), args\n")
	fmt.Fprintf(file, "}\n\n")

	fmt.Fprintf(file, "// buildDeleteQuery builds the DELETE query\n")
	fmt.Fprintf(file, "func (q *Query) buildDeleteQuery() (string, []interface{}) {\n")
	fmt.Fprintf(file, "\tvar parts []string\n")
	fmt.Fprintf(file, "\tvar args []interface{}\n")
	fmt.Fprintf(file, "\targIndex := 1\n\n")
	fmt.Fprintf(file, "\tparts = append(parts, fmt.Sprintf(\"DELETE FROM %%s\", q.dialect.QuoteIdentifier(q.table)))\n\n")
	fmt.Fprintf(file, "\t// WHERE\n")
	fmt.Fprintf(file, "\tif len(q.whereConditions) > 0 {\n")
	fmt.Fprintf(file, "\t\twhereClause, whereArgs := q.buildWhereClause(&argIndex)\n")
	fmt.Fprintf(file, "\t\tparts = append(parts, \"WHERE\", whereClause)\n")
	fmt.Fprintf(file, "\t\targs = append(args, whereArgs...)\n")
	fmt.Fprintf(file, "\t}\n\n")
	fmt.Fprintf(file, "\treturn strings.Join(parts, \" \"), args\n")
	fmt.Fprintf(file, "}\n\n")
}

// generateQueryScanHelpers generates scanRowIntoModel, scanRowsIntoModel, etc.
func generateQueryScanHelpers(file *os.File) {
	fmt.Fprintf(file, "// scanRowIntoModel scans a row into a model\n")
	fmt.Fprintf(file, "func (q *Query) scanRowIntoModel(row interface{}, dest interface{}) error {\n")
	fmt.Fprintf(file, "\tif driverRow, ok := row.(Row); ok {\n")
	fmt.Fprintf(file, "\t\tdestVal := reflect.ValueOf(dest)\n")
	fmt.Fprintf(file, "\t\tif destVal.Kind() != reflect.Ptr {\n")
	fmt.Fprintf(file, "\t\t\treturn SanitizeError(fmt.Errorf(\"dest must be a pointer\"))\n")
	fmt.Fprintf(file, "\t\t}\n")
	fmt.Fprintf(file, "\t\tdestVal = destVal.Elem()\n\n")
	fmt.Fprintf(file, "\t\tif q.modelType == nil {\n")
	fmt.Fprintf(file, "\t\t\treturn SanitizeError(fmt.Errorf(\"modelType not defined\"))\n")
	fmt.Fprintf(file, "\t\t}\n\n")
	fmt.Fprintf(file, "\t\tmodelValue := reflect.New(q.modelType).Elem()\n\n")
	fmt.Fprintf(file, "\t\tcolumnsToScan := q.columns\n")
	fmt.Fprintf(file, "\t\tif len(q.selectFields) > 0 {\n")
	fmt.Fprintf(file, "\t\t\tcolumnsToScan = q.selectFields\n")
	fmt.Fprintf(file, "\t\t}\n\n")
	fmt.Fprintf(file, "\t\t// Build column-to-field map filtering only fields that correspond to actual columns\n")
	fmt.Fprintf(file, "\t\tcolumnToField := buildColumnToFieldMapForScan(q.modelType, columnsToScan)\n\n")
	fmt.Fprintf(file, "\t\tfields := make([]interface{}, len(columnsToScan))\n")
	fmt.Fprintf(file, "\t\tfor i, colName := range columnsToScan {\n")
	fmt.Fprintf(file, "\t\t\tif fieldIdx, ok := columnToField[colName]; ok {\n")
	fmt.Fprintf(file, "\t\t\t\tfield := modelValue.Field(fieldIdx)\n")
	fmt.Fprintf(file, "\t\t\t\tfields[i] = field.Addr().Interface()\n")
	fmt.Fprintf(file, "\t\t\t} else {\n")
	fmt.Fprintf(file, "\t\t\t\tvar dummy interface{}\n")
	fmt.Fprintf(file, "\t\t\t\tfields[i] = &dummy\n")
	fmt.Fprintf(file, "\t\t\t}\n")
	fmt.Fprintf(file, "\t\t}\n\n")
	fmt.Fprintf(file, "\t\tif err := driverRow.Scan(fields...); err != nil {\n")
	fmt.Fprintf(file, "\t\t\tif logger := q.getLogger(); logger != nil {\n")
	fmt.Fprintf(file, "\t\t\t\tlogger.Error(\"Scan failed: %%v (scanning %%d fields: %%v)\", err, len(columnsToScan), columnsToScan)\n")
	fmt.Fprintf(file, "\t\t\t}\n")
	fmt.Fprintf(file, "\t\t\treturn err\n")
	fmt.Fprintf(file, "\t\t}\n\n")
	fmt.Fprintf(file, "\t\tdestVal.Set(modelValue)\n")
	fmt.Fprintf(file, "\t\treturn nil\n")
	fmt.Fprintf(file, "\t}\n")
	fmt.Fprintf(file, "\treturn SanitizeError(fmt.Errorf(\"unsupported row type\"))\n")
	fmt.Fprintf(file, "}\n\n")

	fmt.Fprintf(file, "// scanRowsIntoModel scans rows into a slice of models\n")
	fmt.Fprintf(file, "func (q *Query) scanRowsIntoModel(rows interface{}, dest interface{}) error {\n")
	fmt.Fprintf(file, "\tif driverRows, ok := rows.(Rows); ok {\n")
	fmt.Fprintf(file, "\t\tdefer driverRows.Close()\n\n")
	fmt.Fprintf(file, "\t\tdestVal := reflect.ValueOf(dest)\n")
	fmt.Fprintf(file, "\t\tif destVal.Kind() != reflect.Ptr {\n")
	fmt.Fprintf(file, "\t\t\treturn SanitizeError(fmt.Errorf(\"dest must be a pointer to slice\"))\n")
	fmt.Fprintf(file, "\t\t}\n\n")
	fmt.Fprintf(file, "\t\tsliceVal := destVal.Elem()\n")
	fmt.Fprintf(file, "\t\tif sliceVal.Kind() != reflect.Slice {\n")
	fmt.Fprintf(file, "\t\t\treturn SanitizeError(fmt.Errorf(\"dest must be a pointer to slice\"))\n")
	fmt.Fprintf(file, "\t\t}\n\n")
	fmt.Fprintf(file, "\t\tif q.modelType == nil {\n")
	fmt.Fprintf(file, "\t\t\treturn SanitizeError(fmt.Errorf(\"modelType not defined\"))\n")
	fmt.Fprintf(file, "\t\t}\n\n")
	fmt.Fprintf(file, "\t\tsliceType := sliceVal.Type().Elem()\n")
	fmt.Fprintf(file, "\t\tif sliceType.Kind() == reflect.Ptr {\n")
	fmt.Fprintf(file, "\t\t\tsliceType = sliceType.Elem()\n")
	fmt.Fprintf(file, "\t\t}\n\n")
	fmt.Fprintf(file, "\t\trowCount := 0\n\n")
	fmt.Fprintf(file, "\t\tfor driverRows.Next() {\n")
	fmt.Fprintf(file, "\t\t\tif rowCount >= MaxScanRows {\n")
	fmt.Fprintf(file, "\t\t\t\treturn fmt.Errorf(\"result set too large: maximum %%d rows allowed\", MaxScanRows)\n")
	fmt.Fprintf(file, "\t\t\t}\n\n")
	fmt.Fprintf(file, "\t\t\tmodelValue := reflect.New(sliceType).Elem()\n\n")
	fmt.Fprintf(file, "\t\t\tcolumnsToScan := q.columns\n")
	fmt.Fprintf(file, "\t\t\tif len(q.selectFields) > 0 {\n")
	fmt.Fprintf(file, "\t\t\t\tcolumnsToScan = q.selectFields\n")
	fmt.Fprintf(file, "\t\t\t}\n\n")
	fmt.Fprintf(file, "\t\t\t// Build column-to-field map filtering only fields that correspond to actual columns\n")
	fmt.Fprintf(file, "\t\t\tcolumnToField := buildColumnToFieldMapForScan(sliceType, columnsToScan)\n\n")
	fmt.Fprintf(file, "\t\t\tfields := make([]interface{}, len(columnsToScan))\n")
	fmt.Fprintf(file, "\t\t\tfor i, colName := range columnsToScan {\n")
	fmt.Fprintf(file, "\t\t\t\tif fieldIdx, ok := columnToField[colName]; ok {\n")
	fmt.Fprintf(file, "\t\t\t\t\tfield := modelValue.Field(fieldIdx)\n")
	fmt.Fprintf(file, "\t\t\t\t\tfields[i] = field.Addr().Interface()\n")
	fmt.Fprintf(file, "\t\t\t\t} else {\n")
	fmt.Fprintf(file, "\t\t\t\t\tvar dummy interface{}\n")
	fmt.Fprintf(file, "\t\t\t\t\tfields[i] = &dummy\n")
	fmt.Fprintf(file, "\t\t\t\t}\n")
	fmt.Fprintf(file, "\t\t\t}\n\n")
	fmt.Fprintf(file, "\t\t\tif err := driverRows.Scan(fields...); err != nil {\n")
	fmt.Fprintf(file, "\t\t\t\tif logger := q.getLogger(); logger != nil {\n")
	fmt.Fprintf(file, "\t\t\t\t\tlogger.Error(\"Scan failed: %%v (scanning %%d fields: %%v)\", err, len(columnsToScan), columnsToScan)\n")
	fmt.Fprintf(file, "\t\t\t\t}\n")
	fmt.Fprintf(file, "\t\t\t\treturn err\n")
	fmt.Fprintf(file, "\t\t\t}\n\n")
	fmt.Fprintf(file, "\t\t\trowCount++\n")
	fmt.Fprintf(file, "\t\t\tif destVal.Elem().Type().Elem().Kind() == reflect.Ptr {\n")
	fmt.Fprintf(file, "\t\t\t\tsliceVal.Set(reflect.Append(sliceVal, modelValue.Addr()))\n")
	fmt.Fprintf(file, "\t\t\t} else {\n")
	fmt.Fprintf(file, "\t\t\t\tsliceVal.Set(reflect.Append(sliceVal, modelValue))\n")
	fmt.Fprintf(file, "\t\t\t}\n")
	fmt.Fprintf(file, "\t\t}\n\n")
	fmt.Fprintf(file, "\t\treturn driverRows.Err()\n")
	fmt.Fprintf(file, "\t}\n")
	fmt.Fprintf(file, "\treturn SanitizeError(fmt.Errorf(\"unsupported rows type\"))\n")
	fmt.Fprintf(file, "}\n\n")

	fmt.Fprintf(file, "// scanRowsDirect performs direct scan\n")
	fmt.Fprintf(file, "func (q *Query) scanRowsDirect(rows interface{}, dest interface{}) error {\n")
	fmt.Fprintf(file, "\treturn q.scanRowsIntoModel(rows, dest)\n")
	fmt.Fprintf(file, "}\n\n")

	fmt.Fprintf(file, "// buildColumnToFieldMapForScan creates a map of column names to field indices\n")
	fmt.Fprintf(file, "// Only includes fields that correspond to actual columns being scanned\n")
	fmt.Fprintf(file, "// Iterates through columns first to ensure all columns are mapped\n")
	fmt.Fprintf(file, "func buildColumnToFieldMapForScan(modelType reflect.Type, columns []string) map[string]int {\n")
	fmt.Fprintf(file, "\tcolumnToField := make(map[string]int)\n")
	fmt.Fprintf(file, "\t\n")
	fmt.Fprintf(file, "\t// Build a reverse map: field identifier -> field index\n")
	fmt.Fprintf(file, "\t// This allows us to quickly find fields by their various identifiers\n")
	fmt.Fprintf(file, "\tfieldMap := make(map[string]int)\n")
	fmt.Fprintf(file, "\t\n")
	fmt.Fprintf(file, "\t// First, build a map of all possible field identifiers to field indices\n")
	fmt.Fprintf(file, "\tfor i := 0; i < modelType.NumField(); i++ {\n")
	fmt.Fprintf(file, "\t\tfield := modelType.Field(i)\n")
	fmt.Fprintf(file, "\t\tjsonTag := field.Tag.Get(\"json\")\n")
	fmt.Fprintf(file, "\t\tdbTag := field.Tag.Get(\"db\")\n\n")
	fmt.Fprintf(file, "\t\t// Remove options from json tag (e.g., \"id,omitempty\" -> \"id\")\n")
	fmt.Fprintf(file, "\t\tif jsonTag != \"\" {\n")
	fmt.Fprintf(file, "\t\t\tif idx := strings.Index(jsonTag, \",\"); idx != -1 {\n")
	fmt.Fprintf(file, "\t\t\t\tjsonTag = jsonTag[:idx]\n")
	fmt.Fprintf(file, "\t\t\t}\n")
	fmt.Fprintf(file, "\t\t}\n\n")
	fmt.Fprintf(file, "\t\t// Map all possible identifiers to this field index\n")
	fmt.Fprintf(file, "\t\t// Priority: dbTag > jsonTag > snake_case field name\n")
	fmt.Fprintf(file, "\t\tif dbTag != \"\" {\n")
	fmt.Fprintf(file, "\t\t\tfieldMap[dbTag] = i\n")
	fmt.Fprintf(file, "\t\t}\n")
	fmt.Fprintf(file, "\t\tif jsonTag != \"\" {\n")
	fmt.Fprintf(file, "\t\t\tfieldMap[jsonTag] = i\n")
	fmt.Fprintf(file, "\t\t}\n")
	fmt.Fprintf(file, "\t\t// Also map snake_case field name\n")
	fmt.Fprintf(file, "\t\tfieldName := toSnakeCase(field.Name)\n")
	fmt.Fprintf(file, "\t\tif fieldName != \"\" {\n")
	fmt.Fprintf(file, "\t\t\tfieldMap[fieldName] = i\n")
	fmt.Fprintf(file, "\t\t}\n")
	fmt.Fprintf(file, "\t}\n\n")
	fmt.Fprintf(file, "\t// Now iterate through columns and find matching fields\n")
	fmt.Fprintf(file, "\t// This ensures all columns are checked and mapped\n")
	fmt.Fprintf(file, "\tfor _, col := range columns {\n")
	fmt.Fprintf(file, "\t\tif idx, ok := fieldMap[col]; ok {\n")
	fmt.Fprintf(file, "\t\t\tcolumnToField[col] = idx\n")
	fmt.Fprintf(file, "\t\t}\n")
	fmt.Fprintf(file, "\t\t// If column not found in fieldMap, it will not be in columnToField\n")
	fmt.Fprintf(file, "\t\t// and scanRowIntoModel will use a dummy variable for it\n")
	fmt.Fprintf(file, "\t}\n\n")
	fmt.Fprintf(file, "\treturn columnToField\n")
	fmt.Fprintf(file, "}\n\n")
	fmt.Fprintf(file, "// findFieldByColumn finds a struct field by column name\n")
	fmt.Fprintf(file, "func findFieldByColumn(modelValue reflect.Value, colName string) reflect.Value {\n")
	fmt.Fprintf(file, "\ttyp := modelValue.Type()\n")
	fmt.Fprintf(file, "\tfor i := 0; i < typ.NumField(); i++ {\n")
	fmt.Fprintf(file, "\t\tfield := typ.Field(i)\n")
	fmt.Fprintf(file, "\t\tjsonTag := field.Tag.Get(\"json\")\n")
	fmt.Fprintf(file, "\t\tdbTag := field.Tag.Get(\"db\")\n\n")
	fmt.Fprintf(file, "\t\t// Remove options from json tag (e.g., \"id,omitempty\" -> \"id\")\n")
	fmt.Fprintf(file, "\t\tif jsonTag != \"\" {\n")
	fmt.Fprintf(file, "\t\t\tif idx := strings.Index(jsonTag, \",\"); idx != -1 {\n")
	fmt.Fprintf(file, "\t\t\t\tjsonTag = jsonTag[:idx]\n")
	fmt.Fprintf(file, "\t\t\t}\n")
	fmt.Fprintf(file, "\t\t}\n\n")
	fmt.Fprintf(file, "\t\tif dbTag == colName || jsonTag == colName {\n")
	fmt.Fprintf(file, "\t\t\treturn modelValue.Field(i)\n")
	fmt.Fprintf(file, "\t\t}\n\n")
	fmt.Fprintf(file, "\t\tfieldName := toSnakeCase(field.Name)\n")
	fmt.Fprintf(file, "\t\tif fieldName == colName {\n")
	fmt.Fprintf(file, "\t\t\treturn modelValue.Field(i)\n")
	fmt.Fprintf(file, "\t\t}\n")
	fmt.Fprintf(file, "\t}\n")
	fmt.Fprintf(file, "\treturn reflect.Value{}\n")
	fmt.Fprintf(file, "}\n\n")

	fmt.Fprintf(file, "// ScanFirst scans a single row into a custom type using tags JSON/DB\n")
	fmt.Fprintf(file, "func (q *Query) ScanFirst(ctx context.Context, dest interface{}, scanType reflect.Type) error {\n")
	fmt.Fprintf(file, "\tctx, cancel := WithQueryTimeout(ctx)\n")
	fmt.Fprintf(file, "\tdefer cancel()\n\n")
	fmt.Fprintf(file, "\tprocessStart := time.Now()\n")
	fmt.Fprintf(file, "\tquery, args := q.buildSelectQuery(true)\n\n")
	fmt.Fprintf(file, "\tqueryStart := time.Now()\n")
	fmt.Fprintf(file, "\trow := q.db.QueryRow(ctx, query, args...)\n\n")
	fmt.Fprintf(file, "\tdestVal := reflect.ValueOf(dest)\n")
	fmt.Fprintf(file, "\tif destVal.Kind() != reflect.Ptr {\n")
	fmt.Fprintf(file, "\t\treturn SanitizeError(fmt.Errorf(\"dest must be a pointer\"))\n")
	fmt.Fprintf(file, "\t}\n")
	fmt.Fprintf(file, "\tdestVal = destVal.Elem()\n\n")
	fmt.Fprintf(file, "\t// Use selectFields if available (when Select() was called), otherwise use all columns\n")
	fmt.Fprintf(file, "\tcolumnsToScan := q.columns\n")
	fmt.Fprintf(file, "\tif len(q.selectFields) > 0 {\n")
	fmt.Fprintf(file, "\t\tcolumnsToScan = q.selectFields\n")
	fmt.Fprintf(file, "\t}\n\n")
	fmt.Fprintf(file, "\t// Create instance of scanType\n")
	fmt.Fprintf(file, "\tcustomValue := reflect.New(scanType).Elem()\n\n")
	fmt.Fprintf(file, "\t// Track which fields are json.RawMessage for post-processing\n")
	fmt.Fprintf(file, "\tjsonRawMessageFields := make(map[int]bool)\n")
	fmt.Fprintf(file, "\tfields := make([]interface{}, len(columnsToScan))\n")
	fmt.Fprintf(file, "\tfor i, colName := range columnsToScan {\n")
	fmt.Fprintf(file, "\t\tfield := findFieldByColumn(customValue, colName)\n")
	fmt.Fprintf(file, "\t\tif field.IsValid() {\n")
	fmt.Fprintf(file, "\t\t\t// Handle json.RawMessage specially - scan to string first, then convert\n")
	fmt.Fprintf(file, "\t\t\tif field.Type() == reflect.TypeOf(json.RawMessage{}) {\n")
	fmt.Fprintf(file, "\t\t\t\tvar rawMsgStr string\n")
	fmt.Fprintf(file, "\t\t\t\tfields[i] = &rawMsgStr\n")
	fmt.Fprintf(file, "\t\t\t\tjsonRawMessageFields[i] = true\n")
	fmt.Fprintf(file, "\t\t\t} else {\n")
	fmt.Fprintf(file, "\t\t\t\tfields[i] = field.Addr().Interface()\n")
	fmt.Fprintf(file, "\t\t\t}\n")
	fmt.Fprintf(file, "\t\t} else {\n")
	fmt.Fprintf(file, "\t\t\tvar dummy interface{}\n")
	fmt.Fprintf(file, "\t\t\tfields[i] = &dummy\n")
	fmt.Fprintf(file, "\t\t}\n")
	fmt.Fprintf(file, "\t}\n\n")
	fmt.Fprintf(file, "\tqueryEnd := time.Now()\n")
	fmt.Fprintf(file, "\tqueryDuration := queryEnd.Sub(queryStart)\n\n")
	fmt.Fprintf(file, "\tif err := row.Scan(fields...); err != nil {\n")
	fmt.Fprintf(file, "\t\tq.logQueryWithTiming(ctx, query, args, queryStart, processStart, queryDuration)\n")
	fmt.Fprintf(file, "\t\tif logger := q.getLogger(); logger != nil {\n")
	fmt.Fprintf(file, "\t\t\tlogger.Error(\"Scan failed: %%v (scanning %%d fields: %%v)\", err, len(columnsToScan), columnsToScan)\n")
	fmt.Fprintf(file, "\t\t}\n")
	fmt.Fprintf(file, "\t\treturn err\n")
	fmt.Fprintf(file, "\t}\n\n")
	fmt.Fprintf(file, "\t// Copy scanned values back to customValue, handling json.RawMessage conversion\n")
	fmt.Fprintf(file, "\tfor i, colName := range columnsToScan {\n")
	fmt.Fprintf(file, "\t\tfield := findFieldByColumn(customValue, colName)\n")
	fmt.Fprintf(file, "\t\tif field.IsValid() {\n")
	fmt.Fprintf(file, "\t\t\tif jsonRawMessageFields[i] {\n")
	fmt.Fprintf(file, "\t\t\t\t// Convert string to json.RawMessage\n")
	fmt.Fprintf(file, "\t\t\t\tif strPtr, ok := fields[i].(*string); ok && strPtr != nil {\n")
	fmt.Fprintf(file, "\t\t\t\t\tfield.Set(reflect.ValueOf(json.RawMessage(*strPtr)))\n")
	fmt.Fprintf(file, "\t\t\t\t}\n")
	fmt.Fprintf(file, "\t\t\t}\n")
	fmt.Fprintf(file, "\t\t\t// For other types, the scan already populated the field directly\n")
	fmt.Fprintf(file, "\t\t}\n")
	fmt.Fprintf(file, "\t}\n\n")
	fmt.Fprintf(file, "\tdestVal.Set(customValue)\n")
	fmt.Fprintf(file, "\tq.logQueryWithTiming(ctx, query, args, queryStart, processStart, queryDuration)\n")
	fmt.Fprintf(file, "\treturn nil\n")
	fmt.Fprintf(file, "}\n\n")

	fmt.Fprintf(file, "// ScanFind scans multiple rows into a slice of custom types using tags JSON/DB\n")
	fmt.Fprintf(file, "func (q *Query) ScanFind(ctx context.Context, dest interface{}, scanType reflect.Type) error {\n")
	fmt.Fprintf(file, "\tctx, cancel := WithQueryTimeout(ctx)\n")
	fmt.Fprintf(file, "\tdefer cancel()\n\n")
	fmt.Fprintf(file, "\tprocessStart := time.Now()\n")
	fmt.Fprintf(file, "\tquery, args := q.buildSelectQuery(false)\n\n")
	fmt.Fprintf(file, "\tqueryStart := time.Now()\n")
	fmt.Fprintf(file, "\trows, err := q.db.Query(ctx, query, args...)\n")
	fmt.Fprintf(file, "\tqueryEnd := time.Now()\n")
	fmt.Fprintf(file, "\tqueryDuration := queryEnd.Sub(queryStart)\n\n")
	fmt.Fprintf(file, "\tif err != nil {\n")
	fmt.Fprintf(file, "\t\tq.logQueryWithTiming(ctx, query, args, queryStart, processStart, queryDuration)\n")
	fmt.Fprintf(file, "\t\tif logger := q.getLogger(); logger != nil {\n")
	fmt.Fprintf(file, "\t\t\tlogger.Error(\"SELECT query failed: %%v\", err)\n")
	fmt.Fprintf(file, "\t\t}\n")
	fmt.Fprintf(file, "\t\treturn err\n")
	fmt.Fprintf(file, "\t}\n")
	fmt.Fprintf(file, "\tdefer rows.Close()\n\n")
	fmt.Fprintf(file, "\tdestVal := reflect.ValueOf(dest)\n")
	fmt.Fprintf(file, "\tif destVal.Kind() != reflect.Ptr {\n")
	fmt.Fprintf(file, "\t\treturn SanitizeError(fmt.Errorf(\"dest must be a pointer to slice\"))\n")
	fmt.Fprintf(file, "\t}\n\n")
	fmt.Fprintf(file, "\tsliceVal := destVal.Elem()\n")
	fmt.Fprintf(file, "\tif sliceVal.Kind() != reflect.Slice {\n")
	fmt.Fprintf(file, "\t\treturn SanitizeError(fmt.Errorf(\"dest must be a pointer to slice\"))\n")
	fmt.Fprintf(file, "\t}\n\n")
	fmt.Fprintf(file, "\t// Use selectFields if available (when Select() was called), otherwise use all columns\n")
	fmt.Fprintf(file, "\tcolumnsToScan := q.columns\n")
	fmt.Fprintf(file, "\tif len(q.selectFields) > 0 {\n")
	fmt.Fprintf(file, "\t\tcolumnsToScan = q.selectFields\n")
	fmt.Fprintf(file, "\t}\n\n")
	fmt.Fprintf(file, "\trowCount := 0\n")
	fmt.Fprintf(file, "\tfor rows.Next() {\n")
	fmt.Fprintf(file, "\t\tif rowCount >= MaxScanRows {\n")
	fmt.Fprintf(file, "\t\t\treturn fmt.Errorf(\"result set too large: maximum %%d rows allowed\", MaxScanRows)\n")
	fmt.Fprintf(file, "\t\t}\n\n")
	fmt.Fprintf(file, "\t\tcustomValue := reflect.New(scanType).Elem()\n\n")
	fmt.Fprintf(file, "\t\t// Track which fields are json.RawMessage for post-processing\n")
	fmt.Fprintf(file, "\t\tjsonRawMessageFields := make(map[int]bool)\n")
	fmt.Fprintf(file, "\t\tfields := make([]interface{}, len(columnsToScan))\n")
	fmt.Fprintf(file, "\t\tfor i, colName := range columnsToScan {\n")
	fmt.Fprintf(file, "\t\t\tfield := findFieldByColumn(customValue, colName)\n")
	fmt.Fprintf(file, "\t\t\tif field.IsValid() {\n")
	fmt.Fprintf(file, "\t\t\t\t// Handle json.RawMessage specially - scan to string first, then convert\n")
	fmt.Fprintf(file, "\t\t\t\tif field.Type() == reflect.TypeOf(json.RawMessage{}) {\n")
	fmt.Fprintf(file, "\t\t\t\t\tvar rawMsgStr string\n")
	fmt.Fprintf(file, "\t\t\t\t\tfields[i] = &rawMsgStr\n")
	fmt.Fprintf(file, "\t\t\t\t\tjsonRawMessageFields[i] = true\n")
	fmt.Fprintf(file, "\t\t\t\t} else {\n")
	fmt.Fprintf(file, "\t\t\t\t\tfields[i] = field.Addr().Interface()\n")
	fmt.Fprintf(file, "\t\t\t\t}\n")
	fmt.Fprintf(file, "\t\t\t} else {\n")
	fmt.Fprintf(file, "\t\t\t\tvar dummy interface{}\n")
	fmt.Fprintf(file, "\t\t\t\tfields[i] = &dummy\n")
	fmt.Fprintf(file, "\t\t\t}\n")
	fmt.Fprintf(file, "\t\t}\n\n")
	fmt.Fprintf(file, "\t\tif err := rows.Scan(fields...); err != nil {\n")
	fmt.Fprintf(file, "\t\t\tif logger := q.getLogger(); logger != nil {\n")
	fmt.Fprintf(file, "\t\t\t\tlogger.Error(\"Scan failed: %%v (scanning %%d fields: %%v)\", err, len(columnsToScan), columnsToScan)\n")
	fmt.Fprintf(file, "\t\t\t}\n")
	fmt.Fprintf(file, "\t\t\treturn err\n")
	fmt.Fprintf(file, "\t\t}\n\n")
	fmt.Fprintf(file, "\t\t// Copy scanned values back to customValue, handling json.RawMessage conversion\n")
	fmt.Fprintf(file, "\t\tfor i, colName := range columnsToScan {\n")
	fmt.Fprintf(file, "\t\t\tfield := findFieldByColumn(customValue, colName)\n")
	fmt.Fprintf(file, "\t\t\tif field.IsValid() {\n")
	fmt.Fprintf(file, "\t\t\t\tif jsonRawMessageFields[i] {\n")
	fmt.Fprintf(file, "\t\t\t\t\t// Convert string to json.RawMessage\n")
	fmt.Fprintf(file, "\t\t\t\t\tif strPtr, ok := fields[i].(*string); ok && strPtr != nil {\n")
	fmt.Fprintf(file, "\t\t\t\t\t\tfield.Set(reflect.ValueOf(json.RawMessage(*strPtr)))\n")
	fmt.Fprintf(file, "\t\t\t\t\t}\n")
	fmt.Fprintf(file, "\t\t\t\t}\n")
	fmt.Fprintf(file, "\t\t\t\t// For other types, the scan already populated the field directly\n")
	fmt.Fprintf(file, "\t\t\t}\n")
	fmt.Fprintf(file, "\t\t}\n\n")
	fmt.Fprintf(file, "\t\trowCount++\n")
	fmt.Fprintf(file, "\t\tsliceVal.Set(reflect.Append(sliceVal, customValue))\n")
	fmt.Fprintf(file, "\t}\n\n")
	fmt.Fprintf(file, "\tq.logQueryWithTiming(ctx, query, args, queryStart, processStart, queryDuration)\n\n")
	fmt.Fprintf(file, "\tif err := rows.Err(); err != nil {\n")
	fmt.Fprintf(file, "\t\tif logger := q.getLogger(); logger != nil {\n")
	fmt.Fprintf(file, "\t\t\tlogger.Error(\"SELECT query failed during scan: %%v\", err)\n")
	fmt.Fprintf(file, "\t\t}\n")
	fmt.Fprintf(file, "\t\treturn err\n")
	fmt.Fprintf(file, "\t}\n\n")
	fmt.Fprintf(file, "\treturn nil\n")
	fmt.Fprintf(file, "}\n\n")
}

// generateFulltextHelpers generates fulltext search helpers
func generateFulltextHelpers(file *os.File) {
	fmt.Fprintf(file, "// NormalizeTSQuery normalizes a query for PostgreSQL to_tsquery\n")
	fmt.Fprintf(file, "func NormalizeTSQuery(query string) string {\n")
	fmt.Fprintf(file, "\tquery = strings.TrimSpace(query)\n")
	fmt.Fprintf(file, "\tif query == \"\" {\n")
	fmt.Fprintf(file, "\t\treturn \"\"\n")
	fmt.Fprintf(file, "\t}\n\n")
	fmt.Fprintf(file, "\twords := strings.Fields(query)\n\n")
	fmt.Fprintf(file, "\twordsWithPrefix := make([]string, len(words))\n")
	fmt.Fprintf(file, "\tfor i, word := range words {\n")
	fmt.Fprintf(file, "\t\twordsWithPrefix[i] = word + \":*\"\n")
	fmt.Fprintf(file, "\t}\n\n")
	fmt.Fprintf(file, "\treturn strings.Join(wordsWithPrefix, \" & \")\n")
	fmt.Fprintf(file, "}\n\n")
}

// generateLoggingHelpers generates logging helper methods
func generateLoggingHelpers(file *os.File) {
	fmt.Fprintf(file, "// detectQueryType detects the type of SQL query (SELECT, INSERT, UPDATE, DELETE)\n")
	fmt.Fprintf(file, "func detectQueryType(query string) string {\n")
	fmt.Fprintf(file, "\ttrimmed := strings.TrimSpace(query)\n")
	fmt.Fprintf(file, "\tupper := strings.ToUpper(trimmed)\n\n")
	fmt.Fprintf(file, "\tif strings.HasPrefix(upper, \"SELECT\") {\n")
	fmt.Fprintf(file, "\t\treturn \"SELECT\"\n")
	fmt.Fprintf(file, "\t}\n")
	fmt.Fprintf(file, "\tif strings.HasPrefix(upper, \"INSERT\") {\n")
	fmt.Fprintf(file, "\t\treturn \"INSERT\"\n")
	fmt.Fprintf(file, "\t}\n")
	fmt.Fprintf(file, "\tif strings.HasPrefix(upper, \"UPDATE\") {\n")
	fmt.Fprintf(file, "\t\treturn \"UPDATE\"\n")
	fmt.Fprintf(file, "\t}\n")
	fmt.Fprintf(file, "\tif strings.HasPrefix(upper, \"DELETE\") {\n")
	fmt.Fprintf(file, "\t\treturn \"DELETE\"\n")
	fmt.Fprintf(file, "\t}\n\n")
	fmt.Fprintf(file, "\treturn \"UNKNOWN\"\n")
	fmt.Fprintf(file, "}\n\n")

	fmt.Fprintf(file, "// logQueryWithTiming logs query time and process time separately\n")
	fmt.Fprintf(file, "func (q *Query) logQueryWithTiming(ctx context.Context, query string, args []interface{}, queryStart, processStart time.Time, queryDuration time.Duration) {\n")
	fmt.Fprintf(file, "\tlogger := q.getLogger()\n")
	fmt.Fprintf(file, "\tif logger == nil {\n")
	fmt.Fprintf(file, "\t\treturn\n")
	fmt.Fprintf(file, "\t}\n\n")
	fmt.Fprintf(file, "\tprocessDuration := time.Since(processStart)\n")
	fmt.Fprintf(file, "\toverheadDuration := processDuration - queryDuration\n\n")
	fmt.Fprintf(file, "\t// Log QUERY (already existing) - uses query time (real time in database)\n")
	fmt.Fprintf(file, "\tlogger.Query(query, args, queryDuration)\n\n")
	fmt.Fprintf(file, "\t// Log INFO with query time, overhead and total time\n")
	fmt.Fprintf(file, "\tqueryType := detectQueryType(query)\n")
	fmt.Fprintf(file, "\tlogger.Info(\"%%s query: %%v, overhead: %%v (total: %%v)\", queryType, queryDuration, overheadDuration, processDuration)\n\n")
	fmt.Fprintf(file, "\t// Log WARN if query is slow (> 1000ms)\n")
	fmt.Fprintf(file, "\tif queryDuration > 1000*time.Millisecond {\n")
	fmt.Fprintf(file, "\t\tlogger.Warn(\"Slow query detected: %%s took %%v\", queryType, queryDuration)\n")
	fmt.Fprintf(file, "\t}\n\n")
	fmt.Fprintf(file, "\t// Log WARN if ORM overhead is too high (> 2x query time)\n")
	fmt.Fprintf(file, "\tif overheadDuration > 0 && queryDuration > 0 && overheadDuration > queryDuration*2 {\n")
	fmt.Fprintf(file, "\t\tlogger.Warn(\"ORM overhead high: %%v (query: %%v, overhead: %%v, %%.1f%% overhead)\",\n")
	fmt.Fprintf(file, "\t\t\tprocessDuration, queryDuration, overheadDuration,\n")
	fmt.Fprintf(file, "\t\t\tfloat64(overheadDuration)/float64(queryDuration)*100)\n")
	fmt.Fprintf(file, "\t}\n")
	fmt.Fprintf(file, "}\n\n")
}
