package generator

import (
	"fmt"
	"os"
	"path/filepath"

	"github.com/carlosnayan/prisma-go-client/internal/parser"
)

// GenerateQueries generates type-safe query builders for each model
func GenerateQueries(schema *parser.Schema, outputDir string) error {
	queriesDir := filepath.Join(outputDir, "queries")
	if err := os.MkdirAll(queriesDir, 0755); err != nil {
		return fmt.Errorf("erro ao criar diretÃ³rio queries: %w", err)
	}

	// Detect user module
	userModule, err := detectUserModule(outputDir)
	if err != nil {
		return fmt.Errorf("failed to detect user module: %w", err)
	}

	queryResultFile := filepath.Join(queriesDir, "query_result.go")
	if err := generateQueryResultFile(queryResultFile); err != nil {
		return fmt.Errorf("erro ao gerar query_result.go: %w", err)
	}

	for _, model := range schema.Models {
		queryFile := filepath.Join(queriesDir, toSnakeCase(model.Name)+"_query.go")
		if err := generateQueryFile(queryFile, model, userModule, outputDir); err != nil {
			return fmt.Errorf("erro ao gerar query para %s: %w", model.Name, err)
		}
	}

	return nil
}

// generateQueryResultFile generates the file with QueryResult type
func generateQueryResultFile(filePath string) error {
	file, err := os.Create(filePath)
	if err != nil {
		return err
	}
	defer file.Close()

	fmt.Fprintf(file, "// Code generated by prisma generate. DO NOT EDIT.\n")
	fmt.Fprintf(file, "package queries\n\n")

	fmt.Fprintf(file, "import (\n")
	fmt.Fprintf(file, "\t\"context\"\n")
	fmt.Fprintf(file, "\t\"github.com/carlosnayan/prisma-go-client/builder\"\n")
	fmt.Fprintf(file, ")\n\n")

	fmt.Fprintf(file, "// QueryResult represents a query that can be executed\n")
	fmt.Fprintf(file, "type QueryResult[T any] struct {\n")
	fmt.Fprintf(file, "\tquery *builder.Query\n")
	fmt.Fprintf(file, "}\n\n")

	fmt.Fprintf(file, "// Exec executes the query and returns results\n")
	fmt.Fprintf(file, "func (r *QueryResult[T]) Exec(ctx context.Context) ([]T, error) {\n")
	fmt.Fprintf(file, "\tvar results []T\n")
	fmt.Fprintf(file, "\terr := r.query.Find(ctx, &results)\n")
	fmt.Fprintf(file, "\treturn results, err\n")
	fmt.Fprintf(file, "}\n\n")

	return nil
}

// generateQueryFile gera o arquivo de query builder para um model
func generateQueryFile(filePath string, model *parser.Model, userModule, outputDir string) error {
	file, err := os.Create(filePath)
	if err != nil {
		return err
	}
	defer file.Close()

	// Header
	fmt.Fprintf(file, "// Code generated by prisma generate. DO NOT EDIT.\n")
	fmt.Fprintf(file, "package queries\n\n")

	// Determine required imports
	imports := determineQueryImports(userModule, outputDir)
	if len(imports) > 0 {
		fmt.Fprintf(file, "import (\n")
		// Separate stdlib and third-party imports
		stdlib := []string{}
		thirdParty := []string{}

		for _, imp := range imports {
			if isStdlibImport(imp) {
				stdlib = append(stdlib, imp)
			} else {
				thirdParty = append(thirdParty, imp)
			}
		}

		// Write stdlib imports
		for _, imp := range stdlib {
			fmt.Fprintf(file, "\t%q\n", imp)
		}

		// Add blank line if both exist
		if len(stdlib) > 0 && len(thirdParty) > 0 {
			fmt.Fprintf(file, "\n")
		}

		// Write third-party imports
		for _, imp := range thirdParty {
			fmt.Fprintf(file, "\t%q\n", imp)
		}

		fmt.Fprintf(file, ")\n\n")
	}

	// Query struct
	pascalModelName := toPascalCase(model.Name)
	fmt.Fprintf(file, "// %sQuery is the query builder for model %s with fluent API\n", pascalModelName, model.Name)
	fmt.Fprintf(file, "// All methods from builder.Query are available via embedding\n")
	fmt.Fprintf(file, "// Example: q.Where(\"email = ?\", \"user@example.com\").First(ctx, &user)\n")
	fmt.Fprintf(file, "type %sQuery struct {\n", pascalModelName)
	fmt.Fprintf(file, "\t*builder.Query\n")
	fmt.Fprintf(file, "}\n\n")

	// Query builder methods
	generateQueryMethods(file, model)

	return nil
}

// generateQueryMethods generates the query builder methods with fluent API
func generateQueryMethods(file *os.File, model *parser.Model) {
	pascalModelName := toPascalCase(model.Name)

	// First
	fmt.Fprintf(file, "// First finds the first record\n")
	fmt.Fprintf(file, "// Examples:\n")
	fmt.Fprintf(file, "//   q.Where(\"email = ?\", \"user@example.com\").First(ctx, &user)\n")
	fmt.Fprintf(file, "//   q.Where(builder.Where{\"id\": id}).First(ctx, &user)\n")
	fmt.Fprintf(file, "func (q *%sQuery) First(ctx context.Context, dest *models.%s) error {\n", pascalModelName, pascalModelName)
	fmt.Fprintf(file, "\treturn q.Query.First(ctx, dest)\n")
	fmt.Fprintf(file, "}\n\n")

	// FindFirst - alias for First
	fmt.Fprintf(file, "// FindFirst is an alias for First\n")
	fmt.Fprintf(file, "func (q *%sQuery) FindFirst(ctx context.Context, dest *models.%s) error {\n", pascalModelName, pascalModelName)
	fmt.Fprintf(file, "\treturn q.Query.FindFirst(ctx, dest)\n")
	fmt.Fprintf(file, "}\n\n")

	// Find
	fmt.Fprintf(file, "// Find finds all records\n")
	fmt.Fprintf(file, "// Examples:\n")
	fmt.Fprintf(file, "//   q.Where(\"active = ?\", true).Order(\"created_at DESC\").Limit(10).Find(ctx, &users)\n")
	fmt.Fprintf(file, "//   q.Where(builder.Where{\"active\": true}).Find(ctx, &users)\n")
	fmt.Fprintf(file, "func (q *%sQuery) Find(ctx context.Context, dest *[]models.%s) error {\n", pascalModelName, pascalModelName)
	fmt.Fprintf(file, "\treturn q.Query.Find(ctx, dest)\n")
	fmt.Fprintf(file, "}\n\n")

	// FindMany - type-safe with WhereInput, returns QueryResult for .Exec()
	fmt.Fprintf(file, "// FindMany returns a QueryResult that can be executed with .Exec(ctx)\n")
	fmt.Fprintf(file, "// Example: users, err := q.FindMany(inputs.UserWhereInput{Email: db.Contains(\"example.com\")}).Exec(ctx)\n")
	fmt.Fprintf(file, "func (q *%sQuery) FindMany(where inputs.%sWhereInput) *QueryResult[models.%s] {\n", pascalModelName, pascalModelName, pascalModelName)
	fmt.Fprintf(file, "\twhereMap := Convert%sWhereInputToWhere(where)\n", pascalModelName)
	fmt.Fprintf(file, "\tq.Where(whereMap)\n")
	fmt.Fprintf(file, "\treturn &QueryResult[models.%s]{\n", pascalModelName)
	fmt.Fprintf(file, "\t\tquery: q.Query,\n")
	fmt.Fprintf(file, "\t}\n")
	fmt.Fprintf(file, "}\n\n")

	generateWhereInputConverter(file, model)
	fmt.Fprintf(file, "// Count counts records\n")
	fmt.Fprintf(file, "// Example: q.Where(\"active = ?\", true).Count(ctx)\n")
	fmt.Fprintf(file, "func (q *%sQuery) Count(ctx context.Context) (int64, error) {\n", pascalModelName)
	fmt.Fprintf(file, "\treturn q.Query.Count(ctx)\n")
	fmt.Fprintf(file, "}\n\n")

	fmt.Fprintf(file, "// Create inserts a new record\n")
	fmt.Fprintf(file, "// Example: q.Create(ctx, &user)\n")
	fmt.Fprintf(file, "func (q *%sQuery) Create(ctx context.Context, value *models.%s) error {\n", pascalModelName, pascalModelName)
	fmt.Fprintf(file, "\treturn q.Query.Create(ctx, value)\n")
	fmt.Fprintf(file, "}\n\n")

	fmt.Fprintf(file, "// Save saves a record (create or update)\n")
	fmt.Fprintf(file, "// Example: q.Save(ctx, &user)\n")
	fmt.Fprintf(file, "func (q *%sQuery) Save(ctx context.Context, value *models.%s) error {\n", pascalModelName, pascalModelName)
	fmt.Fprintf(file, "\treturn q.Query.Save(ctx, value)\n")
	fmt.Fprintf(file, "}\n\n")

	fmt.Fprintf(file, "// Update updates a column\n")
	fmt.Fprintf(file, "// Example: q.Where(\"id = ?\", 1).Update(ctx, \"name\", \"New Name\")\n")
	fmt.Fprintf(file, "func (q *%sQuery) Update(ctx context.Context, column string, value interface{}) error {\n", pascalModelName)
	fmt.Fprintf(file, "\treturn q.Query.Update(ctx, column, value)\n")
	fmt.Fprintf(file, "}\n\n")

	fmt.Fprintf(file, "// Updates updates multiple columns\n")
	fmt.Fprintf(file, "// Example: q.Where(\"id = ?\", 1).Updates(ctx, map[string]interface{}{\"name\": \"New\", \"age\": 30})\n")
	fmt.Fprintf(file, "func (q *%sQuery) Updates(ctx context.Context, values map[string]interface{}) error {\n", pascalModelName)
	fmt.Fprintf(file, "\treturn q.Query.Updates(ctx, values)\n")
	fmt.Fprintf(file, "}\n\n")

	fmt.Fprintf(file, "// Delete removes records\n")
	fmt.Fprintf(file, "// Example: q.Where(\"id = ?\", 1).Delete(ctx, &models.%s{})\n", pascalModelName)
	fmt.Fprintf(file, "func (q *%sQuery) Delete(ctx context.Context, value *models.%s) error {\n", pascalModelName, pascalModelName)
	fmt.Fprintf(file, "\treturn q.Query.Delete(ctx, value)\n")
	fmt.Fprintf(file, "}\n\n")
}

// generateWhereInputConverter generates function to convert WhereInput to builder.Where
func generateWhereInputConverter(file *os.File, model *parser.Model) {
	pascalModelName := toPascalCase(model.Name)

	fmt.Fprintf(file, "// Convert%sWhereInputToWhere converts WhereInput to builder.Where\n", pascalModelName)
	fmt.Fprintf(file, "func Convert%sWhereInputToWhere(where inputs.%sWhereInput) builder.Where {\n", pascalModelName, pascalModelName)
	fmt.Fprintf(file, "\tresult := builder.Where{}\n\n")

	for _, field := range model.Fields {
		if isRelation(field) {
			continue
		}
		fieldName := toPascalCase(field.Name)
		dbFieldName := field.Name
		filterType := getFilterType(field.Type)

		fmt.Fprintf(file, "\tif where.%s != nil {\n", fieldName)
		fmt.Fprintf(file, "\t\tfilter := where.%s\n", fieldName)
		generateFilterConverter(file, filterType, dbFieldName)
		fmt.Fprintf(file, "\t}\n\n")
	}

	fmt.Fprintf(file, "\t// Handle OR conditions\n")
	fmt.Fprintf(file, "\tif len(where.Or) > 0 {\n")
	fmt.Fprintf(file, "\t\torConditions := []builder.Where{}\n")
	fmt.Fprintf(file, "\t\tfor _, orWhere := range where.Or {\n")
	fmt.Fprintf(file, "\t\t\torConditions = append(orConditions, Convert%sWhereInputToWhere(orWhere))\n", pascalModelName)
	fmt.Fprintf(file, "\t\t}\n")
	fmt.Fprintf(file, "\t\tfor _, orCond := range orConditions {\n")
	fmt.Fprintf(file, "\t\t\tfor k, v := range orCond {\n")
	fmt.Fprintf(file, "\t\t\t\tresult[k] = v\n")
	fmt.Fprintf(file, "\t\t\t}\n")
	fmt.Fprintf(file, "\t\t}\n")
	fmt.Fprintf(file, "\t}\n\n")

	fmt.Fprintf(file, "\t// Handle AND conditions\n")
	fmt.Fprintf(file, "\tif len(where.And) > 0 {\n")
	fmt.Fprintf(file, "\t\tfor _, andWhere := range where.And {\n")
	fmt.Fprintf(file, "\t\t\tandMap := Convert%sWhereInputToWhere(andWhere)\n", pascalModelName)
	fmt.Fprintf(file, "\t\t\tfor k, v := range andMap {\n")
	fmt.Fprintf(file, "\t\t\t\tresult[k] = v\n")
	fmt.Fprintf(file, "\t\t\t}\n")
	fmt.Fprintf(file, "\t\t}\n")
	fmt.Fprintf(file, "\t}\n\n")

	fmt.Fprintf(file, "\t// Handle NOT condition\n")
	fmt.Fprintf(file, "\tif where.Not != nil {\n")
	fmt.Fprintf(file, "\t\tnotMap := Convert%sWhereInputToWhere(*where.Not)\n", pascalModelName)
	fmt.Fprintf(file, "\t\t// For now, combine with AND\n")
	fmt.Fprintf(file, "\t\tfor k, v := range notMap {\n")
	fmt.Fprintf(file, "\t\t\tresult[k] = v\n")
	fmt.Fprintf(file, "\t\t}\n")
	fmt.Fprintf(file, "\t}\n\n")

	fmt.Fprintf(file, "\treturn result\n")
	fmt.Fprintf(file, "}\n\n")
}

// generateFilterConverter generates code to convert a Filter type to WhereOperator
func generateFilterConverter(file *os.File, filterType, fieldName string) {
	switch filterType {
	case "StringFilter":
		fmt.Fprintf(file, "\t\tif filter.Contains != nil {\n")
		fmt.Fprintf(file, "\t\t\tresult[%q] = builder.Contains(*filter.Contains)\n", fieldName)
		fmt.Fprintf(file, "\t\t}\n")
		fmt.Fprintf(file, "\t\tif filter.StartsWith != nil {\n")
		fmt.Fprintf(file, "\t\t\tresult[%q] = builder.StartsWith(*filter.StartsWith)\n", fieldName)
		fmt.Fprintf(file, "\t\t}\n")
		fmt.Fprintf(file, "\t\tif filter.EndsWith != nil {\n")
		fmt.Fprintf(file, "\t\t\tresult[%q] = builder.EndsWith(*filter.EndsWith)\n", fieldName)
		fmt.Fprintf(file, "\t\t}\n")
		fmt.Fprintf(file, "\t\tif filter.ContainsInsensitive != nil {\n")
		fmt.Fprintf(file, "\t\t\tresult[%q] = builder.ContainsInsensitive(*filter.ContainsInsensitive)\n", fieldName)
		fmt.Fprintf(file, "\t\t}\n")
		fmt.Fprintf(file, "\t\tif filter.Equals != nil {\n")
		fmt.Fprintf(file, "\t\t\tresult[%q] = *filter.Equals\n", fieldName)
		fmt.Fprintf(file, "\t\t}\n")
		fmt.Fprintf(file, "\t\tif filter.NotEquals != nil {\n")
		fmt.Fprintf(file, "\t\t\tresult[%q] = builder.NotEquals(*filter.NotEquals)\n", fieldName)
		fmt.Fprintf(file, "\t\t}\n")
		fmt.Fprintf(file, "\t\tif len(filter.In) > 0 {\n")
		fmt.Fprintf(file, "\t\t\tvalues := make([]interface{}, len(filter.In))\n")
		fmt.Fprintf(file, "\t\t\tfor i, v := range filter.In {\n")
		fmt.Fprintf(file, "\t\t\t\tvalues[i] = v\n")
		fmt.Fprintf(file, "\t\t\t}\n")
		fmt.Fprintf(file, "\t\t\tresult[%q] = builder.In(values...)\n", fieldName)
		fmt.Fprintf(file, "\t\t}\n")
		fmt.Fprintf(file, "\t\tif len(filter.NotIn) > 0 {\n")
		fmt.Fprintf(file, "\t\t\tvalues := make([]interface{}, len(filter.NotIn))\n")
		fmt.Fprintf(file, "\t\t\tfor i, v := range filter.NotIn {\n")
		fmt.Fprintf(file, "\t\t\t\tvalues[i] = v\n")
		fmt.Fprintf(file, "\t\t\t}\n")
		fmt.Fprintf(file, "\t\t\tresult[%q] = builder.NotIn(values...)\n", fieldName)
		fmt.Fprintf(file, "\t\t}\n")
		fmt.Fprintf(file, "\t\tif filter.IsNull != nil && *filter.IsNull {\n")
		fmt.Fprintf(file, "\t\t\tresult[%q] = builder.IsNull()\n", fieldName)
		fmt.Fprintf(file, "\t\t}\n")
		fmt.Fprintf(file, "\t\tif filter.IsNotNull != nil && *filter.IsNotNull {\n")
		fmt.Fprintf(file, "\t\t\tresult[%q] = builder.IsNotNull()\n", fieldName)
		fmt.Fprintf(file, "\t\t}\n")
	case "IntFilter":
		fmt.Fprintf(file, "\t\tif filter.Equals != nil {\n")
		fmt.Fprintf(file, "\t\t\tresult[%q] = *filter.Equals\n", fieldName)
		fmt.Fprintf(file, "\t\t}\n")
		fmt.Fprintf(file, "\t\tif filter.NotEquals != nil {\n")
		fmt.Fprintf(file, "\t\t\tresult[%q] = builder.NotEquals(*filter.NotEquals)\n", fieldName)
		fmt.Fprintf(file, "\t\t}\n")
		fmt.Fprintf(file, "\t\tif filter.Gt != nil {\n")
		fmt.Fprintf(file, "\t\t\tresult[%q] = builder.Gt(*filter.Gt)\n", fieldName)
		fmt.Fprintf(file, "\t\t}\n")
		fmt.Fprintf(file, "\t\tif filter.Gte != nil {\n")
		fmt.Fprintf(file, "\t\t\tresult[%q] = builder.Gte(*filter.Gte)\n", fieldName)
		fmt.Fprintf(file, "\t\t}\n")
		fmt.Fprintf(file, "\t\tif filter.Lt != nil {\n")
		fmt.Fprintf(file, "\t\t\tresult[%q] = builder.Lt(*filter.Lt)\n", fieldName)
		fmt.Fprintf(file, "\t\t}\n")
		fmt.Fprintf(file, "\t\tif filter.Lte != nil {\n")
		fmt.Fprintf(file, "\t\t\tresult[%q] = builder.Lte(*filter.Lte)\n", fieldName)
		fmt.Fprintf(file, "\t\t}\n")
		fmt.Fprintf(file, "\t\tif len(filter.In) > 0 {\n")
		fmt.Fprintf(file, "\t\t\tvalues := make([]interface{}, len(filter.In))\n")
		fmt.Fprintf(file, "\t\t\tfor i, v := range filter.In {\n")
		fmt.Fprintf(file, "\t\t\t\tvalues[i] = v\n")
		fmt.Fprintf(file, "\t\t\t}\n")
		fmt.Fprintf(file, "\t\t\tresult[%q] = builder.In(values...)\n", fieldName)
		fmt.Fprintf(file, "\t\t}\n")
		fmt.Fprintf(file, "\t\tif len(filter.NotIn) > 0 {\n")
		fmt.Fprintf(file, "\t\t\tvalues := make([]interface{}, len(filter.NotIn))\n")
		fmt.Fprintf(file, "\t\t\tfor i, v := range filter.NotIn {\n")
		fmt.Fprintf(file, "\t\t\t\tvalues[i] = v\n")
		fmt.Fprintf(file, "\t\t\t}\n")
		fmt.Fprintf(file, "\t\t\tresult[%q] = builder.NotIn(values...)\n", fieldName)
		fmt.Fprintf(file, "\t\t}\n")
		fmt.Fprintf(file, "\t\tif filter.IsNull != nil && *filter.IsNull {\n")
		fmt.Fprintf(file, "\t\t\tresult[%q] = builder.IsNull()\n", fieldName)
		fmt.Fprintf(file, "\t\t}\n")
		fmt.Fprintf(file, "\t\tif filter.IsNotNull != nil && *filter.IsNotNull {\n")
		fmt.Fprintf(file, "\t\t\tresult[%q] = builder.IsNotNull()\n", fieldName)
		fmt.Fprintf(file, "\t\t}\n")
	case "Int64Filter":
		fmt.Fprintf(file, "\t\tif filter.Equals != nil {\n")
		fmt.Fprintf(file, "\t\t\tresult[%q] = *filter.Equals\n", fieldName)
		fmt.Fprintf(file, "\t\t}\n")
		fmt.Fprintf(file, "\t\tif filter.NotEquals != nil {\n")
		fmt.Fprintf(file, "\t\t\tresult[%q] = builder.NotEquals(*filter.NotEquals)\n", fieldName)
		fmt.Fprintf(file, "\t\t}\n")
		fmt.Fprintf(file, "\t\tif filter.Gt != nil {\n")
		fmt.Fprintf(file, "\t\t\tresult[%q] = builder.Gt(*filter.Gt)\n", fieldName)
		fmt.Fprintf(file, "\t\t}\n")
		fmt.Fprintf(file, "\t\tif filter.Gte != nil {\n")
		fmt.Fprintf(file, "\t\t\tresult[%q] = builder.Gte(*filter.Gte)\n", fieldName)
		fmt.Fprintf(file, "\t\t}\n")
		fmt.Fprintf(file, "\t\tif filter.Lt != nil {\n")
		fmt.Fprintf(file, "\t\t\tresult[%q] = builder.Lt(*filter.Lt)\n", fieldName)
		fmt.Fprintf(file, "\t\t}\n")
		fmt.Fprintf(file, "\t\tif filter.Lte != nil {\n")
		fmt.Fprintf(file, "\t\t\tresult[%q] = builder.Lte(*filter.Lte)\n", fieldName)
		fmt.Fprintf(file, "\t\t}\n")
		fmt.Fprintf(file, "\t\tif len(filter.In) > 0 {\n")
		fmt.Fprintf(file, "\t\t\tvalues := make([]interface{}, len(filter.In))\n")
		fmt.Fprintf(file, "\t\t\tfor i, v := range filter.In {\n")
		fmt.Fprintf(file, "\t\t\t\tvalues[i] = v\n")
		fmt.Fprintf(file, "\t\t\t}\n")
		fmt.Fprintf(file, "\t\t\tresult[%q] = builder.In(values...)\n", fieldName)
		fmt.Fprintf(file, "\t\t}\n")
		fmt.Fprintf(file, "\t\tif len(filter.NotIn) > 0 {\n")
		fmt.Fprintf(file, "\t\t\tvalues := make([]interface{}, len(filter.NotIn))\n")
		fmt.Fprintf(file, "\t\t\tfor i, v := range filter.NotIn {\n")
		fmt.Fprintf(file, "\t\t\t\tvalues[i] = v\n")
		fmt.Fprintf(file, "\t\t\t}\n")
		fmt.Fprintf(file, "\t\t\tresult[%q] = builder.NotIn(values...)\n", fieldName)
		fmt.Fprintf(file, "\t\t}\n")
		fmt.Fprintf(file, "\t\tif filter.IsNull != nil && *filter.IsNull {\n")
		fmt.Fprintf(file, "\t\t\tresult[%q] = builder.IsNull()\n", fieldName)
		fmt.Fprintf(file, "\t\t}\n")
		fmt.Fprintf(file, "\t\tif filter.IsNotNull != nil && *filter.IsNotNull {\n")
		fmt.Fprintf(file, "\t\t\tresult[%q] = builder.IsNotNull()\n", fieldName)
		fmt.Fprintf(file, "\t\t}\n")
	case "FloatFilter":
		fmt.Fprintf(file, "\t\tif filter.Equals != nil {\n")
		fmt.Fprintf(file, "\t\t\tresult[%q] = *filter.Equals\n", fieldName)
		fmt.Fprintf(file, "\t\t}\n")
		fmt.Fprintf(file, "\t\tif filter.NotEquals != nil {\n")
		fmt.Fprintf(file, "\t\t\tresult[%q] = builder.NotEquals(*filter.NotEquals)\n", fieldName)
		fmt.Fprintf(file, "\t\t}\n")
		fmt.Fprintf(file, "\t\tif filter.Gt != nil {\n")
		fmt.Fprintf(file, "\t\t\tresult[%q] = builder.Gt(*filter.Gt)\n", fieldName)
		fmt.Fprintf(file, "\t\t}\n")
		fmt.Fprintf(file, "\t\tif filter.Gte != nil {\n")
		fmt.Fprintf(file, "\t\t\tresult[%q] = builder.Gte(*filter.Gte)\n", fieldName)
		fmt.Fprintf(file, "\t\t}\n")
		fmt.Fprintf(file, "\t\tif filter.Lt != nil {\n")
		fmt.Fprintf(file, "\t\t\tresult[%q] = builder.Lt(*filter.Lt)\n", fieldName)
		fmt.Fprintf(file, "\t\t}\n")
		fmt.Fprintf(file, "\t\tif filter.Lte != nil {\n")
		fmt.Fprintf(file, "\t\t\tresult[%q] = builder.Lte(*filter.Lte)\n", fieldName)
		fmt.Fprintf(file, "\t\t}\n")
		fmt.Fprintf(file, "\t\tif len(filter.In) > 0 {\n")
		fmt.Fprintf(file, "\t\t\tvalues := make([]interface{}, len(filter.In))\n")
		fmt.Fprintf(file, "\t\t\tfor i, v := range filter.In {\n")
		fmt.Fprintf(file, "\t\t\t\tvalues[i] = v\n")
		fmt.Fprintf(file, "\t\t\t}\n")
		fmt.Fprintf(file, "\t\t\tresult[%q] = builder.In(values...)\n", fieldName)
		fmt.Fprintf(file, "\t\t}\n")
		fmt.Fprintf(file, "\t\tif len(filter.NotIn) > 0 {\n")
		fmt.Fprintf(file, "\t\t\tvalues := make([]interface{}, len(filter.NotIn))\n")
		fmt.Fprintf(file, "\t\t\tfor i, v := range filter.NotIn {\n")
		fmt.Fprintf(file, "\t\t\t\tvalues[i] = v\n")
		fmt.Fprintf(file, "\t\t\t}\n")
		fmt.Fprintf(file, "\t\t\tresult[%q] = builder.NotIn(values...)\n", fieldName)
		fmt.Fprintf(file, "\t\t}\n")
		fmt.Fprintf(file, "\t\tif filter.IsNull != nil && *filter.IsNull {\n")
		fmt.Fprintf(file, "\t\t\tresult[%q] = builder.IsNull()\n", fieldName)
		fmt.Fprintf(file, "\t\t}\n")
		fmt.Fprintf(file, "\t\tif filter.IsNotNull != nil && *filter.IsNotNull {\n")
		fmt.Fprintf(file, "\t\t\tresult[%q] = builder.IsNotNull()\n", fieldName)
		fmt.Fprintf(file, "\t\t}\n")
	case "BooleanFilter":
		fmt.Fprintf(file, "\t\tif filter.Equals != nil {\n")
		fmt.Fprintf(file, "\t\t\tresult[%q] = *filter.Equals\n", fieldName)
		fmt.Fprintf(file, "\t\t}\n")
		fmt.Fprintf(file, "\t\tif filter.NotEquals != nil {\n")
		fmt.Fprintf(file, "\t\t\tresult[%q] = builder.NotEquals(*filter.NotEquals)\n", fieldName)
		fmt.Fprintf(file, "\t\t}\n")
		fmt.Fprintf(file, "\t\tif filter.IsNull != nil && *filter.IsNull {\n")
		fmt.Fprintf(file, "\t\t\tresult[%q] = builder.IsNull()\n", fieldName)
		fmt.Fprintf(file, "\t\t}\n")
		fmt.Fprintf(file, "\t\tif filter.IsNotNull != nil && *filter.IsNotNull {\n")
		fmt.Fprintf(file, "\t\t\tresult[%q] = builder.IsNotNull()\n", fieldName)
		fmt.Fprintf(file, "\t\t}\n")
	case "DateTimeFilter":
		fmt.Fprintf(file, "\t\tif filter.Equals != nil {\n")
		fmt.Fprintf(file, "\t\t\tresult[%q] = *filter.Equals\n", fieldName)
		fmt.Fprintf(file, "\t\t}\n")
		fmt.Fprintf(file, "\t\tif filter.NotEquals != nil {\n")
		fmt.Fprintf(file, "\t\t\tresult[%q] = builder.NotEquals(*filter.NotEquals)\n", fieldName)
		fmt.Fprintf(file, "\t\t}\n")
		fmt.Fprintf(file, "\t\tif filter.Gt != nil {\n")
		fmt.Fprintf(file, "\t\t\tresult[%q] = builder.Gt(*filter.Gt)\n", fieldName)
		fmt.Fprintf(file, "\t\t}\n")
		fmt.Fprintf(file, "\t\tif filter.Gte != nil {\n")
		fmt.Fprintf(file, "\t\t\tresult[%q] = builder.Gte(*filter.Gte)\n", fieldName)
		fmt.Fprintf(file, "\t\t}\n")
		fmt.Fprintf(file, "\t\tif filter.Lt != nil {\n")
		fmt.Fprintf(file, "\t\t\tresult[%q] = builder.Lt(*filter.Lt)\n", fieldName)
		fmt.Fprintf(file, "\t\t}\n")
		fmt.Fprintf(file, "\t\tif filter.Lte != nil {\n")
		fmt.Fprintf(file, "\t\t\tresult[%q] = builder.Lte(*filter.Lte)\n", fieldName)
		fmt.Fprintf(file, "\t\t}\n")
		fmt.Fprintf(file, "\t\tif filter.IsNull != nil && *filter.IsNull {\n")
		fmt.Fprintf(file, "\t\t\tresult[%q] = builder.IsNull()\n", fieldName)
		fmt.Fprintf(file, "\t\t}\n")
		fmt.Fprintf(file, "\t\tif filter.IsNotNull != nil && *filter.IsNotNull {\n")
		fmt.Fprintf(file, "\t\t\tresult[%q] = builder.IsNotNull()\n", fieldName)
		fmt.Fprintf(file, "\t\t}\n")
	case "JsonFilter":
		fmt.Fprintf(file, "\t\tif filter.Equals != nil {\n")
		fmt.Fprintf(file, "\t\t\tresult[%q] = *filter.Equals\n", fieldName)
		fmt.Fprintf(file, "\t\t}\n")
		fmt.Fprintf(file, "\t\tif filter.NotEquals != nil {\n")
		fmt.Fprintf(file, "\t\t\tresult[%q] = builder.NotEquals(*filter.NotEquals)\n", fieldName)
		fmt.Fprintf(file, "\t\t}\n")
		fmt.Fprintf(file, "\t\tif filter.IsNull != nil && *filter.IsNull {\n")
		fmt.Fprintf(file, "\t\t\tresult[%q] = builder.IsNull()\n", fieldName)
		fmt.Fprintf(file, "\t\t}\n")
		fmt.Fprintf(file, "\t\tif filter.IsNotNull != nil && *filter.IsNotNull {\n")
		fmt.Fprintf(file, "\t\t\tresult[%q] = builder.IsNotNull()\n", fieldName)
		fmt.Fprintf(file, "\t\t}\n")
	case "BytesFilter":
		fmt.Fprintf(file, "\t\tif filter.Equals != nil {\n")
		fmt.Fprintf(file, "\t\t\tresult[%q] = *filter.Equals\n", fieldName)
		fmt.Fprintf(file, "\t\t}\n")
		fmt.Fprintf(file, "\t\tif filter.NotEquals != nil {\n")
		fmt.Fprintf(file, "\t\t\tresult[%q] = builder.NotEquals(*filter.NotEquals)\n", fieldName)
		fmt.Fprintf(file, "\t\t}\n")
		fmt.Fprintf(file, "\t\tif filter.IsNull != nil && *filter.IsNull {\n")
		fmt.Fprintf(file, "\t\t\tresult[%q] = builder.IsNull()\n", fieldName)
		fmt.Fprintf(file, "\t\t}\n")
		fmt.Fprintf(file, "\t\tif filter.IsNotNull != nil && *filter.IsNotNull {\n")
		fmt.Fprintf(file, "\t\t\tresult[%q] = builder.IsNotNull()\n", fieldName)
		fmt.Fprintf(file, "\t\t}\n")
	default:
		// For unknown filter types, try to use Equals if available
		fmt.Fprintf(file, "\t\tif filter.Equals != nil {\n")
		fmt.Fprintf(file, "\t\t\tresult[%q] = *filter.Equals\n", fieldName)
		fmt.Fprintf(file, "\t\t}\n")
	}
}

// determineQueryImports determines which imports are needed for query files
func determineQueryImports(userModule, outputDir string) []string {
	// Calculate import paths for generated packages
	modelsPath, _, inputsPath, err := calculateImportPath(userModule, outputDir)
	if err != nil {
		// Fallback to old paths if detection fails
		modelsPath = "github.com/carlosnayan/prisma-go-client/db/models"
		inputsPath = "github.com/carlosnayan/prisma-go-client/db/inputs"
	}

	// context is always needed for all query methods
	// builder is always needed for Query embedding
	// models is always needed for type references
	// inputs is needed for WhereInput
	return []string{
		"context",
		"github.com/carlosnayan/prisma-go-client/builder",
		modelsPath,
		inputsPath,
	}
}
