package generator

import (
	"fmt"
	"os"
	"path/filepath"

	"github.com/carlosnayan/prisma-go-client/internal/parser"
)

// GenerateQueries generates type-safe query builders for each model
func GenerateQueries(schema *parser.Schema, outputDir string) error {
	queriesDir := filepath.Join(outputDir, "queries")
	if err := os.MkdirAll(queriesDir, 0755); err != nil {
		return fmt.Errorf("failed to create queries directory: %w", err)
	}

	// Detect user module
	userModule, err := detectUserModule(outputDir)
	if err != nil {
		return fmt.Errorf("failed to detect user module: %w", err)
	}

	// Generate query_result.go
	queryResultFile := filepath.Join(queriesDir, "query_result.go")
	if err := generateQueryResultFile(queryResultFile, userModule, outputDir); err != nil {
		return fmt.Errorf("failed to generate query_result.go: %w", err)
	}

	// Generate query files for each model
	for _, model := range schema.Models {
		queryFile := filepath.Join(queriesDir, toSnakeCase(model.Name)+"_query.go")
		if err := generateQueryFile(queryFile, model, schema, userModule, outputDir); err != nil {
			return fmt.Errorf("failed to generate query for %s: %w", model.Name, err)
		}
	}

	return nil
}

// generateQueryResultFile generates the file with QueryResult type using templates
func generateQueryResultFile(filePath string, userModule, outputDir string) error {
	// Calculate local import path for builder
	builderPath, _, err := calculateLocalImportPath(userModule, outputDir)
	if err != nil {
		builderPath = "github.com/carlosnayan/prisma-go-client/generated/builder"
	}

	// Prepare template data
	data := QueryResultTemplateData{
		BuilderPath: builderPath,
	}

	// Generate using template
	return executeModelTemplate(filePath, "queries", "queries", "query_result.tmpl", data)
}

// generateQueryFile generates the query builder file for a model using templates
func generateQueryFile(filePath string, model *parser.Model, schema *parser.Schema, userModule, outputDir string) error {
	// Determine required imports
	imports := determineQueryImports(userModule, outputDir)

	// Separate stdlib and third-party imports
	stdlib := make([]string, 0, len(imports))
	thirdParty := make([]string, 0, len(imports))

	for _, imp := range imports {
		if isStdlibImport(imp) {
			stdlib = append(stdlib, imp)
		} else {
			thirdParty = append(thirdParty, imp)
		}
	}

	// Calculate import paths
	modelsPath, _, inputsPath, err := calculateImportPath(userModule, outputDir)
	if err != nil {
		modelsPath = "github.com/carlosnayan/prisma-go-client/generated/models"
		inputsPath = "github.com/carlosnayan/prisma-go-client/generated/inputs"
	}

	builderPath, _, err := calculateLocalImportPath(userModule, outputDir)
	if err != nil {
		builderPath = "github.com/carlosnayan/prisma-go-client/generated/builder"
	}

	// Prepare fields for filter conversion
	fields := make([]FieldFilterInfo, 0)
	for _, field := range model.Fields {
		if isRelation(field, schema) {
			continue
		}
		fieldName := toPascalCase(field.Name)
		// Get the actual database column name (check for @map attribute)
		dbFieldName := field.Name
		for _, attr := range field.Attributes {
			if attr.Name == "map" && len(attr.Arguments) > 0 {
				if val, ok := attr.Arguments[0].Value.(string); ok {
					dbFieldName = val
					break
				}
			}
		}
		filterType := getFilterType(field.Type)

		fields = append(fields, FieldFilterInfo{
			FieldName:   fieldName,
			DBFieldName: dbFieldName,
			FilterType:  filterType,
		})
	}

	// Prepare select fields
	selectFields := make([]SelectFieldInfo, 0)
	for _, field := range model.Fields {
		if isRelation(field, schema) {
			continue
		}
		fieldName := toPascalCase(field.Name)
		// Get the actual database column name (check for @map attribute)
		columnName := field.Name
		for _, attr := range field.Attributes {
			if attr.Name == "map" && len(attr.Arguments) > 0 {
				if val, ok := attr.Arguments[0].Value.(string); ok {
					columnName = val
					break
				}
			}
		}
		selectFields = append(selectFields, SelectFieldInfo{
			FieldName:  fieldName,
			ColumnName: columnName,
		})
	}

	// Prepare update fields
	updateFields := make([]UpdateFieldInfo, 0)
	for _, field := range model.Fields {
		if isAutoGenerated(field) || isPrimaryKey(field) || isRelation(field, schema) {
			continue
		}
		fieldName := toPascalCase(field.Name)
		// Get the actual database column name (check for @map attribute)
		dbFieldName := field.Name
		for _, attr := range field.Attributes {
			if attr.Name == "map" && len(attr.Arguments) > 0 {
				if val, ok := attr.Arguments[0].Value.(string); ok {
					dbFieldName = val
					break
				}
			}
		}

		// Determine if the field in the model is a pointer type
		// A field is a pointer in the model if it's optional and uses a pointer type
		// Exception: Json and Bytes types don't use pointers even when optional
		isPointer := false
		if field.Type != nil && field.Type.IsOptional {
			// Json and Bytes don't use pointers in models, even when optional
			if field.Type.Name == "Json" || field.Type.Name == "Bytes" {
				isPointer = false
			} else {
				typeMapping := parser.GetTypeGoMapping()
				nullableMapping := parser.GetTypeGoMappingNullable()
				if _, ok := typeMapping[field.Type.Name]; ok {
					// Check if the type has a nullable/pointer variant
					// If it does, the model will use a pointer for optional fields
					if _, hasNullable := nullableMapping[field.Type.Name]; hasNullable {
						isPointer = true
					}
				} else {
					// For unknown types, assume pointer if optional
					isPointer = true
				}
			}
		}

		updateFields = append(updateFields, UpdateFieldInfo{
			FieldName:   fieldName,
			DBFieldName: dbFieldName,
			IsPointer:   isPointer,
		})
	}

	// Prepare create fields
	createFields := make([]CreateFieldInfo, 0)
	for _, field := range model.Fields {
		if isAutoGenerated(field) || isRelation(field, schema) {
			continue
		}
		fieldName := toPascalCase(field.Name)
		isOptional := field.Type != nil && field.Type.IsOptional
		isNonPointerOptional := isNonPointerOptionalType(field.Type)
		hasDefault := hasDefaultValue(field)
		// Field is required if: not optional AND no default value
		isRequired := !isOptional && !hasDefault

		createFields = append(createFields, CreateFieldInfo{
			FieldName:            fieldName,
			IsOptional:           isOptional,
			IsRequired:           isRequired,
			IsNonPointerOptional: isNonPointerOptional,
		})
	}

	// Get model metadata
	columns := getModelColumns(model, schema)
	primaryKey := getPrimaryKey(model)
	tableName := getTableName(model)

	// Prepare template data
	data := QueryTemplateData{
		ModelName:         model.Name,
		PascalName:        toPascalCase(model.Name),
		StdlibImports:     stdlib,
		ThirdPartyImports: thirdParty,
		BuilderPath:       builderPath,
		ModelsPath:        modelsPath,
		InputsPath:        inputsPath,
		Fields:            fields,
		SelectFields:      selectFields,
		UpdateFields:      updateFields,
		CreateFields:      createFields,
		Columns:           columns,
		PrimaryKey:        primaryKey,
		TableName:         tableName,
	}

	// Define template order
	templateNames := []string{
		"imports.tmpl",
		"query_struct.tmpl",
		"basic_methods.tmpl",
		"where_input_converter.tmpl",
		"apply_where_helper.tmpl",
		"findfirst_builder.tmpl",
		"findmany_builder.tmpl",
		"count_builder.tmpl",
		"delete_builder.tmpl",
		"update_builder.tmpl",
		"updatemany_builder.tmpl",
		"create_builder.tmpl",
		"createmany_builder.tmpl",
	}

	// Generate query file using templates
	return executeQueryTemplates(filePath, templateNames, data)
}

// isNonPointerOptionalType checks if a field type doesn't use pointers in models
// even when optional (json.RawMessage and []byte)
func isNonPointerOptionalType(fieldType *parser.FieldType) bool {
	if fieldType == nil {
		return false
	}
	// Json and Bytes types don't use pointers in models even when optional
	return fieldType.Name == "Json" || fieldType.Name == "Bytes"
}

// hasDefaultValue checks if a field has a @default attribute
func hasDefaultValue(field *parser.ModelField) bool {
	for _, attr := range field.Attributes {
		if attr.Name == "default" {
			return true
		}
	}
	return false
}

// determineQueryImports determines which imports are needed for query files
func determineQueryImports(userModule, outputDir string) []string {
	// Calculate import paths for generated packages
	modelsPath, _, inputsPath, err := calculateImportPath(userModule, outputDir)
	if err != nil {
		// Fallback to old paths if detection fails
		modelsPath = "github.com/carlosnayan/prisma-go-client/generated/models"
		inputsPath = "github.com/carlosnayan/prisma-go-client/generated/inputs"
	}

	// Calculate local import path for builder (standalone package)
	builderPath, _, err := calculateLocalImportPath(userModule, outputDir)
	if err != nil {
		// Fallback to old path if detection fails
		builderPath = "github.com/carlosnayan/prisma-go-client/generated/builder"
	}

	// context is always needed for all query methods
	// fmt is needed for fmt.Errorf in builders
	// reflect is needed for Scan() method
	// strings is needed for buildColumnToFieldMapForScan (strings.Index)
	// builder is always needed for Query embedding
	// models is always needed for type references
	// inputs is needed for WhereInput
	return []string{
		"context",
		"fmt",
		"reflect",
		"strings",
		builderPath,
		modelsPath,
		inputsPath,
	}
}
