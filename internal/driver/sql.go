package driver

import (
	"context"
	"database/sql"
)

// SQLDBAdapter adapts *sql.DB to the driver.DB interface
// This is used for MySQL and SQLite via database/sql
type SQLDBAdapter struct {
	db *sql.DB
}

// NewSQLDB creates a new adapter from *sql.DB
func NewSQLDB(db *sql.DB) DB {
	return &SQLDBAdapter{db: db}
}

// Exec executes a query that doesn't return rows
func (a *SQLDBAdapter) Exec(ctx context.Context, query string, args ...interface{}) (Result, error) {
	result, err := a.db.ExecContext(ctx, query, args...)
	if err != nil {
		return nil, err
	}
	return &SQLResult{result: result}, nil
}

// Query executes a query that returns multiple rows
func (a *SQLDBAdapter) Query(ctx context.Context, query string, args ...interface{}) (Rows, error) {
	rows, err := a.db.QueryContext(ctx, query, args...)
	if err != nil {
		return nil, err
	}
	return &SQLRows{rows: rows}, nil
}

// QueryRow executes a query that returns a single row
func (a *SQLDBAdapter) QueryRow(ctx context.Context, query string, args ...interface{}) Row {
	row := a.db.QueryRowContext(ctx, query, args...)
	return &SQLRow{row: row}
}

// Begin starts a transaction
func (a *SQLDBAdapter) Begin(ctx context.Context) (Tx, error) {
	tx, err := a.db.BeginTx(ctx, nil)
	if err != nil {
		return nil, err
	}
	return &SQLTx{tx: tx}, nil
}

// SQLDB returns the underlying *sql.DB
func (a *SQLDBAdapter) SQLDB() *sql.DB {
	return a.db
}

// Close closes the database connection
// Note: sql.DB.Close() error is ignored to match interface signature
func (a *SQLDBAdapter) Close() {
	_ = a.db.Close()
}

// SQLResult wraps sql.Result
type SQLResult struct {
	result sql.Result
}

// RowsAffected returns the number of rows affected
func (r *SQLResult) RowsAffected() int64 {
	rows, _ := r.result.RowsAffected()
	return rows
}

// LastInsertId returns the integer generated by the database
func (r *SQLResult) LastInsertId() (int64, error) {
	return r.result.LastInsertId()
}

// SQLRows wraps sql.Rows
type SQLRows struct {
	rows *sql.Rows
}

// Close closes the rows iterator
func (r *SQLRows) Close() {
	r.rows.Close()
}

// Err returns any error that occurred during iteration
func (r *SQLRows) Err() error {
	return r.rows.Err()
}

// Next prepares the next result row for reading
func (r *SQLRows) Next() bool {
	return r.rows.Next()
}

// Scan copies the columns in the current row into the values pointed at by dest
func (r *SQLRows) Scan(dest ...interface{}) error {
	return r.rows.Scan(dest...)
}

// SQLRow wraps sql.Row
type SQLRow struct {
	row *sql.Row
}

// Scan copies the columns in the current row into the values pointed at by dest
func (r *SQLRow) Scan(dest ...interface{}) error {
	return r.row.Scan(dest...)
}

// SQLTx wraps sql.Tx
type SQLTx struct {
	tx *sql.Tx
}

// Commit commits the transaction
func (t *SQLTx) Commit(ctx context.Context) error {
	return t.tx.Commit()
}

// Rollback rolls back the transaction
func (t *SQLTx) Rollback(ctx context.Context) error {
	return t.tx.Rollback()
}

// Exec executes a query that doesn't return rows
func (t *SQLTx) Exec(ctx context.Context, query string, args ...interface{}) (Result, error) {
	result, err := t.tx.ExecContext(ctx, query, args...)
	if err != nil {
		return nil, err
	}
	return &SQLResult{result: result}, nil
}

// Query executes a query that returns multiple rows
func (t *SQLTx) Query(ctx context.Context, query string, args ...interface{}) (Rows, error) {
	rows, err := t.tx.QueryContext(ctx, query, args...)
	if err != nil {
		return nil, err
	}
	return &SQLRows{rows: rows}, nil
}

// QueryRow executes a query that returns a single row
func (t *SQLTx) QueryRow(ctx context.Context, query string, args ...interface{}) Row {
	row := t.tx.QueryRowContext(ctx, query, args...)
	return &SQLRow{row: row}
}
