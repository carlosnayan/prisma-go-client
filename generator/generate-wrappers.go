package generator

import (
	"bufio"
	"fmt"
	"os"
	"path/filepath"
	"regexp"
	"strings"
)

// GenerateWrappers gera wrappers tipo Prisma para todas as tabelas
func GenerateWrappers(projectRoot string) error {
	migrationsDir := filepath.Join(projectRoot, "goose/migrations")
	wrappersDir := filepath.Join(projectRoot, "sqlc/generated/prisma")
	generatedDir := filepath.Join(projectRoot, "sqlc/generated")

	// Remover arquivos de wrappers antigos que estejam fora da pasta prisma
	if err := removeOldWrapperFiles(generatedDir, wrappersDir); err != nil {
		fmt.Printf("‚ö†Ô∏è  Aviso ao limpar arquivos antigos: %v\n", err)
	}

	// Criar diret√≥rio wrappers se n√£o existir
	if err := os.MkdirAll(wrappersDir, 0755); err != nil {
		return fmt.Errorf("erro ao criar diret√≥rio wrappers: %v", err)
	}

	// Ler todas as migrations para extrair informa√ß√µes das tabelas
	tables, err := parseMigrationsForWrappers(migrationsDir)
	if err != nil {
		return fmt.Errorf("erro ao parsear migrations: %v", err)
	}

	// Gerar wrapper para cada tabela
	var tableNames []string
	for tableName := range tables {
		tableNames = append(tableNames, tableName)
		if err := generateWrapper(wrappersDir, tableName); err != nil {
			return fmt.Errorf("erro ao gerar wrapper para %s: %v", tableName, err)
		}
	}

	// Gerar arquivo de registro dos wrappers
	if err := generateRegistry(wrappersDir, tableNames); err != nil {
		return fmt.Errorf("erro ao gerar registry: %v", err)
	}

	fmt.Printf("‚úÖ Wrappers gerados para %d tabelas\n", len(tableNames))
	return nil
}

func generateWrapper(wrappersDir, tableName string) error {
	fileName := fmt.Sprintf("%s/%s_query.go", wrappersDir, tableName)
	pascalName := toPascalCase(tableName)

	file, err := os.Create(fileName)
	if err != nil {
		return fmt.Errorf("erro ao criar arquivo %s: %v", fileName, err)
	}
	defer file.Close()

	fmt.Fprintf(file, "// Code generated by scripts/generate-wrappers.go. DO NOT EDIT.\n")
	fmt.Fprintf(file, "package prisma\n\n")
	fmt.Fprintf(file, "import (\n")
	fmt.Fprintf(file, "\t\"context\"\n")
	fmt.Fprintf(file, "\t\"prisma/internal/generated\"\n")
	fmt.Fprintf(file, "\t\"prisma/internal\"\n")
	fmt.Fprintf(file, "\t\"prisma/internal/generated/models\"\n")
	fmt.Fprintf(file, ")\n\n")

	// Struct do wrapper
	fmt.Fprintf(file, "// %sQuery - Wrapper para queries da tabela %s\n", pascalName, tableName)
	fmt.Fprintf(file, "type %sQuery struct {\n", pascalName)
	fmt.Fprintf(file, "\tqueries *generated.Queries\n")
	fmt.Fprintf(file, "\tbuilder *sqlc.TableQueryBuilder\n")
	fmt.Fprintf(file, "}\n\n")

	// FindFirst
	modelName := toPascalCase(tableName)
	fmt.Fprintf(file, "// FindFirst encontra o primeiro registro que atende √†s condi√ß√µes\n")
	fmt.Fprintf(file, "func (q *%sQuery) FindFirst(ctx context.Context, where sqlc.Where) (*models.%s, error) {\n", pascalName, modelName)
	fmt.Fprintf(file, "\tresult, err := q.builder.FindFirst(ctx, where)\n")
	fmt.Fprintf(file, "\tif err != nil {\n")
	fmt.Fprintf(file, "\t\treturn nil, err\n")
	fmt.Fprintf(file, "\t}\n")
	fmt.Fprintf(file, "\tif result == nil {\n")
	fmt.Fprintf(file, "\t\treturn nil, nil\n")
	fmt.Fprintf(file, "\t}\n")
	fmt.Fprintf(file, "\tmodel := result.(models.%s)\n", modelName)
	fmt.Fprintf(file, "\treturn &model, nil\n")
	fmt.Fprintf(file, "}\n\n")

	// FindMany
	fmt.Fprintf(file, "// FindMany encontra m√∫ltiplos registros\n")
	fmt.Fprintf(file, "func (q *%sQuery) FindMany(ctx context.Context, opts sqlc.QueryOptions) ([]models.%s, error) {\n", pascalName, modelName)
	fmt.Fprintf(file, "\tresult, err := q.builder.FindMany(ctx, opts)\n")
	fmt.Fprintf(file, "\tif err != nil {\n")
	fmt.Fprintf(file, "\t\treturn nil, err\n")
	fmt.Fprintf(file, "\t}\n")
	fmt.Fprintf(file, "\tif result == nil {\n")
	fmt.Fprintf(file, "\t\treturn []models.%s{}, nil\n", modelName)
	fmt.Fprintf(file, "\t}\n")
	fmt.Fprintf(file, "\tmodels := result.([]models.%s)\n", modelName)
	fmt.Fprintf(file, "\treturn models, nil\n")
	fmt.Fprintf(file, "}\n\n")

	// Count
	fmt.Fprintf(file, "// Count conta registros que atende √†s condi√ß√µes\n")
	fmt.Fprintf(file, "func (q *%sQuery) Count(ctx context.Context, where sqlc.Where) (int, error) {\n", pascalName)
	fmt.Fprintf(file, "\treturn q.builder.Count(ctx, where)\n")
	fmt.Fprintf(file, "}\n\n")

	// Create
	fmt.Fprintf(file, "// Create insere um novo registro na tabela\n")
	fmt.Fprintf(file, "func (q *%sQuery) Create(ctx context.Context, data interface{}) (*models.%s, error) {\n", pascalName, modelName)
	fmt.Fprintf(file, "\tresult, err := q.builder.Create(ctx, data)\n")
	fmt.Fprintf(file, "\tif err != nil {\n")
	fmt.Fprintf(file, "\t\treturn nil, err\n")
	fmt.Fprintf(file, "\t}\n")
	fmt.Fprintf(file, "\tif result == nil {\n")
	fmt.Fprintf(file, "\t\treturn nil, nil\n")
	fmt.Fprintf(file, "\t}\n")
	fmt.Fprintf(file, "\tmodel := result.(models.%s)\n", modelName)
	fmt.Fprintf(file, "\treturn &model, nil\n")
	fmt.Fprintf(file, "}\n\n")

	// Update
	fmt.Fprintf(file, "// Update atualiza um registro por primary key\n")
	fmt.Fprintf(file, "func (q *%sQuery) Update(ctx context.Context, id interface{}, data interface{}) (*models.%s, error) {\n", pascalName, modelName)
	fmt.Fprintf(file, "\tresult, err := q.builder.Update(ctx, id, data)\n")
	fmt.Fprintf(file, "\tif err != nil {\n")
	fmt.Fprintf(file, "\t\treturn nil, err\n")
	fmt.Fprintf(file, "\t}\n")
	fmt.Fprintf(file, "\tif result == nil {\n")
	fmt.Fprintf(file, "\t\treturn nil, nil\n")
	fmt.Fprintf(file, "\t}\n")
	fmt.Fprintf(file, "\tmodel := result.(models.%s)\n", modelName)
	fmt.Fprintf(file, "\treturn &model, nil\n")
	fmt.Fprintf(file, "}\n\n")

	// Delete
	fmt.Fprintf(file, "// Delete remove um registro (soft delete se tiver deleted_at, sen√£o hard delete)\n")
	fmt.Fprintf(file, "func (q *%sQuery) Delete(ctx context.Context, id interface{}) error {\n", pascalName)
	fmt.Fprintf(file, "\treturn q.builder.Delete(ctx, id)\n")
	fmt.Fprintf(file, "}\n\n")

	fmt.Printf("‚úÖ Gerado: %s\n", fileName)
	return nil
}

func generateRegistry(wrappersDir string, tableNames []string) error {
	fileName := wrappersDir + "/registry.go"

	file, err := os.Create(fileName)
	if err != nil {
		return fmt.Errorf("erro ao criar arquivo %s: %v", fileName, err)
	}
	defer file.Close()

	fmt.Fprintf(file, "// Code generated by scripts/generate-wrappers.go. DO NOT EDIT.\n")
	fmt.Fprintf(file, "package prisma\n\n")
	fmt.Fprintf(file, "import (\n")
	fmt.Fprintf(file, "\t\"prisma/internal/generated\"\n")
	fmt.Fprintf(file, "\t\"prisma/internal\"\n")
	fmt.Fprintf(file, "\t\"prisma/internal/generated/models\"\n")
	fmt.Fprintf(file, "\t\"reflect\"\n")
	fmt.Fprintf(file, ")\n\n")

	// Gerar fun√ß√µes helper para cada tabela (n√£o m√©todos, pois n√£o podemos adicionar em tipos n√£o-locais)
	// Nota: O usu√°rio precisa passar o DBTX diretamente ou usar uma fun√ß√£o helper que extrai do Queries
	for _, tableName := range tableNames {
		pascalName := toPascalCase(tableName)

		modelName := toPascalCase(tableName)
		fmt.Fprintf(file, "// %s retorna o query builder para a tabela %s\n", pascalName, tableName)
		fmt.Fprintf(file, "// Requer: db (generated.DBTX) e columns ([]string)\n")
		fmt.Fprintf(file, "func %s(db generated.DBTX, columns []string) *%sQuery {\n", pascalName, pascalName)
		fmt.Fprintf(file, "\tqueries := generated.New(db)\n")
		fmt.Fprintf(file, "\tmodelType := reflect.TypeOf(models.%s{})\n", modelName)
		fmt.Fprintf(file, "\tbuilder := sqlc.NewTableQueryBuilder(db, \"%s\", columns)\n", tableName)
		fmt.Fprintf(file, "\tbuilder.SetModelType(modelType)\n")
		fmt.Fprintf(file, "\treturn &%sQuery{\n", pascalName)
		fmt.Fprintf(file, "\t\tqueries: queries,\n")
		fmt.Fprintf(file, "\t\tbuilder: builder,\n")
		fmt.Fprintf(file, "\t}\n")
		fmt.Fprintf(file, "}\n\n")
	}

	fmt.Printf("‚úÖ Gerado: %s\n", fileName)
	return nil
}

// removeOldWrapperFiles remove arquivos *_query.go e registry.go que estejam
// diretamente em generated/ (fora da pasta prisma/)
func removeOldWrapperFiles(generatedDir, prismaDir string) error {
	// Obter o caminho absoluto de prismaDir para compara√ß√£o
	prismaAbsPath, err := filepath.Abs(prismaDir)
	if err != nil {
		return fmt.Errorf("erro ao obter caminho absoluto de prisma: %v", err)
	}

	// Listar todos os arquivos em generated/
	entries, err := os.ReadDir(generatedDir)
	if err != nil {
		return fmt.Errorf("erro ao ler diret√≥rio generated: %v", err)
	}

	var removedCount int
	for _, entry := range entries {
		// Pular diret√≥rios (incluindo prisma/)
		if entry.IsDir() {
			continue
		}

		fileName := entry.Name()

		// Verificar se √© um arquivo de wrapper (*_query.go) ou registry.go
		isQueryFile := strings.HasSuffix(fileName, "_query.go")
		isRegistryFile := fileName == "registry.go"

		if isQueryFile || isRegistryFile {
			filePath := filepath.Join(generatedDir, fileName)

			// Obter caminho absoluto do arquivo
			fileAbsPath, err := filepath.Abs(filePath)
			if err != nil {
				fmt.Printf("‚ö†Ô∏è  Erro ao obter caminho absoluto de %s: %v\n", filePath, err)
				continue
			}

			// Verificar se o arquivo N√ÉO est√° dentro de prisma/
			if !strings.HasPrefix(fileAbsPath, prismaAbsPath) {
				if err := os.Remove(filePath); err != nil {
					fmt.Printf("‚ö†Ô∏è  Erro ao remover %s: %v\n", filePath, err)
				} else {
					fmt.Printf("üóëÔ∏è  Removido: %s\n", filePath)
					removedCount++
				}
			}
		}
	}

	if removedCount > 0 {
		fmt.Printf("‚úÖ Removidos %d arquivo(s) antigo(s) de wrappers\n", removedCount)
	}

	return nil
}

// TableInfoWrapper cont√©m informa√ß√µes sobre uma tabela para wrappers
type TableInfoWrapper struct {
	Name       string
	PrimaryKey string
	HasDeleted bool
}

// parseMigrationsForWrappers l√™ todas as migrations e extrai informa√ß√µes das tabelas
func parseMigrationsForWrappers(migrationsDir string) (map[string]*TableInfoWrapper, error) {
	tables := make(map[string]*TableInfoWrapper)

	err := filepath.Walk(migrationsDir, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}

		if !strings.HasSuffix(path, ".sql") {
			return nil
		}

		table := parseMigrationForWrappers(path)
		if table != nil {
			// Se a tabela j√° existe, manter a existente (mesclar se necess√°rio)
			if _, ok := tables[table.Name]; !ok {
				tables[table.Name] = table
			}
		}

		return nil
	})

	return tables, err
}

// parseMigrationForWrappers parseia uma migration e retorna informa√ß√µes da tabela
func parseMigrationForWrappers(filePath string) *TableInfoWrapper {
	file, err := os.Open(filePath)
	if err != nil {
		return nil
	}
	defer file.Close()

	scanner := bufio.NewScanner(file)
	var inCreateTable bool
	var tableName string
	var tableContent strings.Builder
	var primaryKey string
	hasDeleted := false

	for scanner.Scan() {
		line := scanner.Text()
		trimmed := strings.TrimSpace(line)

		// Detectar CREATE TABLE
		createTableRegex := regexp.MustCompile(`(?i)CREATE\s+TABLE\s+(?:IF\s+NOT\s+EXISTS\s+)?["']?(\w+)["']?`)
		if matches := createTableRegex.FindStringSubmatch(trimmed); matches != nil {
			inCreateTable = true
			tableName = matches[1]
			tableContent.WriteString(line + "\n")
			continue
		}

		// Se estamos dentro de CREATE TABLE
		if inCreateTable {
			tableContent.WriteString(line + "\n")

			// Detectar fim da tabela
			if strings.HasPrefix(trimmed, ");") {
				break
			}
		}
	}

	if tableName == "" {
		return nil
	}

	// Parsear colunas do conte√∫do completo
	_, primaryKey, hasDeleted = parseTableColumnsForWrappers(tableContent.String())

	return &TableInfoWrapper{
		Name:       tableName,
		PrimaryKey: primaryKey,
		HasDeleted: hasDeleted,
	}
}

// parseTableColumnsForWrappers parseia as colunas de uma defini√ß√£o de tabela
func parseTableColumnsForWrappers(statement string) ([]string, string, bool) {
	var columns []string
	var primaryKey string
	hasDeleted := false

	columnLineRegex := regexp.MustCompile(`^\s*["']?(\w+)["']?\s+(\w+(?:\([^)]+\))?)\s*([^,)]*)`)

	lines := strings.Split(statement, "\n")
	inTable := false
	parenDepth := 0

	for _, line := range lines {
		trimmed := strings.TrimSpace(line)

		if strings.Contains(trimmed, "CREATE TABLE") {
			inTable = true
			continue
		}

		if !inTable {
			continue
		}

		parenDepth += strings.Count(line, "(") - strings.Count(line, ")")
		if strings.HasPrefix(trimmed, ");") || (parenDepth < 0 && strings.Contains(trimmed, ")")) {
			break
		}

		if strings.HasPrefix(trimmed, "CONSTRAINT") ||
			strings.HasPrefix(trimmed, "--") ||
			trimmed == "" ||
			strings.HasPrefix(trimmed, "CREATE") {
			continue
		}

		trimmed = strings.TrimSuffix(trimmed, ",")
		trimmed = strings.TrimSpace(trimmed)
		if trimmed == "" {
			continue
		}

		matches := columnLineRegex.FindStringSubmatch(trimmed)
		if len(matches) < 3 {
			continue
		}

		colName := strings.Trim(matches[1], `"'`)
		rest := matches[3]

		if isReservedWordForWrappers(colName) {
			continue
		}

		columns = append(columns, colName)

		if strings.Contains(rest, "PRIMARY KEY") {
			primaryKey = colName
		}

		if colName == "deleted_at" {
			hasDeleted = true
		}
	}

	return columns, primaryKey, hasDeleted
}

// isReservedWordForWrappers verifica se uma palavra √© reservada
func isReservedWordForWrappers(word string) bool {
	reserved := []string{"CREATE", "TABLE", "IF", "NOT", "EXISTS", "PRIMARY", "KEY", "FOREIGN", "CONSTRAINT", "CHECK", "DEFAULT", "NULL", "REFERENCES", "ON", "DELETE", "CASCADE", "UPDATE", "NO", "ACTION", "INDEX", "UNIQUE", "WHERE", "IS", "AND", "OR"}
	upper := strings.ToUpper(word)
	for _, r := range reserved {
		if upper == r {
			return true
		}
	}
	return false
}
