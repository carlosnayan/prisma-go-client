package generator

import (
	"bufio"
	"fmt"
	"os"
	"path/filepath"
	"regexp"
	"sort"
	"strings"
)

// GenerateDB gera o arquivo db.go com métodos para todas as tabelas
func GenerateDB(projectRoot string) error {
	migrationsDir := filepath.Join(projectRoot, "goose/migrations")
	dbFile := filepath.Join(projectRoot, "src/db/db.go")

	// Criar diretório db se não existir
	if err := os.MkdirAll(filepath.Dir(dbFile), 0755); err != nil {
		return fmt.Errorf("erro ao criar diretório db: %v", err)
	}

	// Ler todas as migrations para extrair informações das tabelas
	tables, err := parseMigrationsForDB(migrationsDir)
	if err != nil {
		return fmt.Errorf("erro ao parsear migrations: %v", err)
	}

	// Ordenar tabelas por nome
	var tableNames []string
	for name := range tables {
		tableNames = append(tableNames, name)
	}
	sort.Strings(tableNames)

	// Gerar arquivo db.go
	file, err := os.Create(dbFile)
	if err != nil {
		return fmt.Errorf("erro ao criar arquivo db.go: %v", err)
	}
	defer file.Close()

	// Header
	fmt.Fprintf(file, "// Code generated by scripts/generate-db.go. DO NOT EDIT.\n")
	fmt.Fprintf(file, "package db\n\n")
	fmt.Fprintf(file, "import (\n")
	fmt.Fprintf(file, "\t\"prisma/internal\"\n")
	fmt.Fprintf(file, "\t\"prisma/internal/generated\"\n")
	fmt.Fprintf(file, "\t\"prisma/internal/generated/prisma\"\n")
	fmt.Fprintf(file, "\t\"github.com/jackc/pgx/v5\"\n")
	fmt.Fprintf(file, "\t\"github.com/jackc/pgx/v5/pgxpool\"\n")
	fmt.Fprintf(file, ")\n\n")

	// Re-exportar tipos
	fmt.Fprintf(file, "// Re-exportar tipos do sqlc\n")
	fmt.Fprintf(file, "type Where = sqlc.Where\n")
	fmt.Fprintf(file, "type QueryOptions = sqlc.QueryOptions\n")
	fmt.Fprintf(file, "type OrderBy = sqlc.OrderBy\n")
	fmt.Fprintf(file, "type WhereOperator = sqlc.WhereOperator\n\n")
	fmt.Fprintf(file, "// Re-exportar funções helper para operadores WHERE\n")
	fmt.Fprintf(file, "var (\n")
	fmt.Fprintf(file, "\tIn     = sqlc.In\n")
	fmt.Fprintf(file, "\tNotIn  = sqlc.NotIn\n")
	fmt.Fprintf(file, "\tNotNull = sqlc.NotNull\n")
	fmt.Fprintf(file, "\tNull   = sqlc.Null\n")
	fmt.Fprintf(file, "\tEq     = sqlc.Eq\n")
	fmt.Fprintf(file, "\tNot    = sqlc.Not\n")
	fmt.Fprintf(file, "\tGt     = sqlc.Gt\n")
	fmt.Fprintf(file, "\tGte    = sqlc.Gte\n")
	fmt.Fprintf(file, "\tLt     = sqlc.Lt\n")
	fmt.Fprintf(file, "\tLte    = sqlc.Lte\n")
	fmt.Fprintf(file, "\tLike   = sqlc.Like\n")
	fmt.Fprintf(file, "\tILike  = sqlc.ILike\n")
	fmt.Fprintf(file, ")\n\n")

	// Struct Queries
	fmt.Fprintf(file, "// Queries é a interface principal para acessar os query builders\n")
	fmt.Fprintf(file, "type Queries struct {\n")
	fmt.Fprintf(file, "\tdb      generated.DBTX\n")
	fmt.Fprintf(file, "\tqueries *generated.Queries\n")
	fmt.Fprintf(file, "\traw     *sqlc.RawQuery\n")
	fmt.Fprintf(file, "}\n\n")

	// New
	fmt.Fprintf(file, "// New cria uma nova instância de Queries\n")
	fmt.Fprintf(file, "func New(db *pgxpool.Pool) *Queries {\n")
	fmt.Fprintf(file, "\tqueries := generated.New(db)\n")
	fmt.Fprintf(file, "\treturn &Queries{\n")
	fmt.Fprintf(file, "\t\tdb:      db,\n")
	fmt.Fprintf(file, "\t\tqueries: queries,\n")
	fmt.Fprintf(file, "\t\traw:     sqlc.NewRawQuery(db),\n")
	fmt.Fprintf(file, "\t}\n")
	fmt.Fprintf(file, "}\n\n")

	// WithTx
	fmt.Fprintf(file, "// WithTx cria uma nova instância de Queries com uma transação\n")
	fmt.Fprintf(file, "func (q *Queries) WithTx(tx pgx.Tx) *Queries {\n")
	fmt.Fprintf(file, "\tqueries := q.queries.WithTx(tx)\n")
	fmt.Fprintf(file, "\treturn &Queries{\n")
	fmt.Fprintf(file, "\t\tdb:      tx,\n")
	fmt.Fprintf(file, "\t\tqueries: queries,\n")
	fmt.Fprintf(file, "\t\traw:     sqlc.NewRawQuery(tx),\n")
	fmt.Fprintf(file, "\t}\n")
	fmt.Fprintf(file, "}\n\n")

	// Raw
	fmt.Fprintf(file, "// Raw retorna o query builder para SQL manual\n")
	fmt.Fprintf(file, "func (q *Queries) Raw() *sqlc.RawQuery {\n")
	fmt.Fprintf(file, "\treturn q.raw\n")
	fmt.Fprintf(file, "}\n\n")

	// Gerar métodos para cada tabela
	for _, tableName := range tableNames {
		pascalName := toPascalCase(tableName)
		queryType := pascalName + "Query"

		fmt.Fprintf(file, "// %s retorna o query builder para a tabela %s\n", pascalName, tableName)
		fmt.Fprintf(file, "func (q *Queries) %s() *prisma.%s {\n", pascalName, queryType)
		fmt.Fprintf(file, "\tcolumns := get%sColumns()\n", pascalName)
		fmt.Fprintf(file, "\treturn prisma.%s(q.db, columns)\n", pascalName)
		fmt.Fprintf(file, "}\n\n")
	}

	// Gerar funções helper para obter colunas
	fmt.Fprintf(file, "// Funções helper para obter colunas das tabelas\n\n")
	for _, tableName := range tableNames {
		table := tables[tableName]
		pascalName := toPascalCase(tableName)

		fmt.Fprintf(file, "func get%sColumns() []string {\n", pascalName)
		fmt.Fprintf(file, "\treturn []string{\n")
		for _, col := range table.Columns {
			fmt.Fprintf(file, "\t\t\"%s\",\n", col)
		}
		fmt.Fprintf(file, "\t}\n")
		fmt.Fprintf(file, "}\n\n")
	}

	fmt.Printf("✅ Gerado: %s\n", dbFile)
	return nil
}

// TableInfoDB contém informações sobre uma tabela para db.go
type TableInfoDB struct {
	Name    string
	Columns []string
}

// parseMigrationsForDB lê todas as migrations e extrai informações das tabelas
func parseMigrationsForDB(migrationsDir string) (map[string]*TableInfoDB, error) {
	tables := make(map[string]*TableInfoDB)

	err := filepath.Walk(migrationsDir, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}

		if !strings.HasSuffix(path, ".sql") {
			return nil
		}

		table := parseMigrationForDB(path)
		if table != nil {
			// Se a tabela já existe, mesclar colunas
			if existing, ok := tables[table.Name]; ok {
				// Mesclar colunas (evitar duplicatas)
				existingColumns := make(map[string]bool)
				for _, col := range existing.Columns {
					existingColumns[col] = true
				}
				for _, col := range table.Columns {
					if !existingColumns[col] {
						existing.Columns = append(existing.Columns, col)
					}
				}
			} else {
				tables[table.Name] = table
			}
		}

		return nil
	})

	return tables, err
}

// parseMigrationForDB parseia uma migration e retorna informações da tabela
func parseMigrationForDB(filePath string) *TableInfoDB {
	file, err := os.Open(filePath)
	if err != nil {
		return nil
	}
	defer file.Close()

	scanner := bufio.NewScanner(file)
	var inCreateTable bool
	var tableName string
	var tableContent strings.Builder

	for scanner.Scan() {
		line := scanner.Text()
		trimmed := strings.TrimSpace(line)

		// Detectar CREATE TABLE
		createTableRegex := regexp.MustCompile(`(?i)CREATE\s+TABLE\s+(?:IF\s+NOT\s+EXISTS\s+)?["']?(\w+)["']?`)
		if matches := createTableRegex.FindStringSubmatch(trimmed); matches != nil {
			inCreateTable = true
			tableName = matches[1]
			tableContent.WriteString(line + "\n")
			continue
		}

		// Se estamos dentro de CREATE TABLE
		if inCreateTable {
			tableContent.WriteString(line + "\n")

			// Detectar fim da tabela
			if strings.HasPrefix(trimmed, ");") {
				break
			}
		}
	}

	if tableName == "" {
		return nil
	}

	// Parsear colunas do conteúdo completo
	columns := parseTableColumnsForDB(tableContent.String())

	return &TableInfoDB{
		Name:    tableName,
		Columns: columns,
	}
}

// parseTableColumnsForDB parseia as colunas de uma definição de tabela
func parseTableColumnsForDB(statement string) []string {
	var columns []string

	columnLineRegex := regexp.MustCompile(`^\s*["']?(\w+)["']?\s+(\w+(?:\([^)]+\))?)\s*([^,)]*)`)

	lines := strings.Split(statement, "\n")
	inTable := false
	parenDepth := 0

	for _, line := range lines {
		trimmed := strings.TrimSpace(line)

		if strings.Contains(trimmed, "CREATE TABLE") {
			inTable = true
			continue
		}

		if !inTable {
			continue
		}

		parenDepth += strings.Count(line, "(") - strings.Count(line, ")")
		if strings.HasPrefix(trimmed, ");") || (parenDepth < 0 && strings.Contains(trimmed, ")")) {
			break
		}

		if strings.HasPrefix(trimmed, "CONSTRAINT") ||
			strings.HasPrefix(trimmed, "--") ||
			trimmed == "" ||
			strings.HasPrefix(trimmed, "CREATE") {
			continue
		}

		trimmed = strings.TrimSuffix(trimmed, ",")
		trimmed = strings.TrimSpace(trimmed)
		if trimmed == "" {
			continue
		}

		matches := columnLineRegex.FindStringSubmatch(trimmed)
		if len(matches) < 3 {
			continue
		}

		colName := strings.Trim(matches[1], `"'`)

		if isReservedWordForDB(colName) {
			continue
		}

		columns = append(columns, colName)
	}

	return columns
}

// isReservedWordForDB verifica se uma palavra é reservada
func isReservedWordForDB(word string) bool {
	reserved := []string{"CREATE", "TABLE", "IF", "NOT", "EXISTS", "PRIMARY", "KEY", "FOREIGN", "CONSTRAINT", "CHECK", "DEFAULT", "NULL", "REFERENCES", "ON", "DELETE", "CASCADE", "UPDATE", "NO", "ACTION", "INDEX", "UNIQUE", "WHERE", "IS", "AND", "OR"}
	upper := strings.ToUpper(word)
	for _, r := range reserved {
		if upper == r {
			return true
		}
	}
	return false
}

// toPascalCase converte snake_case para PascalCase
func toPascalCase(s string) string {
	parts := strings.Split(s, "_")
	var result strings.Builder
	for _, part := range parts {
		if len(part) > 0 {
			result.WriteString(strings.ToUpper(part[:1]) + strings.ToLower(part[1:]))
		}
	}
	return result.String()
}
