package generator

import (
	"fmt"
	"os"
	"path/filepath"
	"regexp"
	"strings"
)

// GenerateTypes gera tipos Create{Table}Input e Update{Table}Input baseados nas migrations
func GenerateTypes(projectRoot string) error {
	migrationsDir := filepath.Join(projectRoot, "goose/migrations")
	typesDir := filepath.Join(projectRoot, "sqlc/generated/types")

	// Criar diretório types se não existir
	if err := os.MkdirAll(typesDir, 0755); err != nil {
		return fmt.Errorf("erro ao criar diretório types: %v", err)
	}

	// Ler todas as migrations para extrair informações das tabelas
	tables, err := parseMigrationsForTypes(migrationsDir)
	if err != nil {
		return fmt.Errorf("erro ao parsear migrations: %v", err)
	}

	// Gerar tipos para cada tabela
	for tableName, tableInfo := range tables {
		typesFile := filepath.Join(typesDir, toSnakeCase(tableName)+"_input.go")

		if err := generateTypesFile(typesFile, tableName, tableInfo); err != nil {
			return fmt.Errorf("erro ao gerar tipos para %s: %v", tableName, err)
		}
		fmt.Printf("✅ Gerado: %s\n", typesFile)
	}

	return nil
}

// parseMigrationsForTypes lê todas as migrations e extrai informações das tabelas
func parseMigrationsForTypes(migrationsDir string) (map[string]*TableInfo, error) {
	tables := make(map[string]*TableInfo)

	err := filepath.Walk(migrationsDir, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}

		if !strings.HasSuffix(path, ".sql") {
			return nil
		}

		table := parseMigration(path)
		if table != nil {
			// Se a tabela já existe, mesclar colunas (migrations podem adicionar colunas)
			if existing, ok := tables[table.Name]; ok {
				existing.Columns = mergeColumns(existing.Columns, table.Columns)
			} else {
				tables[table.Name] = table
			}
		}

		return nil
	})

	return tables, err
}

// generateTypesFile gera o arquivo de tipos para uma tabela
func generateTypesFile(filePath, tableName string, tableInfo *TableInfo) error {
	file, err := os.Create(filePath)
	if err != nil {
		return fmt.Errorf("erro ao criar arquivo: %v", err)
	}
	defer file.Close()

	pascalName := toPascalCase(tableName)

	// Header do arquivo
	fmt.Fprintf(file, "// Code generated by scripts/generate-types.go. DO NOT EDIT.\n")
	fmt.Fprintf(file, "package types\n\n")

	// Coletar campos que serão incluídos nos tipos para determinar imports
	hasTime := false
	hasJSON := false

	// Verificar campos do Create
	for _, col := range tableInfo.Columns {
		// Pular: PK, created_at, updated_at (com default), deleted_at
		if col.Name == tableInfo.PrimaryKey ||
			col.Name == "created_at" ||
			col.Name == "updated_at" ||
			col.Name == "deleted_at" {
			continue
		}

		if strings.Contains(strings.ToUpper(col.Type), "TIMESTAMP") || strings.Contains(strings.ToUpper(col.Type), "DATE") {
			hasTime = true
		}
		if strings.Contains(strings.ToUpper(col.Type), "JSON") {
			hasJSON = true
		}
	}

	// Verificar campos do Update
	for _, col := range tableInfo.Columns {
		// Pular: PK, created_at, deleted_at
		if col.Name == tableInfo.PrimaryKey ||
			col.Name == "created_at" ||
			col.Name == "deleted_at" {
			continue
		}

		if strings.Contains(strings.ToUpper(col.Type), "TIMESTAMP") || strings.Contains(strings.ToUpper(col.Type), "DATE") {
			hasTime = true
		}
		if strings.Contains(strings.ToUpper(col.Type), "JSON") {
			hasJSON = true
		}
	}

	// Gerar imports apenas se necessário
	if hasTime || hasJSON {
		fmt.Fprintf(file, "import (\n")
		if hasTime {
			fmt.Fprintf(file, "\t\"time\"\n")
		}
		if hasJSON {
			fmt.Fprintf(file, "\t\"encoding/json\"\n")
		}
		fmt.Fprintf(file, ")\n\n")
	}

	// Gerar Create{Table}Input
	fmt.Fprintf(file, "// Create%sInput representa os dados para criar um novo %s\n", pascalName, tableName)
	fmt.Fprintf(file, "type Create%sInput struct {\n", pascalName)
	for _, col := range tableInfo.Columns {
		// Pular: PK, created_at, updated_at (com default), deleted_at
		if col.Name == tableInfo.PrimaryKey ||
			col.Name == "created_at" ||
			col.Name == "updated_at" ||
			col.Name == "deleted_at" {
			continue
		}

		// Se tem default, é opcional
		// Se é nullable, é opcional
		// Se é NOT NULL e não tem default, é obrigatório
		isOptional := col.Nullable || col.Default != ""

		fieldName := toPascalCase(col.Name)
		goType := sqlTypeToGoType(col.Type, col.Nullable || isOptional)

		fmt.Fprintf(file, "\t%s %s `json:\"%s\"`\n", fieldName, goType, col.Name)
	}
	fmt.Fprintf(file, "}\n\n")

	// Gerar Update{Table}Input
	fmt.Fprintf(file, "// Update%sInput representa os dados para atualizar um %s\n", pascalName, tableName)
	fmt.Fprintf(file, "type Update%sInput struct {\n", pascalName)
	for _, col := range tableInfo.Columns {
		// Pular: PK, created_at, deleted_at
		if col.Name == tableInfo.PrimaryKey ||
			col.Name == "created_at" ||
			col.Name == "deleted_at" {
			continue
		}

		// Todos os campos em Update são opcionais (ponteiros)
		fieldName := toPascalCase(col.Name)
		goType := sqlTypeToGoType(col.Type, true) // Sempre opcional em Update

		fmt.Fprintf(file, "\t%s %s `json:\"%s,omitempty\"`\n", fieldName, goType, col.Name)
	}
	fmt.Fprintf(file, "}\n\n")

	return nil
}

// sqlTypeToGoType converte um tipo SQL para um tipo Go
func sqlTypeToGoType(sqlType string, optional bool) string {
	baseType := strings.ToUpper(sqlType)
	baseType = regexp.MustCompile(`\([^)]+\)`).ReplaceAllString(baseType, "") // Remover parênteses

	var goType string

	switch {
	case strings.HasPrefix(baseType, "UUId"):
		goType = "string"
	case strings.HasPrefix(baseType, "TEXT") || strings.HasPrefix(baseType, "VARCHAR") || strings.HasPrefix(baseType, "CHAR"):
		goType = "string"
	case strings.HasPrefix(baseType, "INTEGER") || strings.HasPrefix(baseType, "INT"):
		goType = "int"
	case strings.HasPrefix(baseType, "BIGINT"):
		goType = "int64"
	case strings.HasPrefix(baseType, "SMALLINT"):
		goType = "int16"
	case strings.HasPrefix(baseType, "BOOLEAN") || strings.HasPrefix(baseType, "BOOL"):
		goType = "bool"
	case strings.HasPrefix(baseType, "TIMESTAMP") || strings.HasPrefix(baseType, "DATE"):
		goType = "time.Time"
	case strings.HasPrefix(baseType, "JSON") || strings.HasPrefix(baseType, "JSONB"):
		goType = "json.RawMessage"
	case strings.HasPrefix(baseType, "DECIMAL") || strings.HasPrefix(baseType, "NUMERIC") || strings.HasPrefix(baseType, "REAL") || strings.HasPrefix(baseType, "DOUBLE"):
		goType = "float64"
	case strings.HasPrefix(baseType, "FLOAT"):
		goType = "float32"
	default:
		// Para ENUMs e outros tipos, assumir string
		goType = "string"
	}

	// Se for opcional, adicionar ponteiro
	if optional {
		if goType == "time.Time" {
			goType = "*time.Time"
		} else if goType == "json.RawMessage" {
			goType = "*json.RawMessage"
		} else {
			goType = "*" + goType
		}
	}

	return goType
}

// toSnakeCase converte PascalCase para snake_case
func toSnakeCase(s string) string {
	var result strings.Builder
	for i, r := range s {
		if i > 0 && r >= 'A' && r <= 'Z' {
			result.WriteByte('_')
		}
		result.WriteRune(r)
	}
	return strings.ToLower(result.String())
}
